<!-- build time:Wed Jul 23 2025 00:53:31 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="http://amentiraz.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="http://amentiraz.github.io/atom.xml"><link rel="alternate" type="application/json" href="http://amentiraz.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="生物,学习笔记类,算法"><link rel="canonical" href="http://amentiraz.github.io/article/SpaGCN/"><title>SpaGCN - 论文 | Amentiraz =</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">SpaGCN</h1><div class="meta"><span class="item" title="创建时间：2024-11-11 09:42:59"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-11-11T09:42:59+08:00">2024-11-11</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>34k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>31 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Amentiraz</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925162917.png"></li><li class="item" data-background-image="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925124341.png"></li><li class="item" data-background-image="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925124403.png"></li><li class="item" data-background-image="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925124553.png"></li><li class="item" data-background-image="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925162941.png"></li><li class="item" data-background-image="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925162750.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/article/" itemprop="item" rel="index" title="分类于 论文"><span itemprop="name">论文</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://amentiraz.github.io/article/SpaGCN/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Lemon Sour"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><p>SpaGCN: Integrating gene expression, spatial location and histology to identify spatial domains and spatially variable genes by graph convolutional network.</p><p>主要利用了 spage2vec 方法对数据进行降维便于聚类，在拟合神经网络的时候利用 DEC 方法作为 loss 函数，创造了一种分辨 SVG 基因（提取 meta-gene）的方法。</p><span id="more"></span><p>生词基本上都记住了，这次就直接从文章入手吧。</p><h1 id="摘要"><a class="anchor" href="#摘要">#</a> 摘要</h1><p>Through graph convolution, SpaGCN aggregates gene expression of each spot from its neighboring spots, which enables the identification of spatial domains with coherent expression and histology.</p><p>we show it can detect genes with much more enriched spatial expression patterns than competing methods.</p><h1 id="introduction"><a class="anchor" href="#introduction">#</a> Introduction</h1><p>methods for SRT:</p><ul><li>in situ hybridization or sequencing-based technologies with single-cell resolution<ul><li>e.g. seqFISH, seqFISH+, MERFISH, STARmap and FISSEQ that measure the expression level for hundred to thousands of genes in cells within their tissue context.</li><li>因为能达到单细胞分辨率，这些技术适合于高精度分析，用于深入理解细胞在组织结构中的分布以及细胞间的相互作用。</li></ul></li><li>in situ capturing-based technologies with spatial barcoding followed by sequencing<ul><li>e.g. spatial transcriptomics(ST), SLIDE-seq, SLIDE-seqV2, HDST and 10x Visium that measure the expression level for thousands of genes in captured locations, referred to as spots.</li><li>由于通常只能定位到捕获区域的水平，这类技术的空间分辨率低于单细胞分辨率，但它们适合于大规模研究，因为能够同时检测数千个基因。</li></ul></li></ul><ol><li><p>identifying spatial domains account for spatial dependency ---- spatial dependency of gene expression:</p><ul><li>Hidden-Markov random field(HMRF)</li><li>stLearn</li><li>BayesSpace</li></ul><p>flaws: the lack of flexibility with different modalities has made the less versatile.</p><p>最直观的 SpaGCN 适用于 imaging-based 的数据，这几个不行。然而可以从 Benchmark 那篇文章看出来，这个 SpaGCN 对于 Multi-splice 的数据也是没辙。</p></li><li><p>Detect spatially variable genes(SVGs): Trendscreek, SpatialDE and SPARK.</p><ul><li>These methods examine each gene independently and return a P value to represent the spatial variability of a gene.</li><li>due to the lack of consideration of spatial domains, genes detected by these methods do not have guaranteed spatial expression patterns.</li></ul></li></ol><p>SpaGCN 同时考虑上述两种问题：</p><ul><li>SpaGCN first identifies spatial domains by integrating gene expression, spatial location and histology through the construction of an undirected weighted graph that represents the spatial dependency of the data.</li><li>For each spatial domain, SpaGCN then detects SVGs that are enriched in the domain.</li><li>By restricting the search space to spatial domains, the SVGs detected by SpaGCN are guaranteed to have spatial expression patterns.</li></ul><h1 id="result"><a class="anchor" href="#result">#</a> Result</h1><h2 id="overview-of-spagcn-and-evaluation"><a class="anchor" href="#overview-of-spagcn-and-evaluation">#</a> Overview of SpaGCN and evaluation</h2><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN1.jpg" alt=""></p><ol><li>SpaGCN first builds a graph to represent the relationship of all spots considering both spatial location and histology information.</li><li>SpaGCN utilizes a graph convolutional layer to aggregate gene expression information from neighboring spots.</li><li>SpaGCN uses the aggregated expression matrix to cluster spots using an unsupervised iterative clustring algorithm.</li></ol><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN2.jpg" alt=""></p><p>Each cluster is considered as a spatial domain from which SpaGCN then detects SVGs that are enriched in a domian by DE analysis.</p><p>When a single gene cannot mark the expression pattern of a domain, SpaGCN will construct a meta gene, formed by the combination of multiple genes, to represent the expression pattern of the domain.</p><h2 id="application-to-human-primary-pancreatic胰腺的-cancer-st-data"><a class="anchor" href="#application-to-human-primary-pancreatic胰腺的-cancer-st-data">#</a> Application to human primary pancreatic (胰腺的) cancer ST data</h2><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN3.jpg" alt=""><br>这张图利用各种算法对于 cancer region 的检测，相当于对比一下之前提到的第一个，分类任务<br>desmolasia: 结缔组织增生<br>Duct epithelium: 导管上皮<br>interstitium: 间质</p><p>说实话，我没看懂这图中 SpaGCN 比 Louvain 好在哪了，但是灵活性在 s 这个参数倒是体现的很好</p><p>parameter s, which controls the weight given to histology when detecting neighbors for each spot.</p><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN4.jpg" alt=""><br>接下来是检测 SVGs.<br>这张图代表了 Spatial expression pattern of SVGs detected by SpaGCN for domain 0 (AEBP1) and domain 1 (SERPINA1)</p><p>我最开始误以为这图里面就对应着有 3，8 个 SVGs，然而这个图代表的是其中某一个 SVG 的表征。SVG 的意思是 Spatially Variable genes，当它在不同的区域的基因表现是一样的时候，那么它就不是 SVG，如果它在不同的区域，基因的表现存在高表达，那么它就是 SVG。</p><p>In total, SpaGCN detected 12SVGs, with three, eight and one SVGs for domain0 , 1, 2, respectively</p><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN5.jpg" alt=""><br>Spatial expression patterns of genes KRT17, MMP11, SERPINA1, which form the meta gene for domain 2 (KRT17+MMP11-SERPINA1).</p><p>KRT17 functions as a tumor promoter and regulates proliferation in pancreatic cancer, and MMP11 is a prognostic biomarker for pancreatic cancer.</p><blockquote><p>SPARK and SpatialDE 检测出来 203 和 163 个 SVGs，但是他们的 P 或 Q values 偏斜 (skew) 到了 0.<br>在统计学和生物信息学中，<strong>p 值（p-value）</strong> 和<strong> q 值（q-value）</strong> 是用来衡量数据显著性的指标：</p><h3 id="1-p值p-value"><a class="anchor" href="#1-p值p-value">#</a> 1. <strong>P 值（p-value）</strong></h3><ul><li><strong>定义</strong>：p 值表示在假设原假设为真的情况下，观测到的数据或更极端数据的概率。</li><li><strong>解释</strong>：p 值用于检验数据是否具有统计显著性。一个较低的 p 值（例如小于 0.05）表明在原假设成立的情况下，观测到的结果极不可能，因此通常拒绝原假设。</li><li><strong>用途</strong>：常用于单次假设检验，帮助判断结果是否具有统计显著性。</li><li><strong>局限性</strong>：在多重假设检验（同时进行多个检验）中，单纯使用 p 值容易产生<strong>多重比较问题</strong>，即假阳性结果（false positives）增加。</li></ul><h3 id="2-q值q-value"><a class="anchor" href="#2-q值q-value">#</a> 2. <strong>Q 值（q-value）</strong></h3><ul><li><strong>定义</strong>：q 值是多重检验中的一个校正后的 p 值，代表的是 <strong>“错误发现率”（ False Discovery Rate, FDR）</strong> 。FDR 控制的是在所有拒绝原假设的检验中，错误拒绝的比例。</li><li><strong>解释</strong>：q 值提供了在多重假设检验下更严格的显著性判断标准，降低了假阳性结果。一个较低的 q 值（例如小于 0.05）表明该结果在多重比较下具有显著性。</li><li><strong>用途</strong>：常用于基因组学、转录组学等需要进行大量假设检验的领域，以校正多个检验带来的假阳性风险。</li></ul><h3 id="总结对比"><a class="anchor" href="#总结对比">#</a> 总结对比</h3><ul><li><strong>p 值</strong>：用于单次检验显著性，低 p 值意味着结果显著，但不校正多重检验。</li><li><strong>q 值</strong>：基于 p 值校正了多重检验带来的假阳性影响，更适合大规模检验场景。</li></ul></blockquote><p>然而它们的 Moran's I 和 Geary's C value 是远远低于 SpaGCN 的。<br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN6.jpg" alt=""><br>genes with smaller P or Q values do not necessarily show better spatial expression patterns than those with larger P or Q values.</p><h2 id="application-to-human-dorsolateral-prefrontal-cortex-10x-visium-data"><a class="anchor" href="#application-to-human-dorsolateral-prefrontal-cortex-10x-visium-data">#</a> Application to human dorsolateral prefrontal cortex 10x Visium data</h2><p>dorsomedial prefrontal cortex: 背侧前额叶<br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN7.jpg" alt=""><br>实际的效果</p><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN8.jpg" alt=""><br>b 图表示了考虑到所有 12 个 slices 后 the median ARI is 0.36 for stLearn, 0.42 for BayesSpace and 0.45 for SpaGCN.</p><p>In total, SpaGCN detected 67 SVGs, with 53 of them being specific to domain 5, which corresponds to white matter.Patterns of SVGs for other domains are not very clear.</p><p>These results indicate that gene expression profiles of spots from white matter are distinct from spots in the neuronal layers, while gene expression differences among the six neuronal layers are much smaller and more difficult to distinguish using individual marker genes.</p><p><strong>White Matter（白质）</strong> 是大脑和脊髓中的一种组织，主要由髓鞘包裹的神经纤维（轴突）组成，其颜色在肉眼观察下呈现白色。白质的主要功能是通过神经纤维连接大脑不同区域和大脑与脊髓之间的信号通路，起到信息传递的作用。</p><p>d 图: For three out of the six neuronal layers, SpaGCN detected a single SVG to mark that region.</p><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN9.jpg" alt=""><br>这是在检测它的 downstream（下游）的影响，利用 K-means 对它进行聚类。我们发现增加 SVGs 的数量并没有提高 SoatialDE 和 SPARK 的 ARIs 的值，证明了 the lack of spatial patterns for genes detected by SPARK and SpatialDE.</p><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN10.jpg" alt=""></p><p>SpaGCN was able to find domain-specific meta genes.<br>这个 meta 基因貌似并没有准确的定义，暂时将它理解为：指在特定组织区域、细胞群体或功能性领域中表现出独特表达模式的一组基因。</p><p>例如 FTH1,MBP,MT-CO3 and PLP1 是 Depleted gene</p><p>Depleted Genes（耗减基因）指的是在某个特定条件、组织区域、细胞类型或实验处理下，表达水平显著低于其他条件或区域的基因。</p><p>Enriched Genes（富集基因）是指在特定条件、样本组、组织区域或细胞类型中，基因的表达水平显著高于其他条件、区域或细胞类型的基因。</p><h2 id="application-to-mouse-posterior后面的-brain-10x-visium-data"><a class="anchor" href="#application-to-mouse-posterior后面的-brain-10x-visium-data">#</a> Application to mouse posterior (后面的) brain 10x Visium data</h2><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN11.png" alt=""></p><p>Louvain's clustering is similar to stLearn, BayesSpace and SpaGCN, but the spatial domains detected by the latter three methods are more spatially contiguous due too their ability to account for spatial dependency of gene expression.</p><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN12.png" alt=""></p><p>图 b: we performed subclustering analysis for spots in domain 5 detected by SpaGCN, which corresponds to the cortex.</p><p>图 c: The subdomians detected by SpaGCN agree well with the Allen Brain Institute reference atlas diagram of the mouse cortex.<br>可以看的出来 SpaGCN 在此例中的拟合效果比其它几种方法都要好</p><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN13.png" alt=""></p><p>d 图：Multiple domain adaptive filtering criteria implemented in SpaGCN allow it to eliminate false positive SVGs and ensure all detected SVGs have clear spatial expression patterns</p><p>e 图: Illustrate how the filtering in SpaGCN works, we use domains 1, 5 and 8 as an example.</p><p>对于 domain1 和 8，即使它们相邻，但是 SpaGCN 仍能很好的将它们区分出来。</p><p>domains 5 and 7, which would be contiguous in a three-dimensional(3D) reconstruction, are artifactually separated as a result of how the section was cut.</p><p>f 图: An example to show how SpaGCN can create informative meta genes to mark a spatial domain.</p><p>SpaGCN only identified four SVGs for dimain 0. However, we reason that a meta gene, formed by the combination of multiple genes, may better reveal spatial patterns than any single genes.</p><p>说实话不是很能理解这个所谓的 meta gene，即使能够很好的表现，那么依据呢？为什么这几个合一起就更好，是巧合还是什么其它的因素？</p><p>好吧，结果紧接着这篇文章就解释了原因。我感觉这个和之前学过的因子分析有点像，先聚合在一起，然后根据结果 “瞎编” 理由:</p><p>KLK6 and MBP are considered as positive markers because they are highly expressed insome spots in domain 0, whereas ATP1B1 is considered a negative marker as it is mainly expressed in regions other than domain 0.</p><p>Previous studies studies have shoen that KLK6 and MBP expression is restricted to oligodendrocytes, while ATP1B1 is mainly expressed in neurons and astrocytes. This resonates with the fact that domain 0 represents white matter which is dominated by oligodendrocytes and has few neuronal cell bodies.</p><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN14.png" alt=""></p><p>SpaGCN can also jointly analyze multiple tissue sections.</p><p>SpaGCN was able to infer cluster correspondence between the two tissue sections.</p><p>Using the modified coordinates as input, SpaGCN was able to produce clustering results that reflect the shared layer structure in the anterior and posterior brain.</p><h2 id="application-to-mouse-visual-cortex-starmap-data"><a class="anchor" href="#application-to-mouse-visual-cortex-starmap-data">#</a> Application to mouse visual cortex STARmap data</h2><p>STARmap data 是更精密但更少的数据，这里是为了体现 SpaGCN 的泛用性。</p><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN15.png" alt=""></p><p>This example demonstrates that SpaGCN utilizes spatial information more efficiently than BayesSpace and HMRF.</p><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN16.png" alt=""></p><p>这是对于 SVG 的检测</p><h1 id="discussion"><a class="anchor" href="#discussion">#</a> Discussion</h1><p>A limitation of SpaGCN is that the spatial domain detection is mainly driven by gene expression, which may lead to the discrepeancy between the detected domains and the underlying tissue anatomical structure.</p><p>Another limitation of SpaGCN is the lack of separation of spatial variation and cell type variation in gene expression patterns for the detected SVGs.</p><p>Further cell type-specific gene expression needs to be estimated to tease out the contribution of cell types and spatial location in gene expression variation.</p><h1 id="methods"><a class="anchor" href="#methods">#</a> Methods</h1><h2 id="data-prepocessing"><a class="anchor" href="#data-prepocessing">#</a> Data prepocessing</h2><p>The spatial gene expression data are stored in an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">N\times D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">D</span></span></span></span> matrix of unique molecular identifier(UMI) counts with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span> spots and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">D</span></span></span></span> genes, along with the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mclose">)</span></span></span></span> two-dimensional(2D) spatial coordinates of each spot.</p><p>The gene expression values in each spot are normalized such that the UMI count for each gene is divided by the total UNI count across all genes in a given spot, multiplied by 10000, and the transformed to a natrual log scale.</p><blockquote><p><strong>UMI count</strong> 是指通过使用 Unique Molecular Identifiers（UMI）技术，在高通量测序中每个特定分子的出现次数。UMI count 的主要目的是在测序数据中，统计每个独特分子（基因、转录本等）在样本中的 “真实” 丰度，而不是依赖于传统的计数方式（即直接根据测序读段的数量来估算丰度），因为 UMI count 可以消除由于 PCR 扩增带来的重复性偏差。</p><p>UMI count 的工作原理</p><ol><li><p><strong>标签引入</strong>：在实验过程中，每个目标分子（如 mRNA 或 DNA 片段）都会与一个独特的 UMI 标签序列一起被捕获和扩增。这些 UMI 标签通常在目标序列的两端加上。</p></li><li><p><strong>测序</strong>：在高通量测序时，UMI 标签和目标序列都会被读取。</p></li><li><p><strong>去重与计数</strong>：在数据分析阶段，所有带有相同 UMI 标签的读段被归为同一组，并且这组只计为一个分子。因此，每个 UMI 标签代表一个独立的分子，而不是由 PCR 扩增产生的多个重复。</p></li><li><p><strong>UMI count</strong>：最终，UMI count 表示每个特定分子在样本中出现的次数，帮助准确估算每个基因或转录本的表达水平。</p></li></ol><p>UMI count 的应用</p><ul><li><strong>基因表达量</strong>：在转录组学研究中，UMI count 可以准确地计算基因的表达水平，避免了由于 PCR 扩增带来的误差。</li><li><strong>单细胞 RNA 测序</strong>：在单细胞测序中，每个细胞的 RNA 分子都会被标记上独特的 UMI 标签，从而可以有效地消除测序误差和扩增偏差，确保对每个单细胞的基因表达量进行精准估算。</li><li><strong>突变检测</strong>：在基因组学和癌症研究中，UMI count 可以帮助准确检测和定量低频突变或稀有变异，避免了由于 PCR 扩增引入的重复导致的假阳性。</li></ul><p>总的来说，UMI count 是一种有效的计数方式，使得基于测序的数据更加精确和可靠，尤其在处理复杂样本和高丰度与低丰度分子并存的情况下，能显著提高数据的准确性。</p></blockquote><h2 id="conversion-of-srt-data-into-graph-structured-data"><a class="anchor" href="#conversion-of-srt-data-into-graph-structured-data">#</a> Conversion of SRT data into graph-structured data</h2><p>SpaGCN converts the gene expression and histology image data into a weighted undirected graph, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="mclose">)</span></span></span></span>.each vertex <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v\in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.22222em">V</span></span></span></span> represents a spot and every two vertices in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.22222em">V</span></span></span></span> are connected via an edge with a specified weight.</p><p>spage2vec employed a graph-based approach, but with the goal of clustering messenger RNA molecules.</p><h3 id="calculation-of-distance-between-two-vertices"><a class="anchor" href="#calculation-of-distance-between-two-vertices">#</a> Calculation of distance between two vertices</h3><p>The distance between any two vertics <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> in the graph reflects the relative similarity of the two corresponding spots.</p><p>This distance is determined by two factors:</p><ol><li>the physical location of spot <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> in the tissue slice</li><li>the corresponding histology information of these two spots.</li></ol><p>consider two spots tobe close if and only if :</p><ol><li>physically close</li><li>similar histological features as shown in the histology image</li></ol><p>pixel coordinates : <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="script">x</mi><mrow><mi>p</mi><mi>v</mi></mrow></msub><mo separator="true">,</mo><msub><mi mathvariant="script">y</mi><mrow><mi>p</mi><mi>v</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathcal{x}_{pv},\mathcal{y}_{pv})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-.286108em"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">y</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>SpaGCN draws a square centered on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="script">x</mi><mrow><mi>p</mi><mi>v</mi></mrow></msub><mo separator="true">,</mo><msub><mi mathvariant="script">y</mi><mrow><mi>p</mi><mi>v</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathcal{x}_{pv},\mathcal{y}_{pv})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-.286108em"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">y</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> containing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn><mo>×</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">50 \times 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span></span></span></span> pixels and calculates the mean color value for the RGB channels,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi><mi>v</mi></msub><mo separator="true">,</mo><msub><mi>g</mi><mi>v</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>v</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r_v,g_v,b_v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.02778em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>\begin{equation} \mathcal{z_v} = \frac{r_v \times V_r + g_v \times V_g + b_v \times V_b}{V_r + V_g + V_b} \end{equation}<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">V_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> = variance(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">r_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.02778em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>) ...</p><p>SpaGCN rescales <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">z</mi><mi mathvariant="script">v</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{z_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.04398em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></span> as</p>\begin{equation} \mathcal{z_v^*}= \frac{z_v-\mu_z}{\sigma_z} \times max(\sigma_x,\sigma_y) \times s \end{equation}<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>z</mi></msub></mrow><annotation encoding="application/x-tex">\mu_z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> is the mean of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">z_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.04398em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>σ</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>σ</mi><mi>z</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_x,\sigma_y,\sigma_z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.716668em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> are the standard deviations of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">x</mi><mi>v</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="script">y</mi><mi>v</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="script">z</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{x}_{v},\mathcal{y}_{v},\mathcal{z}_{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">y</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> is a scaling factor.</p><p>Euclidean distance between every two spots <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> is calculated as:</p>\begin{equation} d(u,v) = \sqrt{(x_u-x_v)^2+(y_u-y_v)^2+(z_u^*-z_v^*)^2} \end{equation}<h3 id="calculation-of-weight-for-each-edge-and-construction-of-graph"><a class="anchor" href="#calculation-of-weight-for-each-edge-and-construction-of-graph">#</a> Calculation of weight for each edge and construction of graph</h3><p>The graph structure G is stored in an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N\times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span> adjacency matrix <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><mi>w</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A=[w(u,v)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>, where the edge weight between spot u and spot v is defined as</p>\begin{equation} w(u,v) = exp(-\frac{d(u,v)^2}{2l^2}) \end{equation}<p>这里是类似于机器学习里面的高斯核</p><p>The hyperparameter <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span></span></span></span>, also known as the characteristic length scale, determines how rapidly the weight decays as a function of distance. A similar function has been employed in SpatialDE.</p><p>For spot <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span>, the corresponding row sum of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>−</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">A-I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.07847em">I</span></span></span></span>, denoted by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">a_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>, can be interpreted as the relative contribution of other spots to its gene expression.</p><h3 id="graph-convolutional-layer"><a class="anchor" href="#graph-convolutional-layer">#</a> Graph convolutional layer</h3><p>对于 X 矩阵，使用 PCA，取前 50 个主成分作为输入。然后使用 graph convolutional network。</p><p>the graph convolutional layer can be written as:</p>\begin{equation} f(X,A) = \delta(AXB), \end{equation}<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.07847em">X</span></span></span></span> is the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">N \times 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span></span></span></span> embedding matrix obtained from PCA, B is a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn><mo>×</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">50 \times 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">0</span></span></span></span> matrix representing filter parameters of the convolutional layer, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta(\cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03785em">δ</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span> is a nonlinear activation function such as ReLU.</p><p>说实话这个粗暴的取前 50 个主成分也算是节省了运算的时间。然而之前我在跑一个数据集较小的数据时，SpaGCN 直接就报错了，因为在那个数据集中只有 32 维。</p><p>原文写到：Through graph convolution, SpaGCN has aggregated the gene expression information according to the edge weights specified in G. The output of this layer is an aggregated matrix that includes information on gene expression, spatial location and histology.</p><p>我大概拿 chatgpt 跑了个关于 spage2vec 的介绍：</p><blockquote><p>以下是将空间转录组学数据转化为向量嵌入的步骤：</p><p>数学符号和定义</p><ol><li><p><strong>空间转录组学数据</strong>：假设我们有一个空间转录组学数据集，这个数据集可以表示为一组节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">V</mi><mo>=</mo><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>v</mi><mi>n</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\mathcal{V}={v_1, v_2, \dots, v_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord"><span class="mord mathcal" style="margin-right:.08222em">V</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner">…</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></span> ，其中每个节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 代表一个空间位置。</p></li><li><p><strong>基因表达矩阵</strong>：对于每个空间位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，我们有一个高维基因表达向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">x</mi><mi>i</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{x}_i\in\mathbb{R}^d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6891em;vertical-align:-.15em"></span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.849108em;vertical-align:0"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">d</span></span></span></span> 是基因的数量。所有节点的基因表达数据可以构成一个基因表达矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi mathvariant="bold">x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi mathvariant="bold">x</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi mathvariant="normal">⊤</mi></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{X}=[\mathbf{x}_1, \mathbf{x}_2, \dots, \mathbf{x}_n]^\top \in \mathbb{R}^{n \times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68611em;vertical-align:0"></span><span class="mord"><span class="mord mathbf">X</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner">…</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8491079999999999em;vertical-align:0"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8491079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span>。</p></li><li><p><strong>空间邻接关系</strong>：我们假设相邻的空间位置在图中通过一条边相连，用图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="script">V</mi><mo separator="true">,</mo><mi mathvariant="script">E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(\mathcal{V}, \mathcal{E})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:.08222em">V</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathcal" style="margin-right:.08944em">E</span></span><span class="mclose">)</span></span></span></span> 表示空间邻接关系，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\mathcal{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord"><span class="mord mathcal" style="margin-right:.08944em">E</span></span></span></span></span> 是边的集合。可以根据物理位置或其他准则（例如距离）定义边的存在，邻接矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{A} \in \mathbb{R}^{n \times n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72521em;vertical-align:-.0391em"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.771331em;vertical-align:0"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.771331em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> 表示图的结构， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A_{ij}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 表示节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.716668em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 相连，反之 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A_{ij} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span>。</p></li></ol><p>SpaGE2vec 的数学过程</p><ol><li><strong>图卷积层的定义</strong>：</li></ol><ul><li>我们通过图卷积神经网络（Graph Convolutional Network, GCN）对基因表达矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68611em;vertical-align:0"></span><span class="mord"><span class="mord mathbf">X</span></span></span></span></span> 和邻接矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68611em;vertical-align:0"></span><span class="mord"><span class="mord mathbf">A</span></span></span></span></span> 进行图卷积操作。</li><li>具体来说，图卷积可以表示为：</li></ul>\begin{equation} \mathbf{H}^{(l+1)} = \sigma\left(\tilde{\mathbf{D}}^{-\frac{1}{2}} \tilde{\mathbf{A}} \tilde{\mathbf{D}}^{-\frac{1}{2}} \mathbf{H}^{(l)} \mathbf{W}^{(l)}\right) \end{equation}<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="bold">A</mi><mo>~</mo></mover><mo>=</mo><mi mathvariant="bold">A</mi><mo>+</mo><mi mathvariant="bold">I</mi></mrow><annotation encoding="application/x-tex">\tilde{\mathbf{A}} = \mathbf{A} + \mathbf{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.9229699999999998em;vertical-align:0"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.9229699999999998em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathbf">A</span></span></span></span><span style="top:-3.6051100000000003em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.11110999999999999em"><span class="mord">~</span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.76944em;vertical-align:-.08333em"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.68611em;vertical-align:0"></span><span class="mord"><span class="mord mathbf">I</span></span></span></span></span> 为加上自连接后的邻接矩阵；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="bold">D</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{\mathbf{D}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.9229699999999998em;vertical-align:0"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.9229699999999998em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathbf">D</span></span></span></span><span style="top:-3.6051100000000003em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.19444em"><span class="mord">~</span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="bold">A</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{\mathbf{A}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.9229699999999998em;vertical-align:0"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.9229699999999998em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathbf">A</span></span></span></span><span style="top:-3.6051100000000003em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.11110999999999999em"><span class="mord">~</span></span></span></span></span></span></span></span></span></span> 的度矩阵；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">H</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{H}^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8879999999999999em;vertical-align:0"></span><span class="mord"><span class="mord"><span class="mord mathbf">H</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8879999999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 是第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span></span></span></span> 层的节点特征矩阵，初始时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">H</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{H}^{(0)} = \mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8879999999999999em;vertical-align:0"></span><span class="mord"><span class="mord"><span class="mord mathbf">H</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8879999999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">0</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68611em;vertical-align:0"></span><span class="mord"><span class="mord mathbf">X</span></span></span></span></span>；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{W}^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8879999999999999em;vertical-align:0"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:.01597em">W</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8879999999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 是该层的权重矩阵；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">σ</span></span></span></span> 是激活函数（例如 ReLU）。</li></ul><ol start="2"><li><strong>嵌入表示</strong>：</li></ol><ul><li>经过多层图卷积后，我们可以得到每个节点的低维嵌入向量表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Z</mi><mo>=</mo><msup><mi mathvariant="bold">H</mi><mrow><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{Z} = \mathbf{H}^{(L)} \in \mathbb{R}^{n \times k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68611em;vertical-align:0"></span><span class="mord"><span class="mord mathbf">Z</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.9270999999999999em;vertical-align:-.0391em"></span><span class="mord"><span class="mord"><span class="mord mathbf">H</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8879999999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">L</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8491079999999999em;vertical-align:0"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8491079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">L</span></span></span></span> 是图卷积的层数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 是嵌入的维度。</li><li>这个矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Z</mi></mrow><annotation encoding="application/x-tex">\mathbf{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68611em;vertical-align:0"></span><span class="mord"><span class="mord mathbf">Z</span></span></span></span></span> 是我们要得到的嵌入结果，每一行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">z</mi><mi>i</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{z}_i \in \mathbb{R}^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6891em;vertical-align:-.15em"></span><span class="mord"><span class="mord"><span class="mord mathbf">z</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.849108em;vertical-align:0"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span></span></span></span></span></span></span></span> 表示节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的低维嵌入。</li></ul><ol start="3"><li><strong>嵌入的聚类和分析</strong>：</li></ol><ul><li>在得到嵌入矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Z</mi></mrow><annotation encoding="application/x-tex">\mathbf{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68611em;vertical-align:0"></span><span class="mord"><span class="mord mathbf">Z</span></span></span></span></span> 后，我们可以使用聚类算法（如 k-means）对这些向量进行聚类，将具有相似基因表达和空间特征的节点归为一类。</li><li>通过聚类结果，我们可以发现组织中不同区域的基因表达特征差异。</li></ul><p>例子分析</p><p>假设我们在肿瘤组织上使用 SpaGE2vec，得到以下结果：</p><ul><li><strong>每个空间点的嵌入</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{z}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.59444em;vertical-align:-.15em"></span><span class="mord"><span class="mord"><span class="mord mathbf">z</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 可以被分为几类，分别代表肿瘤中心、肿瘤边缘、健康组织等区域。</li><li>使用 t-SNE 或 UMAP 对嵌入结果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Z</mi></mrow><annotation encoding="application/x-tex">\mathbf{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68611em;vertical-align:0"></span><span class="mord"><span class="mord mathbf">Z</span></span></span></span></span> 进行二维可视化后，我们发现这些区域在嵌入空间中彼此分离开来。</li></ul></blockquote><p>但吊诡的是，这里面倒是的的确确使用了 gene expression 的数据，那么 SpaGCN 呢？后面看代码印证一下吧。</p><h3 id="spatial-domain-identification-by-clustering"><a class="anchor" href="#spatial-domain-identification-by-clustering">#</a> Spatial domain identification by clustering</h3><p>空间域的概念: SpaGCN employs an unsupervised clustering algorithm iteratively to cluster the spots into different spatial domains. Each cluster identified from this analysis is considered to be a spatial domain, which contains spots that are coherent in gene expression and histology.</p><p>首先确定一个初始的中心，这里是利用 Louvain 算法。我感觉这个 Louvain 算法和 K-means 有点像，都是要确定一下分类的数量和初始点。分类的数量（也就是 domain 的数量）取决于我们是否知道 the number of domains in the tissue. 如果不知道就 vary the resolution parameter from 0.2 to 1.0 and select the resolution that gives the highest Silhouette score.</p><p>Louvain 算法是一种常用的社区检测算法，用于发现复杂网络中的社区结构。分辨率参数是一个重要的超参数，用于控制社区检测的粒度，通常由符号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05556em">γ</span></span></span></span> 表示</p><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\gamma = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05556em">γ</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>,Louvain 算法的标准形式，社区检测的结果通常是最平衡的。</p><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\gamma &lt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7335400000000001em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05556em">γ</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>,Louvain 算法倾向于检测更大的社区，因为较小的社区合并的可能性更大。</p><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\gamma &gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7335400000000001em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05556em">γ</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>,Louvain 算法倾向于检测更小的社区，因为较大的社区会被拆分成更小的社区。</p><p>下面的公式我并没有看懂。这个公式是为了衡量每个 spot <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 的 embedded point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.84444em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和 centroid <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\mu_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.716668em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 对于每个类<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span> 的距离：</p>\begin{equation} q_{ij} = \frac{(1+h_i-\mu_j^2)^{-1}}{\sum_{j' = 1}^{K} (1+h_i-\mu_{j'}^2)^{-1}} \end{equation}<p>可以被诠释为将细胞 i 分类给细胞 j 的概率</p><p ij="">然后文章定义了一个 auxiliary target distribution <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span></span></span></span> based on q_</p>\begin{equation} p_{ij} = \frac{q_{ij}^2 / {\sum^{N}_{i=1}} q_{ij}}{\sum_{j^{\prime}}^{K}(q_{ij^{\prime}}^2 / {\sum^{N}_{i=1}q_{ij^{\prime}}})} \end{equation}<p>然后又解释这个能对高置信度分配的点赋予更大的权重，并对每个簇中心在整体损失函数中的贡献进行归一化，以防止大簇扭曲隐藏特征空间。</p><p>这句话的意思是，在某些模型或算法中，存在两种不同的分配方式：</p><ol><li><p><strong>软分配<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">q_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.716668em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span></strong>：</p><ul><li>软分配通常表示一个模糊的或连续的分配关系。在聚类或分类问题中，软分配可以用于描述一个数据点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 属于簇<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span> 的概率，而不是硬性地将其分配给一个特定的簇。通常，软分配值会在 0 和 1 之间，表示一个数据点属于某个簇的 “程度”。</li><li>例如，在高斯混合模型（Gaussian Mixture Model, GMM）中，软分配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">q_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.716668em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 表示数据点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 属于簇<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span> 的概率，且该概率随着模型的训练不断调整。</li></ul></li><li><p><strong>辅助分配<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.716668em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span></strong>：</p><ul><li>辅助分配通常是用于辅助计算的一种参考分配，可能并不直接用于最终的分类或聚类结果。它可能是模型中的一个中间变量，或者是用来约束某些条件的辅助信息。</li><li>辅助分配通常用来调节或优化模型，例如在变分推断中，辅助分配<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.716668em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 可能是通过某种假设或者近似推断得到的，旨在帮助模型更好地收敛或更精确地估计分布。</li></ul></li></ol><p>然后定义损失函数 Kullback-Leibler (KL) divergence loss<br>KL 散度可以理解为：如果使用分布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8777699999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">Q</span></span></span></span> 来近似分布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span></span></span></span>，会有多少信息损失。具体来说，KL 散度衡量了使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8777699999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">Q</span></span></span></span> 来表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑃</mi></mrow><annotation encoding="application/x-tex">𝑃</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span></span></span></span>时的平均信息损失或不匹配程度。</p>\begin{equation} L = KL(P||Q) = \displaystyle\sum^{N}_{i=1}\displaystyle\sum^{K}_{j=1}p_{ij}log\frac{p_{ij}}{q_{ij}} \end{equation}<p>通过利用随机梯度下降的方法最小化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">L</span></span></span></span> 的值训练模型</p><p>这一个板块看着倒逻辑通畅，实际上每一步都理解不了为什么要这么去实现，后面再研究一下。</p><p>// 这里研究出来了，它本质上是使用了 DEC (Deep Embedded Clustering) 的方法</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd3p5ai9wLzk4Mjc1ODQuaHRtbA==">参考网站</span></p><p>结合这个文章一看，我们大胆推测这个 SpaGCN 里面针对 q 的公式怕不是写错了？应该是：</p>\begin{equation} q_{ij} = \frac{(1+(h_i-\mu_j)^2)^{-1}}{\sum_{j' = 1}^{K} (1+(h_i-\mu_{j'})^2)^{-1}} \end{equation}<p>对应着代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = <span class="number">1.0</span> / ((<span class="number">1.0</span> + torch.<span class="built_in">sum</span>((x.unsqueeze(<span class="number">1</span>) - <span class="variable language_">self</span>.mu)**<span class="number">2</span>, dim=<span class="number">2</span>) / <span class="variable language_">self</span>.alpha) + <span class="number">1e-8</span>)</span><br><span class="line">        q = q**(<span class="variable language_">self</span>.alpha+<span class="number">1.0</span>)/<span class="number">2.0</span></span><br><span class="line">        q = q / torch.<span class="built_in">sum</span>(q, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>而且抽象的是他这里直接写了指数为 - 1，然而原本论文的公式为：</p>\begin{equation} q_{ij} = \frac{(1+(h_i-\mu_j)^2/\alpha)^{-\frac{\alpha+1}{2}}}{\sum_{j' = 1}^{K} (1+(h_i-\mu_j)^2/\alpha)^{-\frac{\alpha+1}{2}}} \end{equation}<p>他自己设定的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.2</mn></mrow><annotation encoding="application/x-tex">\alpha = 0.2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span></span></span></span> 然而论文里面却直接默认<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></p><p>也不知道是什么情况</p><h3 id="detection-of-svgs"><a class="anchor" href="#detection-of-svgs">#</a> Detection of SVGs</h3><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN17.jpg" alt=""></p><p>原文提到要设立一个半径去找邻居，也没具体介绍，这里我根据代码写一下原理：</p><ul><li>首先根据 spot 之间的距离，通过邻接矩阵取非零值排序，对于在分位点 0.1% 和 10% 的分位数作为搜索 radius 的 start 和 end</li><li>接着去计算每个细胞在指定的 radius 所包含细胞邻居数量的平均值，我们希望这个平均值在 8-15 之间，这个应该是经验值。得到的 radius 便是所求的半径。</li></ul><p>这里直接去看原文吧，提到了一些准则，后面会在这里补充一下什么是 DE analysis，什么是 Wilcoxon rank-sum test. 主要是使用了这两种方法</p><p>差异表达分析（DE Analysis）的<strong>核心原理</strong>是通过比较两组（或多组）样本中基因表达的分布差异，识别在不同条件下显著变化的基因。这涉及数据预处理、统计建模和显著性评估等多个步骤，核心原理如下：</p><hr><h4 id="1-数据来源与表示"><a class="anchor" href="#1-数据来源与表示">#</a> <strong>1. 数据来源与表示</strong></h4><p>差异表达分析以基因表达矩阵为输入，矩阵的结构如下：</p><ul><li>行：基因。</li><li>列：样本。</li><li>值：基因在某样本中的表达量（通常是计数值，如 RNA-Seq 的 read counts，或已标准化的表达值，如 TPM、FPKM）。</li></ul><p>例如：</p><table><thead><tr><th>基因 / 样本</th><th>样本 1（对照）</th><th>样本 2（实验）</th><th>样本 3（对照）</th><th>样本 4（实验）</th></tr></thead><tbody><tr><td>GeneA</td><td>50</td><td>100</td><td>45</td><td>95</td></tr><tr><td>GeneB</td><td>200</td><td>210</td><td>195</td><td>220</td></tr></tbody></table><hr><h4 id="2-数据预处理"><a class="anchor" href="#2-数据预处理">#</a> <strong>2. 数据预处理</strong></h4><p>为了消除技术或生物学噪声对结果的影响，差异表达分析需要先对数据进行预处理：</p><ol><li><p><strong>去除低表达基因</strong>：</p><ul><li>低表达的基因贡献的信息有限，可能会引入噪声。</li><li>通常的阈值是：在至少一组样本中计数值大于某个值（如 10）。</li></ul></li><li><p><strong>归一化（Normalization）</strong>：</p><ul><li>由于不同样本测序深度不同，需要对表达量进行归一化。</li><li>常见方法：<ul><li><strong>TPM/FPKM/RPKM</strong>：标准化为每百万读数的基因表达值。</li><li><strong>DESeq2</strong> 的 size factor。</li><li><strong>EdgeR</strong> 的 TMM（Trimmed Mean of M-values）。</li></ul></li></ul></li><li><p><strong>对数变换</strong>：</p><ul><li>由于基因表达分布往往是偏态的（如负二项分布），对数变换可使数据更接近正态分布，便于后续统计分析。</li></ul></li></ol><hr><h4 id="3-差异表达的统计模型"><a class="anchor" href="#3-差异表达的统计模型">#</a> <strong>3. 差异表达的统计模型</strong></h4><p>差异表达分析的核心是比较两组样本中基因表达的差异。这需要统计模型来评估表达变化是否显著。</p><h5 id="1假设检验"><a class="anchor" href="#1假设检验">#</a> <strong>（1）假设检验</strong></h5><p>每个基因进行一次假设检验，设定零假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">H_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和备择假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">H_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">H_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>：该基因在两组样本中的表达量无显著差异。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">H_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>：该基因在两组样本中的表达量有显著差异。</li></ul><h6 id="检验方法"><a class="anchor" href="#检验方法">#</a> 检验方法：</h6><ol><li><p><strong>t 检验</strong>：</p><ul><li>假设表达值符合正态分布。</li><li>适用于小样本但表达值已标准化的数据。</li><li>不适合原始 RNA-Seq 计数值。</li></ul></li><li><p><strong>非参数检验（如 Wilcoxon 检验）</strong>：</p><ul><li>无需假设数据分布，适合较为广泛的场景。</li></ul></li><li><p><strong>基于离散分布的模型</strong>（RNA-Seq 数据常用）：</p><ul><li>RNA-Seq 数据是计数型，且存在离散性和过度离散性（overdispersion）。</li><li>常用方法：<ul><li><strong>EdgeR</strong>：基于负二项分布建模。</li><li><strong>DESeq2</strong>：基于广义线性模型（GLM），以负二项分布校正过度离散性。</li></ul></li></ul></li></ol><h6 id="关键统计量"><a class="anchor" href="#关键统计量">#</a> 关键统计量：</h6><ul><li><p><strong>Fold Change（FC）</strong>：</p><ul><li>表示基因在实验组和对照组之间的表达倍数变化。</li><li>常用对数形式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>log2FC</mtext><mo>=</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mo stretchy="false">(</mo><mtext>实验组均值</mtext><mi mathvariant="normal">/</mi><mtext>对照组均值</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{log2FC} = \log_2(\text{实验组均值}/\text{对照组均值})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord text"><span class="mord">log2FC</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.20696799999999996em"><span style="top:-2.4558600000000004em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.24414em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord cjk_fallback">实验组均值</span></span><span class="mord">/</span><span class="mord text"><span class="mord cjk_fallback">对照组均值</span></span><span class="mclose">)</span></span></span></span>。</li></ul></li><li><p><strong>p-value</strong>：</p><ul><li>根据统计检验方法计算的显著性水平。</li><li>较小的 p-value 表明表达差异可能显著。</li></ul></li></ul><hr><h5 id="2多重检验校正"><a class="anchor" href="#2多重检验校正">#</a> <strong>（2）多重检验校正</strong></h5><p>DE 分析涉及多个基因（通常上万个）的独立假设检验，需控制整体的假阳性率。</p><ul><li><strong>问题</strong>：直接使用 p-value 会导致大量假阳性（type I error）。</li><li><strong>方法</strong>：<ul><li>使用 FDR（False Discovery Rate）校正，常用算法：<ul><li>Benjamini-Hochberg 方法。</li><li>Bonferroni 校正（较为严格）。</li></ul></li></ul></li></ul><p>结果是校正后的 p-value，称为 <strong>adjusted p-value</strong> 或 <strong>q-value</strong>。</p><hr><h4 id="4-差异基因筛选"><a class="anchor" href="#4-差异基因筛选">#</a> <strong>4. 差异基因筛选</strong></h4><p>根据以下标准筛选差异表达基因（DEGs）：</p><ol><li><strong>Fold Change（FC）</strong>：<ul><li>通常设定阈值，如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mtext>log2FC</mtext><mi mathvariant="normal">∣</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|\text{log2FC}| &gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord text"><span class="mord">log2FC</span></span><span class="mord">∣</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>。</li></ul></li><li><strong>p-value 或 Adjusted p-value</strong>：<ul><li>常用阈值：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>q-value</mtext><mo>&lt;</mo><mn>0.05</mn></mrow><annotation encoding="application/x-tex">\text{q-value} &lt; 0.05</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord text"><span class="mord">q-value</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">5</span></span></span></span>。</li></ul></li></ol><p>例如：</p><table><thead><tr><th>基因</th><th>log2FC</th><th>Adjusted p-value</th></tr></thead><tbody><tr><td>GeneA</td><td>2.5</td><td>0.001</td></tr><tr><td>GeneB</td><td>-1.2</td><td>0.02</td></tr></tbody></table><hr><h4 id="5-可视化与结果解释"><a class="anchor" href="#5-可视化与结果解释">#</a> <strong>5. 可视化与结果解释</strong></h4><h5 id="1火山图volcano-plot"><a class="anchor" href="#1火山图volcano-plot">#</a> <strong>（1）火山图（Volcano Plot）</strong></h5><ul><li>x 轴：log2 Fold Change。</li><li>y 轴：-log10 (p-value)。</li><li>用不同颜色标注显著的差异表达基因。</li></ul><h5 id="2热图heatmap"><a class="anchor" href="#2热图heatmap">#</a> <strong>（2）热图（Heatmap）</strong></h5><ul><li>显示差异基因在各样本间的表达模式。</li><li>可聚类分析样本和基因之间的关系。</li></ul><hr><h4 id="6-后续分析"><a class="anchor" href="#6-后续分析">#</a> <strong>6. 后续分析</strong></h4><ul><li><strong>功能富集分析</strong>：<ul><li>通过 Gene Ontology (GO)、KEGG 等数据库，解析差异基因的生物学功能。</li></ul></li><li><strong>信号通路分析</strong>：<ul><li>分析差异基因对信号通路的影响。</li></ul></li><li><strong>验证</strong>：<ul><li>通过实验方法（如 qPCR）验证筛选出的关键基因。</li></ul></li></ul><hr><p>总结：DE 分析的核心原理是基于统计模型和检验，评估基因在不同样本组间的表达差异。通过合理的数据预处理、显著性评估和多重检验校正，可以高效筛选出生物学意义显著的差异表达基因，为后续研究提供关键线索。<br>Wilcoxon 秩和检验（Wilcoxon Rank-Sum Test），也叫 <strong>Mann-Whitney U 检验</strong>，是一种<strong>非参数统计检验</strong>方法，用于比较两组数据的分布是否有显著差异。它特别适用于以下情况：</p><ul><li>数据不满足正态分布假设。</li><li>样本量较小。</li><li>数据是有序的（ordinal），但可能不是连续的。</li></ul><hr><h4 id="1-应用场景"><a class="anchor" href="#1-应用场景">#</a> <strong>1. 应用场景</strong></h4><p>Wilcoxon 秩和检验常用于以下问题：</p><ul><li>比较两组数据的中位数是否不同。</li><li>检测两组数据是否来自相同的分布。</li></ul><hr><h4 id="2-原理"><a class="anchor" href="#2-原理">#</a> <strong>2. 原理</strong></h4><p>该检验基于数据的<strong>秩（rank）</strong>，而不是原始数值，从而对异常值和数据分布的要求不敏感。</p><h5 id="1假设"><a class="anchor" href="#1假设">#</a> <strong>（1）假设</strong></h5><ul><li><strong>零假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">H_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong>：两组数据的分布相同。</li><li><strong>备择假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">H_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong>：<ul><li>双尾检验：两组数据的分布不同。</li><li>单尾检验：一组数据的分布显著大于或小于另一组。</li></ul></li></ul><h5 id="2步骤"><a class="anchor" href="#2步骤">#</a> <strong>（2）步骤</strong></h5><ol><li><p><strong>合并数据并排序</strong>：</p><ul><li>将两组数据合并，根据大小为每个值分配一个秩（rank）。</li><li>如果有重复值，赋予它们相同的秩，计算平均秩。</li></ul></li><li><p><strong>计算秩和</strong>：</p><ul><li>分别计算两组数据的秩和（sum of ranks）。</li></ul></li><li><p><strong>计算检验统计量</strong>：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo>=</mo><msub><mi>R</mi><mn>1</mn></msub><mo>−</mo><mfrac><mrow><msub><mi>n</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">U_1 = R_1 - \frac{n_1(n_1+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.00773em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.485em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31731428571428577em"><span style="top:-2.357em;margin-left:0;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31731428571428577em"><span style="top:-2.357em;margin-left:0;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>U_2 = R_2 - \frac{n_2(n_2+1)}<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_1, R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8777699999999999em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.00773em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.00773em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>：两组数据的秩和。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_1, n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>：两组数据的样本量。</li></ul></li><li>检验统计量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>U</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U = \min(U_1, U_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li></ul></li><li><p><strong>计算 p 值</strong>：</p><ul><li>根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">U</span></span></span></span> 值和两组样本量，从查表或通过正态分布近似计算 p 值。</li></ul></li></ol><hr><h4 id="3-示例"><a class="anchor" href="#3-示例">#</a> <strong>3. 示例</strong></h4><p>假设有两组数据：</p><ul><li>组 1（对照）：[85, 90, 78]</li><li>组 2（实验）：[88, 92, 85]</li></ul><h5 id="步骤-1合并并排序"><a class="anchor" href="#步骤-1合并并排序">#</a> <strong>步骤 1：合并并排序</strong></h5><p>数据排序后：</p><table><thead><tr><th>值</th><th>78</th><th>85</th><th>85</th><th>88</th><th>90</th><th>92</th></tr></thead><tbody><tr><td>秩</td><td>1</td><td>2.5</td><td>2.5</td><td>4</td><td>5</td><td>6</td></tr></tbody></table><h5 id="步骤-2计算秩和"><a class="anchor" href="#步骤-2计算秩和">#</a> <strong>步骤 2：计算秩和</strong></h5><ul><li>组 1（对照，85, 90, 78）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>+</mo><mn>2.5</mn><mo>+</mo><mn>5</mn><mo>=</mo><mn>8.5</mn></mrow><annotation encoding="application/x-tex">R_1 = 1 + 2.5 + 5 = 8.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.00773em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">8</span><span class="mord">.</span><span class="mord">5</span></span></span></span></li><li>组 2（实验，88, 92, 85）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub><mo>=</mo><mn>2.5</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>6</mn><mo>=</mo><mn>12.5</mn></mrow><annotation encoding="application/x-tex">R_2 = 2.5 + 4 + 6 = 12.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.00773em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">4</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span></span></li></ul><h5 id="步骤-3计算-u-值"><a class="anchor" href="#步骤-3计算-u-值">#</a> <strong>步骤 3：计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">U</span></span></span></span> 值</strong></h5><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo>=</mo><msub><mi>R</mi><mn>1</mn></msub><mo>−</mo><mfrac><mrow><msub><mi>n</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mn>8.5</mn><mo>−</mo><mfrac><mrow><mn>3</mn><mo>⋅</mo><mo stretchy="false">(</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mn>8.5</mn><mo>−</mo><mn>6</mn><mo>=</mo><mn>2.5</mn></mrow><annotation encoding="application/x-tex">U_1 = R_1 - \frac{n_1(n_1+1)}{2} = 8.5 - \frac{3 \cdot (3+1)}{2} = 8.5 - 6 = 2.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.00773em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.485em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31731428571428577em"><span style="top:-2.357em;margin-left:0;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31731428571428577em"><span style="top:-2.357em;margin-left:0;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">8</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.485em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">⋅</span><span class="mopen mtight">(</span><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">8</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>2</mn></msub><mo>=</mo><msub><mi>R</mi><mn>2</mn></msub><mo>−</mo><mfrac><mrow><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mn>12.5</mn><mo>−</mo><mfrac><mrow><mn>3</mn><mo>⋅</mo><mo stretchy="false">(</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mn>12.5</mn><mo>−</mo><mn>6</mn><mo>=</mo><mn>6.5</mn></mrow><annotation encoding="application/x-tex">U_2 = R_2 - \frac{n_2(n_2+1)}{2} = 12.5 - \frac{3 \cdot (3+1)}{2} = 12.5 - 6 = 6.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.00773em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.485em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31731428571428577em"><span style="top:-2.357em;margin-left:0;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31731428571428577em"><span style="top:-2.357em;margin-left:0;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.485em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">⋅</span><span class="mopen mtight">(</span><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span><span class="mord">.</span><span class="mord">5</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>U</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2.5</mn><mo separator="true">,</mo><mn>6.5</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2.5</mn></mrow><annotation encoding="application/x-tex">U = \min(U_1, U_2) = \min(2.5, 6.5) = 2.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">6</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span></span></li></ul><h5 id="步骤-4查表得-p-值"><a class="anchor" href="#步骤-4查表得-p-值">#</a> <strong>步骤 4：查表得 p 值</strong></h5><ul><li>根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mn>2.5</mn></mrow><annotation encoding="application/x-tex">U = 2.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n_1 = n_2 = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span>，查表或计算 p 值。</li><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>&lt;</mo><mn>0.05</mn></mrow><annotation encoding="application/x-tex">p &lt; 0.05</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7335400000000001em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">5</span></span></span></span>，拒绝 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">H_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。</li></ul><hr><h4 id="4-优点"><a class="anchor" href="#4-优点">#</a> <strong>4. 优点</strong></h4><ul><li>对数据分布无要求（非正态分布可用）。</li><li>对极值不敏感。</li><li>适合小样本分析。</li></ul><hr><h4 id="5-限制"><a class="anchor" href="#5-限制">#</a> <strong>5. 限制</strong></h4><ul><li>对于非常大的样本，非参数方法的效能可能不如参数方法（如 t 检验）。</li><li>假设两组数据是独立的，且度量尺度至少是有序的。</li><li>无法提供基于具体差异大小的效应量估计。</li></ul><hr><h3 id="detection-of-spatially-variable-meta-genes"><a class="anchor" href="#detection-of-spatially-variable-meta-genes">#</a> Detection of spatially variable meta genes</h3><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/SPAGCN18.jpg" alt=""></p><p>每次迭代的公式</p>\begin{equation} log(meta\_gene_{t+1}) = log(meta\_gene_t) + log(gene_{t+}) - log(gene_{t-}) + C_t \end{equation}<p>原本我以为这个 meta genes 没啥用，结果发现构造它的方法也十分巧妙合乎逻辑，其实主要的逻辑就是处理上一个板块若是没有出现 SVGs 的 domain 该怎么处理。</p><h3 id="evaluation-of-svgs-using-moransi-and-gearys-statics"><a class="anchor" href="#evaluation-of-svgs-using-moransi-and-gearys-statics">#</a> Evaluation of SVGs using Moran'sI and Geary's statics</h3><p>这个板块直接去看 benchmarking 的那篇文章的解释即可</p><p>接下来就是代码的部分了。</p><h1 id="代码"><a class="anchor" href="#代码">#</a> 代码</h1><p>好恶心</p><p>由于不理解不会的太多以至于我不知道该怎么记了，先大致先从 Clustering 和 SVGs 两个板块来记录吧，最后再记录一下实际使用 SpaGCN 的步骤。</p><h2 id="clustering"><a class="anchor" href="#clustering">#</a> Clustering</h2><h3 id="原理性的东西"><a class="anchor" href="#原理性的东西">#</a> 原理性的东西</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpaGCN</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(SpaGCN, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.l=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_l</span>(<span class="params">self, l</span>):</span><br><span class="line">        <span class="variable language_">self</span>.l=l</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self,adata,adj, </span></span><br><span class="line"><span class="params">            num_pcs=<span class="number">50</span>, </span></span><br><span class="line"><span class="params">            lr=<span class="number">0.005</span>,</span></span><br><span class="line"><span class="params">            max_epochs=<span class="number">2000</span>,</span></span><br><span class="line"><span class="params">            weight_decay=<span class="number">0</span>,</span></span><br><span class="line"><span class="params">            opt=<span class="string">&quot;admin&quot;</span>,</span></span><br><span class="line"><span class="params">            init_spa=<span class="literal">True</span>,</span></span><br><span class="line"><span class="params">            init=<span class="string">&quot;louvain&quot;</span>, <span class="comment">#louvain or kmeans</span></span></span><br><span class="line"><span class="params">            n_neighbors=<span class="number">10</span>, <span class="comment">#for louvain</span></span></span><br><span class="line"><span class="params">            n_clusters=<span class="literal">None</span>, <span class="comment">#for kmeans</span></span></span><br><span class="line"><span class="params">            res=<span class="number">0.4</span>, <span class="comment">#for louvain</span></span></span><br><span class="line"><span class="params">            tol=<span class="number">1e-3</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.num_pcs=num_pcs</span><br><span class="line">        <span class="variable language_">self</span>.res=res</span><br><span class="line">        <span class="variable language_">self</span>.lr=lr</span><br><span class="line">        <span class="variable language_">self</span>.max_epochs=max_epochs</span><br><span class="line">        <span class="variable language_">self</span>.weight_decay=weight_decay</span><br><span class="line">        <span class="variable language_">self</span>.opt=opt</span><br><span class="line">        <span class="variable language_">self</span>.init_spa=init_spa</span><br><span class="line">        <span class="variable language_">self</span>.init=init</span><br><span class="line">        <span class="variable language_">self</span>.n_neighbors=n_neighbors</span><br><span class="line">        <span class="variable language_">self</span>.n_clusters=n_clusters</span><br><span class="line">        <span class="variable language_">self</span>.res=res</span><br><span class="line">        <span class="variable language_">self</span>.tol=tol</span><br><span class="line">        <span class="keyword">assert</span> adata.shape[<span class="number">0</span>]==adj.shape[<span class="number">0</span>]==adj.shape[<span class="number">1</span>]</span><br><span class="line">        pca = PCA(n_components=<span class="variable language_">self</span>.num_pcs)</span><br><span class="line">        <span class="keyword">if</span> issparse(adata.X):</span><br><span class="line">            pca.fit(adata.X.A)</span><br><span class="line">            embed=pca.transform(adata.X.A)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pca.fit(adata.X)</span><br><span class="line">            embed=pca.transform(adata.X)</span><br><span class="line">        <span class="comment">###------------------------------------------###</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.l <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;l should not be set before fitting the model!&#x27;</span>)</span><br><span class="line">        adj_exp=np.exp(-<span class="number">1</span>*(adj**<span class="number">2</span>)/(<span class="number">2</span>*(<span class="variable language_">self</span>.l**<span class="number">2</span>)))</span><br><span class="line">        <span class="comment">#----------Train model----------</span></span><br><span class="line">        <span class="variable language_">self</span>.model=simple_GC_DEC(embed.shape[<span class="number">1</span>],embed.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="variable language_">self</span>.model.fit(embed,adj_exp,lr=<span class="variable language_">self</span>.lr,max_epochs=<span class="variable language_">self</span>.max_epochs,weight_decay=<span class="variable language_">self</span>.weight_decay,opt=<span class="variable language_">self</span>.opt,init_spa=<span class="variable language_">self</span>.init_spa,init=<span class="variable language_">self</span>.init,n_neighbors=<span class="variable language_">self</span>.n_neighbors,n_clusters=<span class="variable language_">self</span>.n_clusters,res=<span class="variable language_">self</span>.res, tol=<span class="variable language_">self</span>.tol)</span><br><span class="line">        <span class="variable language_">self</span>.embed=embed</span><br><span class="line">        <span class="variable language_">self</span>.adj_exp=adj_exp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self</span>):</span><br><span class="line">        z,q=<span class="variable language_">self</span>.model.predict(<span class="variable language_">self</span>.embed,<span class="variable language_">self</span>.adj_exp)</span><br><span class="line">        y_pred = torch.argmax(q, dim=<span class="number">1</span>).data.cpu().numpy()</span><br><span class="line">        <span class="comment"># Max probability plot</span></span><br><span class="line">        prob=q.detach().numpy()</span><br><span class="line">        <span class="keyword">return</span> y_pred, prob</span><br></pre></td></tr></table></figure><ul><li>p: Percentage of total expression contributed by neighborhoods. 也对应着论文中的 the average of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">a_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> across all spots</li><li>l: Parameter to control p.</li><li>res: 是用来控制在 Louvain 中聚类的分辨率的，需要先用算法去生成这个值，然后能得到对应的能生成具体对应区块数目的 res 值</li></ul><p>输入中 adata，adj 是由下面的代码得到的，全部都可以由 h5ad 数据得到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">adata = sc.read_h5ad(<span class="string">f&#x27;<span class="subst">&#123;datadir&#125;</span>/osmfish.h5ad&#x27;</span>)</span><br><span class="line">adata.obs[<span class="string">&#x27;x_pixel&#x27;</span>]=adata.obsm[<span class="string">&#x27;spatial&#x27;</span>][:,<span class="number">0</span>]</span><br><span class="line">adata.obs[<span class="string">&#x27;y_pixel&#x27;</span>]=adata.obsm[<span class="string">&#x27;spatial&#x27;</span>][:,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">x_pixel=adata.obs[<span class="string">&quot;x_pixel&quot;</span>].tolist()</span><br><span class="line">y_pixel=adata.obs[<span class="string">&quot;y_pixel&quot;</span>].tolist()</span><br><span class="line"></span><br><span class="line">adj=spg.calculate_adj_matrix(x=x_pixel,y=y_pixel, histology=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>self 指的是实例本身，也便是我们利用这个 class 创建出来的实例。</p><p>然后便是调用 model 里面的函数。<br>model：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">simple_GC_DEC</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nfeat, nhid, alpha=<span class="number">0.2</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(simple_GC_DEC, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.gc = GraphConvolution(nfeat, nhid)</span><br><span class="line">        <span class="variable language_">self</span>.nhid=nhid</span><br><span class="line">        <span class="comment">#self.mu determined by the init method</span></span><br><span class="line">        <span class="variable language_">self</span>.alpha=alpha</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, adj</span>):</span><br><span class="line">        x=<span class="variable language_">self</span>.gc(x, adj)</span><br><span class="line">        q = <span class="number">1.0</span> / ((<span class="number">1.0</span> + torch.<span class="built_in">sum</span>((x.unsqueeze(<span class="number">1</span>) - <span class="variable language_">self</span>.mu)**<span class="number">2</span>, dim=<span class="number">2</span>) / <span class="variable language_">self</span>.alpha) + <span class="number">1e-8</span>)</span><br><span class="line">        q = q**(<span class="variable language_">self</span>.alpha+<span class="number">1.0</span>)/<span class="number">2.0</span></span><br><span class="line">        q = q / torch.<span class="built_in">sum</span>(q, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> x, q</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loss_function</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">kld</span>(<span class="params">target, pred</span>):</span><br><span class="line">            <span class="keyword">return</span> torch.mean(torch.<span class="built_in">sum</span>(target*torch.log(target/(pred+<span class="number">1e-6</span>)), dim=<span class="number">1</span>))</span><br><span class="line">        loss = kld(p, q)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">target_distribution</span>(<span class="params">self, q</span>):</span><br><span class="line">        <span class="comment">#weight = q ** 2 / q.sum(0)</span></span><br><span class="line">        <span class="comment">#return torch.transpose((torch.transpose(weight,0,1) / weight.sum(1)),0,1)e</span></span><br><span class="line">        p = q**<span class="number">2</span> / torch.<span class="built_in">sum</span>(q, dim=<span class="number">0</span>)</span><br><span class="line">        p = p / torch.<span class="built_in">sum</span>(p, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X,adj,  lr=<span class="number">0.001</span>, max_epochs=<span class="number">5000</span>, update_interval=<span class="number">3</span>, trajectory_interval=<span class="number">50</span>,weight_decay=<span class="number">5e-4</span>,opt=<span class="string">&quot;sgd&quot;</span>,init=<span class="string">&quot;louvain&quot;</span>,n_neighbors=<span class="number">10</span>,res=<span class="number">0.4</span>,n_clusters=<span class="number">10</span>,init_spa=<span class="literal">True</span>,tol=<span class="number">1e-3</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.trajectory=[]</span><br><span class="line">        <span class="keyword">if</span> opt==<span class="string">&quot;sgd&quot;</span>:</span><br><span class="line">            optimizer = optim.SGD(<span class="variable language_">self</span>.parameters(), lr=lr, momentum=<span class="number">0.9</span>)</span><br><span class="line">        <span class="keyword">elif</span> opt==<span class="string">&quot;admin&quot;</span>:</span><br><span class="line">            optimizer = optim.Adam(<span class="variable language_">self</span>.parameters(),lr=lr, weight_decay=weight_decay)</span><br><span class="line"></span><br><span class="line">        features= <span class="variable language_">self</span>.gc(torch.FloatTensor(X),torch.FloatTensor(adj))</span><br><span class="line">        <span class="comment">#----------------------------------------------------------------        </span></span><br><span class="line">        <span class="keyword">if</span> init==<span class="string">&quot;kmeans&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Initializing cluster centers with kmeans, n_clusters known&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>.n_clusters=n_clusters</span><br><span class="line">            kmeans = KMeans(<span class="variable language_">self</span>.n_clusters, n_init=<span class="number">20</span>)</span><br><span class="line">            <span class="keyword">if</span> init_spa:</span><br><span class="line">                <span class="comment">#------Kmeans use exp and spatial</span></span><br><span class="line">                y_pred = kmeans.fit_predict(features.detach().numpy())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#------Kmeans only use exp info, no spatial</span></span><br><span class="line">                y_pred = kmeans.fit_predict(X)  <span class="comment">#Here we use X as numpy</span></span><br><span class="line">        <span class="keyword">elif</span> init==<span class="string">&quot;louvain&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Initializing cluster centers with louvain, resolution = &quot;</span>, res)</span><br><span class="line">            <span class="keyword">if</span> init_spa:</span><br><span class="line">                adata=sc.AnnData(features.detach().numpy())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adata=sc.AnnData(X)</span><br><span class="line">            sc.pp.neighbors(adata, n_neighbors=n_neighbors)</span><br><span class="line">            sc.tl.louvain(adata,resolution=res)</span><br><span class="line">            y_pred=adata.obs[<span class="string">&#x27;louvain&#x27;</span>].astype(<span class="built_in">int</span>).to_numpy()</span><br><span class="line">            <span class="variable language_">self</span>.n_clusters=<span class="built_in">len</span>(np.unique(y_pred))</span><br><span class="line">        <span class="comment">#----------------------------------------------------------------</span></span><br><span class="line">        y_pred_last = y_pred</span><br><span class="line">        <span class="variable language_">self</span>.mu = Parameter(torch.Tensor(<span class="variable language_">self</span>.n_clusters, <span class="variable language_">self</span>.nhid))</span><br><span class="line">        X=torch.FloatTensor(X)</span><br><span class="line">        adj=torch.FloatTensor(adj)</span><br><span class="line">        <span class="variable language_">self</span>.trajectory.append(y_pred)</span><br><span class="line">        features=pd.DataFrame(features.detach().numpy(),index=np.arange(<span class="number">0</span>,features.shape[<span class="number">0</span>]))</span><br><span class="line">        Group=pd.Series(y_pred,index=np.arange(<span class="number">0</span>,features.shape[<span class="number">0</span>]),name=<span class="string">&quot;Group&quot;</span>)</span><br><span class="line">        Mergefeature=pd.concat([features,Group],axis=<span class="number">1</span>)</span><br><span class="line">        cluster_centers=np.asarray(Mergefeature.groupby(<span class="string">&quot;Group&quot;</span>).mean())</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.mu.data.copy_(torch.Tensor(cluster_centers))</span><br><span class="line">        <span class="variable language_">self</span>.train()</span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">            <span class="keyword">if</span> epoch%update_interval == <span class="number">0</span>:</span><br><span class="line">                _, q = <span class="variable language_">self</span>.forward(X,adj)</span><br><span class="line">                p = <span class="variable language_">self</span>.target_distribution(q).data</span><br><span class="line">            <span class="keyword">if</span> epoch%<span class="number">10</span>==<span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Epoch &quot;</span>, epoch) </span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            z,q = <span class="variable language_">self</span>(X, adj)</span><br><span class="line">            loss = <span class="variable language_">self</span>.loss_function(p, q)</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            <span class="keyword">if</span> epoch%trajectory_interval == <span class="number">0</span>:</span><br><span class="line">                <span class="variable language_">self</span>.trajectory.append(torch.argmax(q, dim=<span class="number">1</span>).data.cpu().numpy())</span><br><span class="line"></span><br><span class="line">            <span class="comment">#Check stop criterion</span></span><br><span class="line">            y_pred = torch.argmax(q, dim=<span class="number">1</span>).data.cpu().numpy()</span><br><span class="line">            delta_label = np.<span class="built_in">sum</span>(y_pred != y_pred_last).astype(np.float32) / X.shape[<span class="number">0</span>]</span><br><span class="line">            y_pred_last = y_pred</span><br><span class="line">            <span class="keyword">if</span> epoch&gt;<span class="number">0</span> <span class="keyword">and</span> (epoch-<span class="number">1</span>)%update_interval == <span class="number">0</span> <span class="keyword">and</span> delta_label &lt; tol:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;delta_label &#x27;</span>, delta_label, <span class="string">&#x27;&lt; tol &#x27;</span>, tol)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Reach tolerance threshold. Stopping training.&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Total epoch:&quot;</span>, epoch)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit_with_init</span>(<span class="params">self, X,adj, init_y, lr=<span class="number">0.001</span>, max_epochs=<span class="number">5000</span>, update_interval=<span class="number">1</span>, weight_decay=<span class="number">5e-4</span>,opt=<span class="string">&quot;sgd&quot;</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Initializing cluster centers with kmeans.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> opt==<span class="string">&quot;sgd&quot;</span>:</span><br><span class="line">            optimizer = optim.SGD(<span class="variable language_">self</span>.parameters(), lr=lr, momentum=<span class="number">0.9</span>)</span><br><span class="line">        <span class="keyword">elif</span> opt==<span class="string">&quot;admin&quot;</span>:</span><br><span class="line">            optimizer = optim.Adam(<span class="variable language_">self</span>.parameters(),lr=lr, weight_decay=weight_decay)</span><br><span class="line">        X=torch.FloatTensor(X)</span><br><span class="line">        adj=torch.FloatTensor(adj)</span><br><span class="line">        features, _ = <span class="variable language_">self</span>.forward(X,adj)</span><br><span class="line">        features=pd.DataFrame(features.detach().numpy(),index=np.arange(<span class="number">0</span>,features.shape[<span class="number">0</span>]))</span><br><span class="line">        Group=pd.Series(init_y,index=np.arange(<span class="number">0</span>,features.shape[<span class="number">0</span>]),name=<span class="string">&quot;Group&quot;</span>)</span><br><span class="line">        Mergefeature=pd.concat([features,Group],axis=<span class="number">1</span>)</span><br><span class="line">        cluster_centers=np.asarray(Mergefeature.groupby(<span class="string">&quot;Group&quot;</span>).mean())</span><br><span class="line">        <span class="variable language_">self</span>.mu.data.copy_(torch.Tensor(cluster_centers))</span><br><span class="line">        <span class="variable language_">self</span>.train()</span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">            <span class="keyword">if</span> epoch%update_interval == <span class="number">0</span>:</span><br><span class="line">                _, q = <span class="variable language_">self</span>.forward(torch.FloatTensor(X),torch.FloatTensor(adj))</span><br><span class="line">                p = <span class="variable language_">self</span>.target_distribution(q).data</span><br><span class="line">            X=torch.FloatTensor(X)</span><br><span class="line">            adj=torch.FloatTensor(adj)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            z,q = <span class="variable language_">self</span>(X, adj)</span><br><span class="line">            loss = <span class="variable language_">self</span>.loss_function(p, q)</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X, adj</span>):</span><br><span class="line">        z,q = <span class="variable language_">self</span>(torch.FloatTensor(X),torch.FloatTensor(adj))</span><br><span class="line">        <span class="keyword">return</span> z, q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>forward 函数对应着</p>\begin{equation} q_{ij} = \frac{(1+(h_i-\mu_j)^2)^{-1}}{\sum_{j' = 1}^{K} (1+(h_i-\mu_{j'})^2)^{-1}} \end{equation}<p>这也是上面提到过的<br>可以看到他显式的定义了 alpha=0.2，说明我们上面的猜测也是没错的。</p><p>loss_function 对应着</p>\begin{equation} L = KL(P||Q) = \displaystyle\sum^{N}_{i=1}\displaystyle\sum^{K}_{j=1}p_{ij}log\frac{p_{ij}}{q_{ij}} \end{equation}<p>target_distribution 对应着：</p>\begin{equation} p_{ij} = \frac{q_{ij}^2 / {\sum^{N}_{i=1}} q_{ij}}{\sum_{j^{\prime}}^{K}(q_{ij^{\prime}}^2 / {\sum^{N}_{i=1}q_{ij^{\prime}}})} \end{equation}<p>这里最不好理解的就是 features 是什么东西，以下是它的解释，方便后面来查阅：</p><h4 id="图卷积层的计算过程"><a class="anchor" href="#图卷积层的计算过程">#</a> 图卷积层的计算过程</h4><p>图卷积层（GC）通常执行以下步骤：</p><ol><li><strong>特征聚合</strong>：对于每个节点，将其特征与邻居节点的特征进行加权求和。</li><li><strong>线性变换</strong>：通过一个线性变换（通常是矩阵乘法）将聚合后的特征转换为新的特征表示。</li><li><strong>激活函数</strong>：通常还会应用一个激活函数（如 ReLU）来引入非线性。</li></ol><h4 id="具体计算步骤"><a class="anchor" href="#具体计算步骤">#</a> 具体计算步骤</h4><p>假设我们有一个简单的图数据集，并且已经定义了一个图卷积层，以下是一个完整的示例：</p><h5 id="导入必要的模块"><a class="anchor" href="#导入必要的模块">#</a> 导入必要的模块</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><h4 id="定义一个简单的图卷积层"><a class="anchor" href="#定义一个简单的图卷积层">#</a> 定义一个简单的图卷积层</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphConvolution</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_features, out_features</span>):</span><br><span class="line">        <span class="built_in">super</span>(GraphConvolution, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.weight = nn.Parameter(torch.FloatTensor(in_features, out_features))</span><br><span class="line">        <span class="variable language_">self</span>.reset_parameters()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset_parameters</span>(<span class="params">self</span>):</span><br><span class="line">        nn.init.xavier_uniform_(<span class="variable language_">self</span>.weight)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X, adj</span>):</span><br><span class="line">        support = torch.mm(X, <span class="variable language_">self</span>.weight)</span><br><span class="line">        output = torch.spmm(adj, support)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h5 id="创建一个简单的数据集"><a class="anchor" href="#创建一个简单的数据集">#</a> 创建一个简单的数据集</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个简单的特征矩阵</span></span><br><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个简单的邻接矩阵</span></span><br><span class="line">adj = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure><h5 id="创建模型实例并处理数据"><a class="anchor" href="#创建模型实例并处理数据">#</a> 创建模型实例并处理数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建图卷积层实例</span></span><br><span class="line">gc = GraphConvolution(in_features=<span class="number">3</span>, out_features=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将特征矩阵和邻接矩阵转换为 PyTorch 张量</span></span><br><span class="line">X_tensor = torch.FloatTensor(X)</span><br><span class="line">adj_tensor = torch.FloatTensor(adj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过图卷积层处理特征</span></span><br><span class="line">features = gc(X_tensor, adj_tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将结果从 PyTorch 张量转换为 NumPy 数组</span></span><br><span class="line">features_np = features.detach().numpy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Original Features:\n&quot;</span>, X)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Transformed Features:\n&quot;</span>, features_np)</span><br></pre></td></tr></table></figure><h4 id="具体计算过程"><a class="anchor" href="#具体计算过程">#</a> 具体计算过程</h4><ol><li><p><strong>特征矩阵 <code>X</code> 和邻接矩阵 <code>adj</code> </strong>：</p><ul><li><code>X</code> 的形状为 <code>(3, 3)</code> ，表示 3 个节点，每个节点有 3 个特征。</li><li><code>adj</code> 的形状为 <code>(3, 3)</code> ，表示节点之间的连接关系。</li></ul></li><li><p><strong>初始化权重矩阵 <code>self.weight</code> </strong>：</p><ul><li><code>self.weight</code> 是一个形状为 <code>(3, 3)</code> 的矩阵，通过 Xavier 初始化方法初始化。</li></ul></li><li><p><strong>特征聚合</strong>：</p><ul><li>首先，将输入特征矩阵 <code>X</code> 与权重矩阵 <code>self.weight</code> 进行矩阵乘法，得到支持矩阵 <code>support</code> 。</li><li><code>support = torch.mm(X, self.weight)</code></li></ul></li><li><p><strong>线性变换</strong>：</p><ul><li>然后，将支持矩阵 <code>support</code> 与邻接矩阵 <code>adj</code> 进行稀疏矩阵乘法，得到输出特征矩阵 <code>output</code> 。</li><li><code>output = torch.spmm(adj, support)</code></li></ul></li><li><p><strong>激活函数</strong>（可选）：</p><ul><li>在这个例子中，我们没有应用激活函数，但在实际应用中，通常会应用 ReLU 等激活函数。</li></ul></li></ol><h4 id="示例计算"><a class="anchor" href="#示例计算">#</a> 示例计算</h4><p>假设初始化后的权重矩阵 <code>self.weight</code> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.weight = torch.FloatTensor([</span><br><span class="line">    [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>],</span><br><span class="line">    [<span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.6</span>],</span><br><span class="line">    [<span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h5 id="计算支持矩阵-support"><a class="anchor" href="#计算支持矩阵-support">#</a> 计算支持矩阵 <code>support</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">support = torch.mm(X_tensor, <span class="variable language_">self</span>.weight)</span><br></pre></td></tr></table></figure><p>具体计算如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X_tensor = [[1, 2, 3],</span><br><span class="line">            [4, 5, 6],</span><br><span class="line">            [7, 8, 9]]</span><br><span class="line"></span><br><span class="line">self.weight = [[0.1, 0.2, 0.3],</span><br><span class="line">               [0.4, 0.5, 0.6],</span><br><span class="line">               [0.7, 0.8, 0.9]]</span><br><span class="line"></span><br><span class="line">support = X_tensor @ self.weight</span><br></pre></td></tr></table></figure><p>计算结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">support = [[1 * 0.1 + 2 * 0.4 + 3 * 0.7, 1 * 0.2 + 2 * 0.5 + 3 * 0.8, 1 * 0.3 + 2 * 0.6 + 3 * 0.9],</span><br><span class="line">           [4 * 0.1 + 5 * 0.4 + 6 * 0.7, 4 * 0.2 + 5 * 0.5 + 6 * 0.8, 4 * 0.3 + 5 * 0.6 + 6 * 0.9],</span><br><span class="line">           [7 * 0.1 + 8 * 0.4 + 9 * 0.7, 7 * 0.2 + 8 * 0.5 + 9 * 0.8, 7 * 0.3 + 8 * 0.6 + 9 * 0.9]]</span><br><span class="line"></span><br><span class="line">support = [[2.4, 3.2, 4.0],</span><br><span class="line">           [6.0, 8.0, 10.0],</span><br><span class="line">           [9.6, 12.8, 16.0]]</span><br></pre></td></tr></table></figure><h5 id="计算输出特征矩阵-output"><a class="anchor" href="#计算输出特征矩阵-output">#</a> 计算输出特征矩阵 <code>output</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = torch.spmm(adj_tensor, support)</span><br></pre></td></tr></table></figure><p>具体计算如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">adj_tensor = [[0, 1, 0],</span><br><span class="line">              [1, 0, 1],</span><br><span class="line">              [0, 1, 0]]</span><br><span class="line"></span><br><span class="line">support = [[2.4, 3.2, 4.0],</span><br><span class="line">           [6.0, 8.0, 10.0],</span><br><span class="line">           [9.6, 12.8, 16.0]]</span><br><span class="line"></span><br><span class="line">output = adj_tensor @ support</span><br></pre></td></tr></table></figure><p>计算结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output = [[0 * 2.4 + 1 * 6.0 + 0 * 9.6, 0 * 3.2 + 1 * 8.0 + 0 * 12.8, 0 * 4.0 + 1 * 10.0 + 0 * 16.0],</span><br><span class="line">          [1 * 2.4 + 0 * 6.0 + 1 * 9.6, 1 * 3.2 + 0 * 8.0 + 1 * 12.8, 1 * 4.0 + 0 * 10.0 + 1 * 16.0],</span><br><span class="line">          [0 * 2.4 + 1 * 6.0 + 0 * 9.6, 0 * 3.2 + 1 * 8.0 + 0 * 12.8, 0 * 4.0 + 1 * 10.0 + 0 * 16.0]]</span><br><span class="line"></span><br><span class="line">output = [[6.0, 8.0, 10.0],</span><br><span class="line">          [12.0, 16.0, 20.0],</span><br><span class="line">          [6.0, 8.0, 10.0]]</span><br></pre></td></tr></table></figure><h4 id="最终结果"><a class="anchor" href="#最终结果">#</a> 最终结果</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Original Features:\n&quot;</span>, X)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Transformed Features:\n&quot;</span>, features_np)</span><br></pre></td></tr></table></figure><p>输出可能如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Original Features:</span><br><span class="line"> [[1 2 3]</span><br><span class="line"> [4 5 6]</span><br><span class="line"> [7 8 9]]</span><br><span class="line">Transformed Features:</span><br><span class="line"> [[ 6.0  8.0 10.0]</span><br><span class="line"> [12.0 16.0 20.0]</span><br><span class="line"> [ 6.0  8.0 10.0]]</span><br></pre></td></tr></table></figure><h4 id="解释"><a class="anchor" href="#解释">#</a> 解释</h4><ol><li><p><strong>原始特征 <code>X</code> </strong>：</p><ul><li>输入特征矩阵 <code>X</code> 的形状为 <code>(3, 3)</code> ，表示 3 个节点，每个节点有 3 个特征。</li></ul></li><li><p><strong>变换后的特征 <code>features</code> </strong>：</p><ul><li>经过图卷积层处理后， <code>features</code> 变成了一个新的特征矩阵，形状仍然是 <code>(3, 3)</code> ，但内容已经包含了图结构的信息。</li><li>例如，第一个节点的新特征 <code>[6.0, 8.0, 10.0]</code> 是通过聚合第一个节点的特征及其邻居节点的特征得到的。</li></ul></li><li><p><strong>数据类型转换</strong>：</p><ul><li><code>features</code> 最初是一个 PyTorch 张量。</li><li>通过 <code>detach()</code> 方法从计算图中分离张量，返回一个新的张量，不再记录任何梯度信息。</li><li>通过 <code>numpy()</code> 方法将 PyTorch 张量转换为 NumPy 数组，方便后续的数据处理和分析。</li></ul></li></ol><h4 id="总结"><a class="anchor" href="#总结">#</a> 总结</h4><p>图卷积层通过特征聚合和线性变换将输入特征矩阵 <code>X</code> 转换为新的特征表示 <code>features</code> ，这些新的特征表示包含了图结构的信息。希望这个详细的解释能帮助你更好地理解和使用图卷积层的计算过程。</p><p>需要注意的是，如果像我们的代码没有显式的定义 weight 的值，它会自动用 xavier 来定义一个。这对应论文中的 B 矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphConvolution</span>(<span class="title class_ inherited__">Module</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Simple GCN layer, similar to https://arxiv.org/abs/1609.02907</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_features, out_features, bias=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(GraphConvolution, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.in_features = in_features</span><br><span class="line">        <span class="variable language_">self</span>.out_features = out_features</span><br><span class="line">        <span class="variable language_">self</span>.weight = Parameter(torch.FloatTensor(in_features, out_features))</span><br><span class="line">        <span class="comment">#self.weight 是通过 nn.Parameter 定义的，并且在 reset_parameters 方法中使用了 nn.init.xavier_uniform_ 方法进行初始化。这意味着 self.weight 的值会被 Xavier 均匀分布初始化方法随机初始化。</span></span><br><span class="line">        <span class="keyword">if</span> bias:</span><br><span class="line">            <span class="variable language_">self</span>.bias = Parameter(torch.FloatTensor(out_features))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.register_parameter(<span class="string">&#x27;bias&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="variable language_">self</span>.reset_parameters()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset_parameters</span>(<span class="params">self</span>):</span><br><span class="line">        stdv = <span class="number">1.</span> / math.sqrt(<span class="variable language_">self</span>.weight.size(<span class="number">1</span>))</span><br><span class="line">        <span class="variable language_">self</span>.weight.data.uniform_(-stdv, stdv)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.bias.data.uniform_(-stdv, stdv)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span>, adj</span>):</span><br><span class="line">        support = torch.mm(<span class="built_in">input</span>, <span class="variable language_">self</span>.weight)</span><br><span class="line">        output = torch.spmm(adj, support)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> output + <span class="variable language_">self</span>.bias</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__class__.__name__ + <span class="string">&#x27; (&#x27;</span> \</span><br><span class="line">               + <span class="built_in">str</span>(<span class="variable language_">self</span>.in_features) + <span class="string">&#x27; -&gt; &#x27;</span> \</span><br><span class="line">               + <span class="built_in">str</span>(<span class="variable language_">self</span>.out_features) + <span class="string">&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure><p>上面是论文中的代码定义的卷积层，可以看到它是如何定义的。</p><hr><h4 id="1-self是什么为什么selfx-adj可以前向传播"><a class="anchor" href="#1-self是什么为什么selfx-adj可以前向传播">#</a> <strong>1. <code>self</code> 是什么？为什么 <code>self(X, adj)</code> 可以前向传播？</strong></h4><ul><li><p><strong><code>self</code> 是当前模型实例</strong>：</p><ul><li>在 Python 的类定义中， <code>self</code> 代表类的实例。在 PyTorch 中， <code>self</code> 通常是 <code>torch.nn.Module</code> 的子类实例，即一个模型对象。</li></ul></li><li><p><strong>为什么可以调用 <code>self(X, adj)</code> ？</strong></p><ul><li>这是因为在定义模型类时，我们重载了 <code>nn.Module</code> 的 <code>__call__</code> 方法（继承自 PyTorch 的 <code>nn.Module</code> ）。</li><li>当执行 <code>self(X, adj)</code> 时，会自动调用模型的 <code>forward</code> 方法，这在模型设计中是标准行为：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, adj</span>):</span><br><span class="line">    <span class="comment"># 前向传播的逻辑</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li>所以 <code>self(X, adj)</code> 是 <code>self.forward(X, adj)</code> 的简写，直接执行前向传播。</li></ul></li></ul><hr><h4 id="2-为什么-loss-是一个数却可以调用-lossbackward底层逻辑是什么"><a class="anchor" href="#2-为什么-loss-是一个数却可以调用-lossbackward底层逻辑是什么">#</a> <strong>2. 为什么 <code>loss</code> 是一个数，却可以调用 <code>loss.backward()</code> ？底层逻辑是什么？</strong></h4><h5 id="loss-的值和张量计算图"><a class="anchor" href="#loss-的值和张量计算图">#</a> <strong><code>loss</code> 的值和张量计算图</strong></h5><ul><li><strong><code>loss</code> 是一个标量张量</strong>：<ul><li><code>loss</code> 是通过 <code>loss_function(p, q)</code> 计算得来的，其值是一个单一标量张量，例如形状为 <code>torch.Size([])</code> 。</li><li>PyTorch 会为所有涉及 <code>p</code> 和 <code>q</code> 的计算构建动态计算图，记录每一步计算及其操作（加法、乘法等）。</li></ul></li></ul><h5 id="backward-的作用"><a class="anchor" href="#backward-的作用">#</a> <strong><code>backward()</code> 的作用</strong></h5><ul><li>当调用 <code>loss.backward()</code> 时：<ul><li>PyTorch 沿着计算图，从 <code>loss</code> 的值开始，计算其对每个参数的梯度。</li><li>这些梯度会存储到模型的参数（如 <code>self.gc</code> 和 <code>self.mu</code> ）的 <code>grad</code> 属性中。</li></ul></li></ul><h5 id="如何支持梯度计算"><a class="anchor" href="#如何支持梯度计算">#</a> <strong>如何支持梯度计算？</strong></h5><ul><li>计算图的构建依赖 PyTorch 的张量操作，所有张量都默认 <code>requires_grad=False</code> 。</li><li>只有模型参数（如 <code>self.parameters()</code> 返回的张量）设置了 <code>requires_grad=True</code> ，PyTorch 才会在计算图中记录这些张量的操作，进而支持梯度计算。</li></ul><hr><h4 id="3-为什么可以执行-optimizerstepoptimizer-默认操作的是谁"><a class="anchor" href="#3-为什么可以执行-optimizerstepoptimizer-默认操作的是谁">#</a> <strong>3. 为什么可以执行 <code>optimizer.step()</code> ？ <code>optimizer</code> 默认操作的是谁？</strong></h4><h5 id="optimizer-是如何绑定模型参数的"><a class="anchor" href="#optimizer-是如何绑定模型参数的">#</a> <strong><code>optimizer</code> 是如何绑定模型参数的？</strong></h5><ul><li>优化器初始化时，我们传入了 <code>self.parameters()</code> ：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.SGD(<span class="variable language_">self</span>.parameters(), lr=lr, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure></li><li><code>self.parameters()</code> 是一个生成器，包含模型中所有可训练参数（即 <code>requires_grad=True</code> 的张量），如 <code>self.gc</code> 和 <code>self.mu</code> 。</li><li>优化器会记录这些参数，并在调用 <code>optimizer.step()</code> 时，更新这些参数的值。</li></ul><h5 id="optimizerstep-的作用"><a class="anchor" href="#optimizerstep-的作用">#</a> <strong><code>optimizer.step()</code> 的作用</strong></h5><ul><li>在调用 <code>loss.backward()</code> 后，参数的梯度存储在每个参数的 <code>grad</code> 属性中。</li><li><code>optimizer.step()</code> 使用这些梯度，根据优化算法（如 SGD 或 Adam）更新参数值：<ul><li>SGD 更新公式： <code>param = param - lr * grad</code></li><li>Adam 等高级算法会对梯度进行一些额外的修正。</li></ul></li></ul><hr><h4 id="4-selftrain-训练了什么"><a class="anchor" href="#4-selftrain-训练了什么">#</a> <strong>4. <code>self.train()</code> 训练了什么？</strong></h4><ul><li><p><strong><code>self.train()</code> 的作用</strong>：</p><ul><li>它不会直接 “训练” 模型，而是将模型切换到训练模式。</li><li>PyTorch 的 <code>nn.Module</code> 有两种模式： <code>train()</code> 和 <code>eval()</code> 。<ul><li>在 <code>train()</code> 模式下，某些层（如 <code>Dropout</code> 和 <code>BatchNorm</code> ）会启用特定的训练行为。</li><li>在 <code>eval()</code> 模式下，这些层的行为会发生变化（如 <code>Dropout</code> 禁用、 <code>BatchNorm</code> 使用固定统计值）。</li></ul></li></ul></li><li><p><strong>模型训练本质</strong>：</p><ul><li>训练实际上由反向传播和优化器更新参数实现：<ol><li>前向传播计算输出；</li><li>计算损失；</li><li>调用 <code>loss.backward()</code> 计算梯度；</li><li>调用 <code>optimizer.step()</code> 更新参数。</li></ol></li></ul></li></ul><hr><h4 id="总结-2"><a class="anchor" href="#总结-2">#</a> <strong>总结</strong></h4><ol><li><strong><code>self</code> </strong>是模型实例，调用 <code>self(X, adj)</code> 本质是调用模型的 <code>forward</code> 方法。</li><li><strong><code>loss</code> 是一个标量张量</strong>，它的计算图记录了所有依赖操作， <code>loss.backward()</code> 会计算所有参数的梯度。</li><li><strong><code>optimizer.step()</code> 更新的是绑定到优化器的模型参数</strong>，这些参数通过 <code>self.parameters()</code> 显式指定。</li><li><strong><code>self.train()</code> 设置模型为训练模式</strong>，实际训练逻辑由前向传播、反向传播和优化器更新完成。</li></ol><p>上面的代码都是 simple 的部分，还有一个正常版本，多了 ReLu 和 dropout，设立了两层卷积层。这里就不赘述了，大体思路是一样的。</p><h2 id="svgs"><a class="anchor" href="#svgs">#</a> SVGs</h2><h3 id="原理性的东西-2"><a class="anchor" href="#原理性的东西-2">#</a> 原理性的东西</h3><p>其实反倒这里没什么好说的了，具体实现的东西和论文里面差不多，可以记录几个自己认为值得记录的几处：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nbr_num = [(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> nbr_num.items() <span class="keyword">if</span> v &gt; (ratio * cluster_num[k])]</span><br><span class="line"></span><br><span class="line">nbr_num.sort(key=<span class="keyword">lambda</span> x: -x[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>这里面是通过 nbr_num.items () 取出键值对</p><p><code>lambda x: -x[1]</code> 是一个匿名函数，接受一个二元组 <code>x</code> 作为输入，返回 <code>-x[1]</code> ，即二元组的第二个元素的负值。</p><p>其实具体就是把论文中提到的给实现了，没什么好说的</p><h2 id="实际使用"><a class="anchor" href="#实际使用">#</a> 实际使用</h2><p>这里就具体记录一下自己复现过程遇到的问题吧<br>算了，实际上也没遇到什么问题，下面是跑出来的结果</p><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0001.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0002.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0003.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0004.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0005.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0006.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0007.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0008.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0009.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0010.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0011.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0012.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0013.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0014.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0015.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0016.jpg" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/tutorial_pages-to-jpg-0017.jpg" alt=""></p><div class="tags"><a href="/tags/%E7%94%9F%E7%89%A9/" rel="tag"><i class="ic i-tag"></i> 生物</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B1%BB/" rel="tag"><i class="ic i-tag"></i> 学习笔记类</a> <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="ic i-tag"></i> 算法</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-04-30 10:51:14" itemprop="dateModified" datetime="2025-04-30T10:51:14+08:00">2025-04-30</time> </span><span id="article/SpaGCN/" class="item leancloud_visitors" data-flag-title="SpaGCN" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Lemon Sour <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="http://amentiraz.github.io/article/SpaGCN/" title="SpaGCN">http://amentiraz.github.io/article/SpaGCN/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/article/Matching-Anything-by-Segmenting-Anything/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;amentirazblogpic.oss-cn-hangzhou.aliyuncs.com&#x2F;blogpic&#x2F;%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925124438.jpg" title="Matching_Anything_by_Segmenting_Anything"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 论文</span><h3>Matching_Anything_by_Segmenting_Anything</h3></a></div><div class="item right"><a href="/note/%E3%80%8A%E7%B4%A0%E9%A3%9F%E8%80%85%E3%80%8B%EF%BC%9A%E5%B7%A7%E5%85%8B%E5%8A%9B%E5%91%B3%E7%9A%84%E5%B1%8E/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;amentirazblogpic.oss-cn-hangzhou.aliyuncs.com&#x2F;blogpic&#x2F;%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925124522.jpg" title="《素食者》：巧克力味的屎"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 书</span><h3>《素食者》：巧克力味的屎</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#introduction"><span class="toc-number">2.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#result"><span class="toc-number">3.</span> <span class="toc-text">Result</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#overview-of-spagcn-and-evaluation"><span class="toc-number">3.1.</span> <span class="toc-text">Overview of SpaGCN and evaluation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#application-to-human-primary-pancreatic%E8%83%B0%E8%85%BA%E7%9A%84-cancer-st-data"><span class="toc-number">3.2.</span> <span class="toc-text">Application to human primary pancreatic (胰腺的) cancer ST data</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-p%E5%80%BCp-value"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. P 值（p-value）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-q%E5%80%BCq-value"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. Q 值（q-value）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="toc-number">3.2.3.</span> <span class="toc-text">总结对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#application-to-human-dorsolateral-prefrontal-cortex-10x-visium-data"><span class="toc-number">3.3.</span> <span class="toc-text">Application to human dorsolateral prefrontal cortex 10x Visium data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#application-to-mouse-posterior%E5%90%8E%E9%9D%A2%E7%9A%84-brain-10x-visium-data"><span class="toc-number">3.4.</span> <span class="toc-text">Application to mouse posterior (后面的) brain 10x Visium data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#application-to-mouse-visual-cortex-starmap-data"><span class="toc-number">3.5.</span> <span class="toc-text">Application to mouse visual cortex STARmap data</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#discussion"><span class="toc-number">4.</span> <span class="toc-text">Discussion</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#methods"><span class="toc-number">5.</span> <span class="toc-text">Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#data-prepocessing"><span class="toc-number">5.1.</span> <span class="toc-text">Data prepocessing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#conversion-of-srt-data-into-graph-structured-data"><span class="toc-number">5.2.</span> <span class="toc-text">Conversion of SRT data into graph-structured data</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#calculation-of-distance-between-two-vertices"><span class="toc-number">5.2.1.</span> <span class="toc-text">Calculation of distance between two vertices</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calculation-of-weight-for-each-edge-and-construction-of-graph"><span class="toc-number">5.2.2.</span> <span class="toc-text">Calculation of weight for each edge and construction of graph</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#graph-convolutional-layer"><span class="toc-number">5.2.3.</span> <span class="toc-text">Graph convolutional layer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spatial-domain-identification-by-clustering"><span class="toc-number">5.2.4.</span> <span class="toc-text">Spatial domain identification by clustering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#detection-of-svgs"><span class="toc-number">5.2.5.</span> <span class="toc-text">Detection of SVGs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%E4%B8%8E%E8%A1%A8%E7%A4%BA"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">1. 数据来源与表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">5.2.5.2.</span> <span class="toc-text">2. 数据预处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B7%AE%E5%BC%82%E8%A1%A8%E8%BE%BE%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.5.3.</span> <span class="toc-text">3. 差异表达的统计模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C"><span class="toc-number">5.2.5.3.1.</span> <span class="toc-text">（1）假设检验</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E9%AA%8C%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.5.3.1.1.</span> <span class="toc-text">检验方法：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%9F%E8%AE%A1%E9%87%8F"><span class="toc-number">5.2.5.3.1.2.</span> <span class="toc-text">关键统计量：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E5%A4%9A%E9%87%8D%E6%A3%80%E9%AA%8C%E6%A0%A1%E6%AD%A3"><span class="toc-number">5.2.5.3.2.</span> <span class="toc-text">（2）多重检验校正</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B7%AE%E5%BC%82%E5%9F%BA%E5%9B%A0%E7%AD%9B%E9%80%89"><span class="toc-number">5.2.5.4.</span> <span class="toc-text">4. 差异基因筛选</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%A3%E9%87%8A"><span class="toc-number">5.2.5.5.</span> <span class="toc-text">5. 可视化与结果解释</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E7%81%AB%E5%B1%B1%E5%9B%BEvolcano-plot"><span class="toc-number">5.2.5.5.1.</span> <span class="toc-text">（1）火山图（Volcano Plot）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E7%83%AD%E5%9B%BEheatmap"><span class="toc-number">5.2.5.5.2.</span> <span class="toc-text">（2）热图（Heatmap）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%90%8E%E7%BB%AD%E5%88%86%E6%9E%90"><span class="toc-number">5.2.5.6.</span> <span class="toc-text">6. 后续分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.2.5.7.</span> <span class="toc-text">1. 应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.5.8.</span> <span class="toc-text">2. 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E5%81%87%E8%AE%BE"><span class="toc-number">5.2.5.8.1.</span> <span class="toc-text">（1）假设</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.2.5.8.2.</span> <span class="toc-text">（2）步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.2.5.9.</span> <span class="toc-text">3. 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%E5%90%88%E5%B9%B6%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">5.2.5.9.1.</span> <span class="toc-text">步骤 1：合并并排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%E8%AE%A1%E7%AE%97%E7%A7%A9%E5%92%8C"><span class="toc-number">5.2.5.9.2.</span> <span class="toc-text">步骤 2：计算秩和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3%E8%AE%A1%E7%AE%97-u-%E5%80%BC"><span class="toc-number">5.2.5.9.3.</span> <span class="toc-text">步骤 3：计算 UUU 值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-4%E6%9F%A5%E8%A1%A8%E5%BE%97-p-%E5%80%BC"><span class="toc-number">5.2.5.9.4.</span> <span class="toc-text">步骤 4：查表得 p 值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BC%98%E7%82%B9"><span class="toc-number">5.2.5.10.</span> <span class="toc-text">4. 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%99%90%E5%88%B6"><span class="toc-number">5.2.5.11.</span> <span class="toc-text">5. 限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#detection-of-spatially-variable-meta-genes"><span class="toc-number">5.2.6.</span> <span class="toc-text">Detection of spatially variable meta genes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#evaluation-of-svgs-using-moransi-and-gearys-statics"><span class="toc-number">5.2.7.</span> <span class="toc-text">Evaluation of SVGs using Moran&#39;sI and Geary&#39;s statics</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#clustering"><span class="toc-number">6.1.</span> <span class="toc-text">Clustering</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E6%80%A7%E7%9A%84%E4%B8%9C%E8%A5%BF"><span class="toc-number">6.1.1.</span> <span class="toc-text">原理性的东西</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%8D%B7%E7%A7%AF%E5%B1%82%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">图卷积层的计算过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AE%A1%E7%AE%97%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">具体计算步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%BF%85%E8%A6%81%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-number">6.1.1.2.1.</span> <span class="toc-text">导入必要的模块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E5%8D%B7%E7%A7%AF%E5%B1%82"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">定义一个简单的图卷积层</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="toc-number">6.1.1.3.1.</span> <span class="toc-text">创建一个简单的数据集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B%E5%B9%B6%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE"><span class="toc-number">6.1.1.3.2.</span> <span class="toc-text">创建模型实例并处理数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B"><span class="toc-number">6.1.1.4.</span> <span class="toc-text">具体计算过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%AE%A1%E7%AE%97"><span class="toc-number">6.1.1.5.</span> <span class="toc-text">示例计算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%94%AF%E6%8C%81%E7%9F%A9%E9%98%B5-support"><span class="toc-number">6.1.1.5.1.</span> <span class="toc-text">计算支持矩阵 support</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E8%BE%93%E5%87%BA%E7%89%B9%E5%BE%81%E7%9F%A9%E9%98%B5-output"><span class="toc-number">6.1.1.5.2.</span> <span class="toc-text">计算输出特征矩阵 output</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C"><span class="toc-number">6.1.1.6.</span> <span class="toc-text">最终结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">6.1.1.7.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.1.1.8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-self%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88selfx-adj%E5%8F%AF%E4%BB%A5%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD"><span class="toc-number">6.1.1.9.</span> <span class="toc-text">1. self 是什么？为什么 self(X, adj) 可以前向传播？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-loss-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E5%8D%B4%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8-lossbackward%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.1.1.10.</span> <span class="toc-text">2. 为什么 loss 是一个数，却可以调用 loss.backward() ？底层逻辑是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#loss-%E7%9A%84%E5%80%BC%E5%92%8C%E5%BC%A0%E9%87%8F%E8%AE%A1%E7%AE%97%E5%9B%BE"><span class="toc-number">6.1.1.10.1.</span> <span class="toc-text">loss 的值和张量计算图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#backward-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.1.1.10.2.</span> <span class="toc-text">backward() 的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E6%A2%AF%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="toc-number">6.1.1.10.3.</span> <span class="toc-text">如何支持梯度计算？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C-optimizerstepoptimizer-%E9%BB%98%E8%AE%A4%E6%93%8D%E4%BD%9C%E7%9A%84%E6%98%AF%E8%B0%81"><span class="toc-number">6.1.1.11.</span> <span class="toc-text">3. 为什么可以执行 optimizer.step() ？ optimizer 默认操作的是谁？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#optimizer-%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84"><span class="toc-number">6.1.1.11.1.</span> <span class="toc-text">optimizer 是如何绑定模型参数的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#optimizerstep-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.1.1.11.2.</span> <span class="toc-text">optimizer.step() 的作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-selftrain-%E8%AE%AD%E7%BB%83%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">6.1.1.12.</span> <span class="toc-text">4. self.train() 训练了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">6.1.1.13.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#svgs"><span class="toc-number">6.2.</span> <span class="toc-text">SVGs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E6%80%A7%E7%9A%84%E4%B8%9C%E8%A5%BF-2"><span class="toc-number">6.2.1.</span> <span class="toc-text">原理性的东西</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">实际使用</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/article/scRNA%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" rel="bookmark" title="scRNA论文笔记">scRNA论文笔记</a></li><li><a href="/article/What-is-A-Cell-Type/" rel="bookmark" title="What_is_A_Cell_Type">What_is_A_Cell_Type</a></li><li><a href="/article/Cell-Review-What-is-a-cell-type-and-how-to-define-it/" rel="bookmark" title="Cell_Review_What_is_a_cell_type_and_how_to_define_it">Cell_Review_What_is_a_cell_type_and_how_to_define_it</a></li><li><a href="/article/Benchmarking-spatial-claustering-methods-with-spatially-resolved-transcriptomic-data/" rel="bookmark" title="Benchmarking-spatial-claustering-methods-with-spatially-resolved-transcriptomic-data">Benchmarking-spatial-claustering-methods-with-spatially-resolved-transcriptomic-data</a></li><li><a href="/article/%E8%AE%BA%E6%96%87ppt1/" rel="bookmark" title="论文ppt1">论文ppt1</a></li><li><a href="/article/Matching-Anything-by-Segmenting-Anything/" rel="bookmark" title="Matching_Anything_by_Segmenting_Anything">Matching_Anything_by_Segmenting_Anything</a></li><li class="active"><a href="/article/SpaGCN/" rel="bookmark" title="SpaGCN">SpaGCN</a></li><li><a href="/article/STAGATE/" rel="bookmark" title="STAGATE">STAGATE</a></li><li><a href="/article/MENDER/" rel="bookmark" title="MENDER">MENDER</a></li><li><a href="/article/scanpy%E6%95%B0%E6%8D%AE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/" rel="bookmark" title="scanpy数据使用笔记">scanpy数据使用笔记</a></li><li><a href="/article/BayesSpace/" rel="bookmark" title="BayesSpace">BayesSpace</a></li><li><a href="/article/%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AE%B0%E5%BD%95/" rel="bookmark" title="数据集记录">数据集记录</a></li><li><a href="/article/DeepST/" rel="bookmark" title="DeepST">DeepST</a></li><li><a href="/article/EnSDD/" rel="bookmark" title="EnSDD">EnSDD</a></li><li><a href="/article/domain%E5%86%85%E5%AE%B9%E7%9A%84%E6%80%BB%E7%BB%93/" rel="bookmark" title="对spatial domain内容的总结">对spatial domain内容的总结</a></li><li><a href="/article/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%B1%87%E6%80%BB/" rel="bookmark" title="毕业设计文档汇总">毕业设计文档汇总</a></li><li><a href="/article/scPerturb/" rel="bookmark" title="scPerturb">scPerturb</a></li><li><a href="/GEARS/" rel="bookmark" title="GEARS">GEARS</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Lemon Sour" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Lemon Sour</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">83</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">26</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">57</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FtZW50aXJheg==" title="https:&#x2F;&#x2F;github.com&#x2F;Amentiraz"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9kc2ZseS04" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;dsfly-8"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE1MTc2ODUzMzM=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1517685333"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnZpb2xlbW9uQDE2My5jb20=" title="mailto:violemon@163.com"><i class="ic i-envelope"></i></span> <span class="exturl item bangumi" data-url="aHR0cHM6Ly9iYW5ndW1pLnR2L2FuaW1lL2xpc3QvNjY4MDE2" title="https:&#x2F;&#x2F;bangumi.tv&#x2F;anime&#x2F;list&#x2F;668016"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-magic"></i>关于</a><ul class="submenu"><li class="item"><a href="/author/" rel="section"><i class="ic i-user"></i>本人</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-cloud"></i>其它</a><ul class="submenu"><li class="item"><a href="/music/" rel="section"><i class="ic i-music"></i>音乐区</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>朋友</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/article/Matching-Anything-by-Segmenting-Anything/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/note/%E3%80%8A%E7%B4%A0%E9%A3%9F%E8%80%85%E3%80%8B%EF%BC%9A%E5%B7%A7%E5%85%8B%E5%8A%9B%E5%91%B3%E7%9A%84%E5%B1%8E/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/music/" title="分类于 音乐">音乐</a> <i class="ic i-angle-right"></i> <a href="/categories/music/%E4%B9%90%E7%90%86/" title="分类于 乐理">乐理</a></div><span><a href="/music/%E5%90%89%E4%BB%96%E4%B9%90%E7%90%86-Funk%E7%B1%BB/" title="吉他乐理-Funk类">吉他乐理-Funk类</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/music/" title="分类于 音乐">音乐</a> <i class="ic i-angle-right"></i> <a href="/categories/music/%E4%B9%90%E7%90%86/" title="分类于 乐理">乐理</a></div><span><a href="/music/%E5%B8%B8%E8%A7%81%E5%92%8C%E5%BC%A6/" title="常见和弦">常见和弦</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/code/" title="分类于 代码">代码</a> <i class="ic i-angle-right"></i> <a href="/categories/code/OI/" title="分类于 OI">OI</a></div><span><a href="/code/Dijkstra/" title="Dijkstra">Dijkstra</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/code/" title="分类于 代码">代码</a> <i class="ic i-angle-right"></i> <a href="/categories/code/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" title="分类于 编程语言">编程语言</a></div><span><a href="/code/%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="文件学习笔记">文件学习笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/code/" title="分类于 代码">代码</a> <i class="ic i-angle-right"></i> <a href="/categories/code/ECS/" title="分类于 ECS">ECS</a></div><span><a href="/code/%E9%98%BF%E9%87%8C%E4%BA%91ECS%E8%BF%9C%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%AC%94%E8%AE%B0/" title="阿里云ECS远程运行笔记">阿里云ECS远程运行笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/life/" title="分类于 生活">生活</a> <i class="ic i-angle-right"></i> <a href="/categories/life/%E4%BC%BC%E6%B0%B4%E6%B5%81%E5%B9%B4/" title="分类于 似水流年">似水流年</a></div><span><a href="/life/%E8%A7%81%E5%AD%97%E5%A6%82%E9%9D%A2/" title="见字如面">见字如面</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/code/" title="分类于 代码">代码</a> <i class="ic i-angle-right"></i> <a href="/categories/code/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/" title="分类于 数学建模">数学建模</a></div><span><a href="/code/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E4%BD%9C%E4%B8%9A/" title="分布式大作业">分布式大作业</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/music/" title="分类于 音乐">音乐</a> <i class="ic i-angle-right"></i> <a href="/categories/music/%E4%B9%90%E8%B0%B1/" title="分类于 乐谱">乐谱</a></div><span><a href="/music/%E6%8C%87%E5%BC%B9%E8%B0%B1%E5%90%88%E9%9B%86/" title="指弹谱合集">指弹谱合集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/note/" title="分类于 影视书籍">影视书籍</a> <i class="ic i-angle-right"></i> <a href="/categories/note/%E5%8A%A8%E6%BC%AB/" title="分类于 动漫">动漫</a></div><span><a href="/note/FLCL/" title="FLCL">FLCL</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/life/" title="分类于 生活">生活</a> <i class="ic i-angle-right"></i> <a href="/categories/life/%E6%80%9D%E8%80%83/" title="分类于 思考">思考</a></div><span><a href="/life/%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%AD%94%E7%9A%84%E5%90%AB%E4%B9%89/" title="关于面孔的含义">关于面孔的含义</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Lemon Sour @ Amentiraz</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"article/SpaGCN/",favicon:{show:"⁽⁽ଘ( ˊᵕˋ )ଓ⁾⁾",hide:"(つд⊂)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->