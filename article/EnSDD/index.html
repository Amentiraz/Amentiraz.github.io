<!-- build time:Wed Dec 31 2025 18:45:48 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="http://amentiraz.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="http://amentiraz.github.io/atom.xml"><link rel="alternate" type="application/json" href="http://amentiraz.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="生物,学习笔记类,算法"><link rel="canonical" href="http://amentiraz.github.io/article/EnSDD/"><title>EnSDD - 论文 | Amentiraz =</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">EnSDD</h1><div class="meta"><span class="item" title="创建时间：2025-02-17 11:01:55"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2025-02-17T11:01:55+08:00">2025-02-17</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>62k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>56 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Amentiraz</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925124558.png"></li><li class="item" data-background-image="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925162737.jpg"></li><li class="item" data-background-image="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925124421.png"></li><li class="item" data-background-image="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925124526.jpg"></li><li class="item" data-background-image="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925162929.png"></li><li class="item" data-background-image="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925162718.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/article/" itemprop="item" rel="index" title="分类于 论文"><span itemprop="name">论文</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://amentiraz.github.io/article/EnSDD/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Lemon Sour"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><p>Enhancing spatial domain detection in spatial transcriptomics with EnSDD</p><span id="more"></span><details class="danger"><summary>先用chatgpt提炼一下要点：</summary><div><h3 id="论文要点提炼enhancing-spatial-domain-detection-in-spatial-transcriptomics-with-ensdd"><a class="anchor" href="#论文要点提炼enhancing-spatial-domain-detection-in-spatial-transcriptomics-with-ensdd">#</a> 论文要点提炼：《Enhancing Spatial Domain Detection in Spatial Transcriptomics with EnSDD》</h3><h4 id="1-研究背景"><a class="anchor" href="#1-研究背景">#</a> <strong>1. 研究背景</strong></h4><ul><li>空间转录组学（Spatial Transcriptomics, SRT）帮助理解器官功能和组织微环境，但空间域（spatial domains）的准确识别仍是挑战。</li><li>现有的空间域检测方法（如 BayesSpace、GraphST、STAGATE 等）存在局限，如忽略组织形态信息，或受数据复杂性影响效果不稳定。</li><li>传统方法难以选择最佳的检测方法，因此需要集成学习（ensemble learning）策略来整合多种方法的结果。</li></ul><h4 id="2-研究目标"><a class="anchor" href="#2-研究目标">#</a> <strong>2. 研究目标</strong></h4><ul><li>提出 <strong>EnSDD (Ensemble-learning for Spatial Domain Detection)</strong>，整合 8 种先进的空间域检测方法，并使用 <strong>动态加权机制</strong> 来优化每种方法的贡献。</li><li>该方法可 <strong>自动评估各方法的性能</strong>，无需依赖人工标注（ground truth）。</li><li>EnSDD 还能够识别 <strong>特定空间域的差异表达基因（SVGs）</strong> 和 <strong>细胞类型空间分布</strong>，提供更深层次的组织异质性见解。</li></ul><h4 id="3-方法创新"><a class="anchor" href="#3-方法创新">#</a> <strong>3. 方法创新</strong></h4><ul><li><strong>动态加权机制</strong>：EnSDD 通过优化模型自适应地分配各基方法的权重，并生成一个 <strong>共识相似度矩阵（consensus similarity matrix）</strong>。</li><li><strong>自动调整聚类参数</strong>：采用 Louvain 算法的自适应分辨率调整策略，确保聚类结果的优化。</li><li><strong>集成 8 种方法</strong>：包括 <strong>BayesSpace、DR-SC、GraphST、STAGATE、SpaGCN、stLearn、SiGra 和 spaVAE</strong>，结合空间坐标、基因表达数据和组织形态图像进行聚类分析。</li></ul><h4 id="4-主要实验与结果"><a class="anchor" href="#4-主要实验与结果">#</a> <strong>4. 主要实验与结果</strong></h4><h5 id="1-在人类大脑-dlpfc-数据集上的表现"><a class="anchor" href="#1-在人类大脑-dlpfc-数据集上的表现">#</a> <strong>(1) 在人类大脑 DLPFC 数据集上的表现</strong></h5><ul><li>EnSDD 在 12 个人类 DLPFC（前额叶皮层）切片上进行测试，结果显示：<ul><li><strong>在大多数切片上表现最佳</strong>，准确划分了不同皮层层次。</li><li>以 <strong>调整兰德指数（ARI）= 0.637</strong> 和 <strong>纯度（Purity）= 0.753</strong> 在部分切片中取得最高聚类准确度。</li><li>与人工标注相比，部分区域的划分更细（如 Layer 3 进一步被细分），表明 EnSDD 具有较强的发现新结构的能力。</li></ul></li></ul><h5 id="2-在小鼠大脑数据集上的验证"><a class="anchor" href="#2-在小鼠大脑数据集上的验证">#</a> <strong>(2) 在小鼠大脑数据集上的验证</strong></h5><ul><li>采用 <strong>Allen Brain Atlas</strong> 作为参考标准，EnSDD 成功识别出 <strong>大脑皮层 6 层结构、海马 CA1 结构、齿状回（DG）</strong> 等重要区域。</li><li><strong>相比其他方法更稳定</strong>，即使调整聚类数量，EnSDD 仍能保持空间域的连贯性，而其他方法如 BayesSpace、stLearn 在某些情况下生成不连续的区域。</li></ul><h5 id="3-在癌症组织乳腺癌-前列腺癌和卵巢癌上的应用"><a class="anchor" href="#3-在癌症组织乳腺癌-前列腺癌和卵巢癌上的应用">#</a> <strong>(3) 在癌症组织（乳腺癌、前列腺癌和卵巢癌）上的应用</strong></h5><ul><li><p><strong>乳腺癌</strong>：</p><ul><li>EnSDD 识别出不同的 <strong>肿瘤区域（IDC、DCIS/LCIS）</strong> 及肿瘤边缘的细微异质性。</li><li>通过差异基因分析，发现了 <strong>IDC_5 区域的关键基因（如 CSTA、FAM234B、HEBP1）</strong>，揭示了潜在的肿瘤进展机制。</li><li><strong>肿瘤微环境分析</strong> 显示，IDC 5 区域的 <strong>巨噬细胞和树突状细胞</strong> 含量较高，可能与肿瘤免疫逃逸相关。</li></ul></li><li><p><strong>前列腺癌</strong>：</p><ul><li>成功识别 <strong>肿瘤区域</strong> 和 <strong>肿瘤边界（ecotone）</strong>，相比其他方法，EnSDD 更精确地区分了肿瘤与周围组织的异质性。</li><li>发现 <strong>KLK3、TP63、ATG9B</strong> 等基因在肿瘤边缘具有显著表达变化，可能影响前列腺癌的进展。</li></ul></li><li><p><strong>卵巢癌</strong>：</p><ul><li>EnSDD 成功检测到 <strong>肿瘤 - 基质交界区（tumor-stroma interface）</strong>，揭示了肿瘤微环境的复杂性。</li><li>识别的关键基因 <strong>SFRP4、IGKN、THBS1</strong> 可能与肿瘤侵袭能力相关，提示 EnSDD 可用于肿瘤生物标志物的发现。</li></ul></li></ul><h4 id="5-贡献与未来展望"><a class="anchor" href="#5-贡献与未来展望">#</a> <strong>5. 贡献与未来展望</strong></h4><ul><li>EnSDD <strong>比单一方法更稳定</strong>，可自动评估不同方法的贡献，适用于 <strong>不同类型的组织结构</strong>。</li><li>未来可扩展至 <strong>多切片分析（multi-slice analysis）</strong>，探索组织在多个切片间的连续性。</li><li><strong>结合外部参考数据</strong> 可能进一步提升 EnSDD 在未知数据集上的适用性。</li></ul><hr><h3 id="总结"><a class="anchor" href="#总结">#</a> <strong>总结</strong></h3><p>这篇论文提出了一种 <strong>基于集成学习的空间域检测方法 EnSDD</strong>，在多个数据集上表现优异，能更准确地识别 <strong>空间域结构、差异基因和细胞类型分布</strong>，并适用于 <strong>复杂组织结构及肿瘤微环境研究</strong>，为空间转录组学分析提供了新的工具。</p></div></details><h2 id="two-main-challenges"><a class="anchor" href="#two-main-challenges">#</a> two main challenges:</h2><ul><li>differing base methods may produce varying numbers and types of spatial doamins, complicating the integration of their results</li><li>the performance of methods can vary across datasets, making it difficult to automatically assess and incorporate method performance into the ensemble process.</li></ul><h2 id="ensddensemble-learning-for-spatial-domain-detection-offers-several-advantages"><a class="anchor" href="#ensddensemble-learning-for-spatial-domain-detection-offers-several-advantages">#</a> EnSDD(Ensemble-learning for Spatial Domain Detection) offers several advantages:</h2><ul><li>EnSDD adaptively assigns weights to similarity matrices generated by base methods, learning the complete similarity between spots</li><li>the weights assigned by EnSDD provide a reliable metric for evaluating the performance of base SDD methods without requiring ground truth.</li><li>EnSDD offers a comprehensive framework for exploring tissue spatial organization, including the identification of spatial domains, determination of domain-specific SVGs, and inference of cell type distribution</li><li>it includes well-documented tutorials and an interative platform to facilitate implementation and visualization.</li></ul><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/EnSDD1.png" alt=""></p><p>大概概括一下整个流程：<br>首先将各种各样的数据输入进模型，这个模型下的 8 个 base methods 会生成结果，然后右图的那个代表 0，1 的矩阵的意思是两个 spot 之间是否属于一个 cluster，通过使用这些矩阵，EnSDD 会运用一个优化模型去决定最终的 similarity matrix，并且把可自适应的权重分给 base method，然后这些权重便成为了衡量 base method 的方式。最终 EnSDD 运用 Louvain 算法去最终决定 spatial domains。</p><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/EnSDD2.png" alt=""></p><p>EnSDD offers two approaches for identifying SVGs:</p><ul><li>one involves detecting domain-specific differentially expressed genes(DEGs)</li><li>other identifies gene with expression patterns with expression patterns correlated to spatial locations</li></ul><p><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/EnSDD3.png" alt=""><br><img data-src="https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/EnSDD4.png" alt=""></p><blockquote><p>在科研中，gold standard 指的是被广泛接受、被认为是最准确和权威的 “真值” 或参考数据，通常由专家通过严格的人工注释获得。例如，在前列腺癌数据中，病理学家提供的肿瘤和肿瘤边缘区域标注就被视为 gold standard，用来评估算法的准确性。而 silver standard 则是指在没有绝对完美的 gold standard 时使用的参考数据，这类数据虽然不是最完美的，但仍能作为一个有用的基准来评价方法的表现。例如，在某些小鼠大脑数据中，Allen Brain Atlas 被用作 silver standard。总体来说，gold standard 是最理想的标准，而 silver standard 则是在实际条件下的一个次优但可接受的替代。</p></blockquote><p>针对乳腺癌数据板块的对于 cell proportion 的分析可以借鉴一下</p><details class="danger"><summary>其它的集成学习方法</summary><div><p>STAMarker 和 SC3 都是利用集成学习思想的聚类方法，但它们应用的场景和侧重点有所不同：</p><ul><li><p><strong>SC3</strong> 是一种用于单细胞 RNA 测序（scRNA-seq）数据聚类的方法。它通过整合多个聚类结果得到多个二元相似度矩阵，然后利用层次聚类生成最终的细胞分类结果。这种方法能够整合不同算法的信息，从而获得更稳健的聚类结果。</p></li><li><p><strong>STAMarker</strong> 则主要用于空间转录组学数据中的空间域检测。它计算不同聚类结果中任意两个空间点共同归入同一空间域的比例，形成一个连接矩阵，再利用层次聚类或 Louvain 算法来进行标签分配，从而识别出具有生物学意义的空间域。</p></li></ul><p>这两种方法都是通过集成多种聚类结果来提高整体的准确性和稳健性，但 SC3 更侧重于单细胞数据的细胞分类，而 STAMarker 则专注于空间域的划分。</p></div></details><h2 id="methods部分"><a class="anchor" href="#methods部分">#</a> Methods 部分</h2><p>在 Methods 部分，作者主要介绍了 EnSDD 模型的构建和求解方法，其中核心在于如何将来自多个基础空间域检测方法（如 BayesSpace、DR-SC、GraphST、STAGATE、SpaGCN、stLearn、SiGra 和 spaVAE）得到的二值相似矩阵进行加权融合，进而生成一个共识相似矩阵 S，从而指导后续的空间域划分。下面详细说明公式部分的主要内容：</p><hr><h3 id="1-二值相似矩阵构造"><a class="anchor" href="#1-二值相似矩阵构造">#</a> 1. 二值相似矩阵构造</h3><p>对于每个基础方法 m（m = 1, …, M，默认 M = 8），根据其聚类结果构造一个二值相似矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">S^{(m)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8879999999999999em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8879999999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>。具体来说，对于任意两个点 i 和 j，如果它们在方法 m 中被划分到同一聚类，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">S^{(m)}(i, j) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8879999999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>；否则为 0。这一步的目的在于将各方法的聚类结果以矩阵的形式表达出来。</p><hr><h3 id="2-优化模型与加权融合公式"><a class="anchor" href="#2-优化模型与加权融合公式">#</a> 2. 优化模型与加权融合公式</h3><p>为了整合这些基础方法得到的相似矩阵，作者提出了如下优化问题：</p>\begin{align} \min_{S, \{\omega_m\}} \quad \sum_{m=1}^{M} \omega_m \|S - S^{(m)}\|_F^2 + \lambda \sum_{m=1}^{M} \omega_m \log \omega_m \end{align} \begin{align} \text{subject to} \quad \sum_{m=1}^{M} \omega_m = 1, \quad \omega_m \geq 0 \quad (m=1,\ldots,M) \end{align}<p>其中：</p><ul><li><strong>S</strong> 是待学习的共识相似矩阵。</li><li><strong>S^(m)</strong> 是第 m 个基础方法构造的二值相似矩阵。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mo>⋅</mo><msubsup><mi mathvariant="normal">∥</mi><mi>F</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\|\cdot\|_F^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∥</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.089439em;vertical-align:-.275331em"></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-2.424669em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">F</span></span></span><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.275331em"><span></span></span></span></span></span></span></span></span></span></strong> 表示矩阵的 Frobenius 范数的平方，即衡量两个矩阵之间的欧氏距离。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong> 是分配给第 m 个基础方法的权重，这些权重反映了每个方法在当前数据集上的表现好坏。直观上，表现较好的方法会获得较大的权重，使得共识矩阵 S 与该方法的 S^(m) 更加接近。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">λ</span></span></span></span></strong> 是调节负熵正则化项的参数。正则化项 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><msubsup><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><msub><mi>ω</mi><mi>m</mi></msub><mi>log</mi><mo>⁡</mo><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\lambda \sum_{m=1}^{M} \omega_m \log \omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2809409999999999em;vertical-align:-.29971000000000003em"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.981231em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.29971000000000003em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的引入能够防止权重过于集中在某一个方法上，从而避免过拟合。</li></ul><p><strong>公式解析：</strong></p><ul><li><p><strong>第一项：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><msub><mi>ω</mi><mi>m</mi></msub><mi mathvariant="normal">∥</mi><mi>S</mi><mo>−</mo><msup><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></msup><msubsup><mi mathvariant="normal">∥</mi><mi>F</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sum_{m=1}^{M} \omega_m \|S - S^{(m)}\|_F^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2809409999999999em;vertical-align:-.29971000000000003em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.981231em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.29971000000000003em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord">∥</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.163331em;vertical-align:-.275331em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8879999999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-2.424669em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">F</span></span></span><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.275331em"><span></span></span></span></span></span></span></span></span></span></strong><br>这部分计算了共识矩阵 S 与每个基础方法的相似矩阵之间的加权差异。对每个方法 m，距离越小表明 S 更接近于该方法的结果，且这个距离由相应的权重 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 加权求和。</p></li><li><p><strong>第二项：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><msubsup><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><msub><mi>ω</mi><mi>m</mi></msub><mi>log</mi><mo>⁡</mo><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\lambda \sum_{m=1}^{M} \omega_m \log \omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2809409999999999em;vertical-align:-.29971000000000003em"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.981231em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.29971000000000003em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong><br>这是一个负熵正则化项，它在优化过程中会鼓励权重分布更加平滑，防止某个方法的权重过大。这里的 λ 控制了正则化的强度，当 λ 较大时，权重分布会更加均衡；当 λ 较小时，可能会倾向于将大部分权重赋予表现最好的方法。</p></li><li><p><strong>约束条件：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><msub><mi>ω</mi><mi>m</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{m=1}^{M} \omega_m = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2809409999999999em;vertical-align:-.29971000000000003em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.981231em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.29971000000000003em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\omega_m \geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7859700000000001em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span></strong><br>这保证了所有权重构成一个概率分布，即所有权重之和为 1，并且每个权重都是非负的。</p></li></ul><p>作者采用坐标下降算法来求解这个优化问题，即交替优化 S 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的值。最终得到的共识相似矩阵 S 能够更准确地反映各基础方法综合后的空间点相似性，同时各 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 也可作为评估各基础方法在特定数据集上表现的指标。</p><hr><details class="danger"><summary>第一项偏导</summary><div><p>这是一个经典的<strong>带权 Frobenius 距离最小化问题</strong>，常出现在集成学习、矩阵逼近或多视图聚类中。你问的是下面这个优化目标：</p><hr><h3 id="优化问题"><a class="anchor" href="#优化问题">#</a> 📌 优化问题</h3>\begin{equation} \min_{S, \{\omega_m\}} \quad \sum_{m=1}^{M} \omega_m \|S - S^{(m)}\|_F^2 \end{equation}<p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 是你要求解的<strong>集成矩阵</strong></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 是每个 base 矩阵的权重（你暂时是常数或已知的情况下求偏导）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">S^{(m)} \in \mathbb{R}^{n \times n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.9270999999999999em;vertical-align:-.0391em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8879999999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.771331em;vertical-align:0"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.771331em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> 是第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 个给定的相似度矩阵</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mo>⋅</mo><msub><mi mathvariant="normal">∥</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">\| \cdot \|_F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∥</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 表示 Frobenius 范数</li></ul><hr><h3 id="要求"><a class="anchor" href="#要求">#</a> 🎯 要求：</h3><p>你现在是想<strong>对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 求偏导数</strong>，也就是：</p>\begin{equation} \frac{\partial}{\partial S} \left( \sum_{m=1}^{M} \omega_m \|S - S^{(m)}\|_F^2 \right) \end{equation}<hr><h3 id="计算步骤"><a class="anchor" href="#计算步骤">#</a> 🧮 计算步骤</h3><p>我们知道：</p>\begin{equation} \|A\|_F^2 = \sum_{i,j} A_{ij}^2 = \operatorname{Tr}(A^\top A) \end{equation}<p>所以每一项：</p>\begin{equation} \|S - S^{(m)}\|_F^2 = \operatorname{Tr}\left((S - S^{(m)})^\top (S - S^{(m)})\right) \end{equation}<p>对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 求导的标准结果是：</p>\begin{equation} \frac{\partial}{\partial S} \|S - S^{(m)}\|_F^2 = 2(S - S^{(m)}) \end{equation}<hr><h3 id="于是整体偏导为"><a class="anchor" href="#于是整体偏导为">#</a> 🧾 于是整体偏导为：</h3>\begin{equation} \frac{\partial}{\partial S} \sum_{m=1}^{M} \omega_m \|S - S^{(m)}\|_F^2 = \sum_{m=1}^{M} \omega_m \cdot 2(S - S^{(m)}) = 2 \sum_{m=1}^{M} \omega_m (S - S^{(m)}) \end{equation}<hr><h3 id="最终结果"><a class="anchor" href="#最终结果">#</a> ✅ 最终结果：</h3>\begin{equation} \frac{\partial}{\partial S} \left( \sum_{m=1}^{M} \omega_m \|S - S^{(m)}\|_F^2 \right) = 2 \sum_{m=1}^{M} \omega_m (S - S^{(m)}) \end{equation}<hr><h3 id="如果你要最小化它只需让偏导为-0"><a class="anchor" href="#如果你要最小化它只需让偏导为-0">#</a> 💡 如果你要最小化它，只需让偏导为 0：</h3>\begin{equation} \sum_{m=1}^{M} \omega_m (S - S^{(m)}) = 0 \quad \Rightarrow \quad S = \sum_{m=1}^{M} \omega_m S^{(m)} \end{equation}<p>也就是说，<strong>最优解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span></strong> 是所有矩阵的 <strong>加权平均</strong>！</p><hr><p>需要我帮你把这推导写成 LaTeX 公式或加到你自己的代码推导里也可以继续说哈～</p></div></details><details class="danger"><summary>第二项偏导</summary><div><p>太好了！你这个问题非常经典，咱们现在就来一步步推导怎么用 <strong>Lagrange 乘子法</strong>（Lagrange multipliers）来求解权重 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的最优解。</p><hr><h2 id="你给的目标函数是"><a class="anchor" href="#你给的目标函数是">#</a> 🔢 你给的目标函数是：</h2>\begin{equation} \min_{\{ \omega_m \}} \quad \sum_{m=1}^M \omega_m \| S - S^{(m)} \|_F^2 + \lambda \sum_{m=1}^M \omega_m \log \omega_m \end{equation}<p>带有约束：</p>\begin{equation} \sum_{m=1}^M \omega_m = 1, \quad \omega_m \geq 0 \end{equation}<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 是固定的（或者在交替优化里暂时固定），所以我们只针对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 来优化。</p><hr><h2 id="️-第一步写出-lagrangian-拉格朗日函数"><a class="anchor" href="#️-第一步写出-lagrangian-拉格朗日函数">#</a> ✏️ 第一步：写出 Lagrangian 拉格朗日函数</h2><p>为了处理约束 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msub><mi>ω</mi><mi>m</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum \omega_m = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-.25001em"></span><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>，引入拉格朗日乘子 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">μ</span></span></span></span>，构造：</p>\begin{equation} \mathcal{L}(\omega_1, \ldots, \omega_M, \mu) = \sum_{m=1}^M \omega_m \| S - S^{(m)} \|_F^2 + \lambda \sum_{m=1}^M \omega_m \log \omega_m - \mu \left( \sum_{m=1}^M \omega_m - 1 \right) \end{equation}<hr><h2 id="第二步对每个-omega_m-求偏导数"><a class="anchor" href="#第二步对每个-omega_m-求偏导数">#</a> 🧮 第二步：对每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 求偏导数</h2><p>我们令每个偏导为 0：</p>\begin{equation} \frac{\partial \mathcal{L}}{\partial \omega_m} = \| S - S^{(m)} \|_F^2 + \lambda(1 + \log \omega_m) - \mu = 0 \end{equation}<p>整理一下：</p>\begin{equation} \lambda \log \omega_m = \mu - \lambda - \| S - S^{(m)} \|_F^2 \end{equation}<p>再除以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">λ</span></span></span></span> 并指数两边：</p>\begin{equation} \log \omega_m = \frac{\mu - \lambda - \| S - S^{(m)} \|_F^2}{\lambda} \Rightarrow \omega_m = \exp\left( \frac{\mu - \lambda - \| S - S^{(m)} \|_F^2}{\lambda} \right) \end{equation}<p>整理一下：</p>\begin{equation} \omega_m = C \cdot \exp\left( -\frac{1}{\lambda} \| S - S^{(m)} \|_F^2 \right) \end{equation}<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mrow><mi>μ</mi><mo>−</mo><mi>λ</mi></mrow><mi>λ</mi></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">C = \exp\left( \frac{\mu - \lambda}{\lambda} \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.80002em;vertical-align:-.65002em"></span><span class="mop">exp</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.9322159999999999em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">λ</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.446108em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">μ</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">λ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size2">)</span></span></span></span></span></span> 是一个<strong>所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的共同常数</strong>。</p><hr><h2 id="第三步用约束条件求出-c"><a class="anchor" href="#第三步用约束条件求出-c">#</a> ✅ 第三步：用约束条件求出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.07153em">C</span></span></span></span></h2><p>由于所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 要满足：</p>\begin{equation} \sum_{m=1}^M \omega_m = 1 \end{equation}<p>我们将上面形式代入得：</p>\begin{equation} \sum_{m=1}^M C \cdot \exp\left( -\frac{1}{\lambda} \| S - S^{(m)} \|_F^2 \right) = 1 \Rightarrow C = \frac{1}{\sum_{m=1}^M \exp\left( -\frac{1}{\lambda} \| S - S^{(m)} \|_F^2 \right)} \end{equation}<hr><h2 id="最终结果-2"><a class="anchor" href="#最终结果-2">#</a> 🎉 最终结果：</h2>\begin{equation} \boxed{ \omega_m = \frac{ \exp\left( -\frac{1}{\lambda} \| S - S^{(m)} \|_F^2 \right) }{ \sum_{j=1}^M \exp\left( -\frac{1}{\lambda} \| S - S^{(j)} \|_F^2 \right) } } \end{equation}<p>这其实就是一个 <strong>softmax</strong> 形式！每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 是对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">S^{(m)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8879999999999999em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8879999999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 的一个相似度评分（用负的距离衡量），用 softmax 来归一化。</p><hr><h2 id="补充说明"><a class="anchor" href="#补充说明">#</a> 📌 补充说明</h2><ul><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda \to 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span>：权重趋向于 “winner takes all”（只选最小误差的那个）</li><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\lambda \to \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord">∞</span></span></span></span>：所有权重接近均匀平均</li><li>这个方法就是你之前代码中那个权重更新公式的数学基础</li></ul><hr><p>如果你想我也可以帮你推对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 的梯度，或者画图解释这个 softmax 权重的直觉含义 😄 想继续哪一块？</p><p>当然可以！我们就专注于这一步：<strong>如何对每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 求偏导数</strong>。</p><p>你给的函数是：</p>\begin{equation} \mathcal{L}(\omega_1, \ldots, \omega_M, \mu) = \sum_{m=1}^M \omega_m \|S - S^{(m)}\|_F^2 + \lambda \sum_{m=1}^M \omega_m \log \omega_m - \mu \left( \sum_{m=1}^M \omega_m - 1 \right) \end{equation}<p>我们现在只关注其中一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，要对它<strong>求偏导数</strong>。</p><hr><h2 id="拆开看mathcall-对于单个-omega_m-是"><a class="anchor" href="#拆开看mathcall-对于单个-omega_m-是">#</a> 🔍 拆开看，(\mathcal {L}) 对于单个 (\omega_m) 是：</h2><p>选定一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span>，(\mathcal {L}$ 中关于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的部分是：</p>\begin{equation} \omega_m \|S - S^{(m)}\|_F^2 + \lambda \omega_m \log \omega_m - \mu \omega_m \end{equation}<p>这是三项：</p><ol><li>线性项：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub><mi mathvariant="normal">∥</mi><mi>S</mi><mo>−</mo><msup><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></msup><msubsup><mi mathvariant="normal">∥</mi><mi>F</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\omega_m \|S - S^{(m)}\|_F^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord">∥</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.163331em;vertical-align:-.275331em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8879999999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-2.424669em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">F</span></span></span><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.275331em"><span></span></span></span></span></span></span></span></span></span></li><li>熵正则项：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><msub><mi>ω</mi><mi>m</mi></msub><mi>log</mi><mo>⁡</mo><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\lambda \omega_m \log \omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></li><li>约束乘子项：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>μ</mi><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">-\mu \omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7777700000000001em;vertical-align:-.19444em"></span><span class="mord">−</span><span class="mord mathnormal">μ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></li></ol><hr><h2 id="逐项对-omega_m-求导"><a class="anchor" href="#逐项对-omega_m-求导">#</a> 🧮 逐项对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 求导</h2><h3 id="第一项"><a class="anchor" href="#第一项">#</a> 第一项：</h3>\begin{equation} \frac{\partial}{\partial \omega_m} \left( \omega_m \cdot \|S - S^{(m)}\|_F^2 \right) = \|S - S^{(m)}\|_F^2 \end{equation}<p>这是因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mi>S</mi><mo>−</mo><msup><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></msup><msubsup><mi mathvariant="normal">∥</mi><mi>F</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\|S - S^{(m)}\|_F^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∥</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.163331em;vertical-align:-.275331em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8879999999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-2.424669em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">F</span></span></span><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.275331em"><span></span></span></span></span></span></span></span></span></span> 是常数，对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\omega_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 直接是乘法。</p><hr><h3 id="第二项关键点"><a class="anchor" href="#第二项关键点">#</a> 第二项（关键点）：</h3>\begin{equation} \frac{\partial}{\partial \omega_m} \left( \omega_m \log \omega_m \right) \end{equation}<p>我们来慢慢推一下这个常见表达式的导数：</p><p>令：</p>\begin{equation} f(\omega) = \omega \log \omega \end{equation}<p>用乘积法则：</p>\begin{equation} f'(\omega) = \frac{d}{d\omega} \omega \cdot \log \omega = 1 \cdot \log \omega + \omega \cdot \frac{1}{\omega} = \log \omega + 1 \end{equation}<p>所以：</p>\begin{equation} \frac{\partial}{\partial \omega_m} \left( \lambda \omega_m \log \omega_m \right) = \lambda (\log \omega_m + 1) \end{equation}<hr><h3 id="第三项"><a class="anchor" href="#第三项">#</a> 第三项：</h3>\begin{equation} \frac{\partial}{\partial \omega_m} (-\mu \omega_m) = -\mu \end{equation}<hr><h2 id="把三项加起来得到偏导"><a class="anchor" href="#把三项加起来得到偏导">#</a> 🔚 把三项加起来，得到偏导：</h2>\begin{equation} \frac{\partial \mathcal{L}}{\partial \omega_m} = \|S - S^{(m)}\|_F^2 + \lambda (\log \omega_m + 1) - \mu \end{equation}<p>然后我们令偏导为 0，得到最优条件：</p>\begin{equation} \|S - S^{(m)}\|_F^2 + \lambda (\log \omega_m + 1) - \mu = 0 \end{equation}<p>就是我们之前推导的式子啦！</p><hr><h2 id="总结一下你学到什么"><a class="anchor" href="#总结一下你学到什么">#</a> 🎯 总结一下你学到什么：</h2><ul><li>对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mi>log</mi><mo>⁡</mo><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega \log \omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">ω</span></span></span></span> 求导是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>ω</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\log \omega + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">ω</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>（这是熵类正则常见的导数）</li><li>在加权平均里用 softmax，其实就是从这个偏导数出发</li><li>拉格朗日乘子 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">μ</span></span></span></span> 用于处理总和为 1 的约束</li></ul><hr><p>如果你想，我还可以做成一张「可视化推导卡片」，更方便你日后复习！要不要试试？</p></div></details><h3 id="3-空间域的划分"><a class="anchor" href="#3-空间域的划分">#</a> 3. 空间域的划分</h3><p>得到共识相似矩阵 S 后，EnSDD 进一步使用 Louvain 算法进行社区发现（即聚类），并通过自适应分辨率调整（利用二分搜索确定最佳分辨率参数），将 SRT 数据中的点划分为不同的空间域。这样既能保证空间域的连贯性，也能在预设的聚类数下获得较优的划分结果。</p><hr><h3 id="4-后续分析"><a class="anchor" href="#4-后续分析">#</a> 4. 后续分析</h3><p>在共识相似矩阵和空间域划分的基础上，EnSDD 还进一步进行：</p><ul><li><strong>差异表达基因（SVGs）的识别</strong>：利用 Wilcoxon 检验比较各空间域之间的基因表达水平，识别出在特定空间域中具有显著表达变化的基因。</li><li><strong>局部空间自相关分析</strong>：采用 Local Getis and Ord’s Gi 统计量，评估基因表达在局部空间内的聚集或分散趋势，从而揭示基因的空间自相关特征。</li></ul><details class="danger"><summary>SA</summary><div><h3 id="空间自相关spatial-auto-correlation-sa的使用"><a class="anchor" href="#空间自相关spatial-auto-correlation-sa的使用">#</a> <strong>空间自相关（Spatial Auto-correlation, SA）的使用</strong></h3><p>在 EnSDD 研究中，空间自相关用于分析 <strong>基因表达在空间上的依赖性</strong>，即在组织切片中，基因的表达水平是否在空间上呈现聚集或分散模式。这有助于识别 <strong>空间可变基因（SVGs, Spatially Variable Genes）</strong>，即在特定空间区域内具有特定表达模式的基因。</p><hr><h2 id="1-什么是空间自相关"><a class="anchor" href="#1-什么是空间自相关">#</a> <strong>1. 什么是空间自相关？</strong></h2><p>空间自相关（SA）是指某一变量（这里是基因表达水平）在空间上的分布模式是否表现出 <strong>相似性或相关性</strong>。一般来说：</p><ul><li><strong>正空间自相关（Positive SA）</strong>：相邻位置的基因表达水平相似，呈现聚集模式。例如，在大脑皮层某个区域，如果某个基因的表达量高，其周围位置的表达量也较高。</li><li><strong>负空间自相关（Negative SA）</strong>：相邻位置的基因表达水平相反，呈现分散模式。例如，某些基因在神经组织和周围支持细胞中表现出相反的表达模式。</li></ul><p>EnSDD 采用 <strong>Local Getis and Ord’s Gi 统计量</strong> 来定量衡量某个基因在局部空间中的自相关性。</p><hr><h2 id="2-local-getis-and-ords-g_i-统计量"><a class="anchor" href="#2-local-getis-and-ords-g_i-统计量">#</a> <strong>2. Local Getis and Ord’s <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 统计量</strong></h2><p>EnSDD 通过 <strong>Local Getis and Ord’s <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong> 统计量来评估基因表达的空间聚集性。这一统计量用于衡量每个基因在空间中的局部自相关性，数学表达如下：</p>\begin{align} G_i(k) = \frac{\sum\limits_{j} c_{ij}(k) x_j - V_i \mu}{\sigma \left\{(n-1)B_{1i} - V_i^2\right\}^{1/2}}, \quad i \neq j \end{align}<p>其中：</p><ul><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.716668em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span></strong>：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span> 个空间点的基因表达水平。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">μ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">σ</span></span></span></span></strong>：所有空间点（去除第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 个点）的基因表达的均值和标准差。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c_{ij}(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span></strong>：空间权重矩阵，表示空间点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span> 之间的距离权重（例如，最近的 k 个点的权重为 1，其余为 0）。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mo>=</mo><msub><mo>∑</mo><mi>j</mi></msub><msub><mi>c</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_i = \sum_j c_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-.43581800000000004em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.16195399999999993em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.43581800000000004em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span></strong>：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 个点的总空间权重。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mn>1</mn><mi>i</mi></mrow></msub><mo>=</mo><msub><mo>∑</mo><mi>j</mi></msub><msubsup><mi>c</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">B_{1i} = \sum_j c_{ij}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.2499259999999999em;vertical-align:-.43581800000000004em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.16195399999999993em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.43581800000000004em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-2.441336em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.394772em"><span></span></span></span></span></span></span></span></span></span></strong>：空间权重的平方和。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span></strong>：所有空间点的总数。</li></ul><p><strong>解释：</strong></p><ul><li>如果 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong> 值 <strong>大于 0</strong>，表示该基因的高表达区域在局部空间中聚集（正空间自相关）。</li><li>如果 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong> 值 <strong>小于 0</strong>，表示该基因在该区域的表达呈现离散模式（负空间自相关）。</li></ul><p>EnSDD 采用 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">k = 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span></span></span></span></strong> 作为最近邻窗口大小，计算基因在每个空间点上的 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong> 统计量，并使用 <strong>Wilcoxon 检验</strong> 进一步确认哪些基因在特定空间域上表现出显著的空间可变性。</p><hr><h2 id="3-sa-在-ensdd-中的应用"><a class="anchor" href="#3-sa-在-ensdd-中的应用">#</a> <strong>3. SA 在 EnSDD 中的应用</strong></h2><p>EnSDD 主要利用 <strong>Local Getis and Ord’s <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong> 统计量来：</p><ol><li><strong>筛选空间可变基因（SVGs）</strong>：识别在不同空间域（Spatial Domain）中表达模式具有明显局部聚集或分散特征的基因。</li><li><strong>分析组织结构中的基因表达模式</strong>：<ul><li>例如，在 <strong>人类 DLPFC（前额叶皮层）数据</strong> 中，EnSDD 发现 <strong>Layer 3 被进一步细分</strong>，并通过 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong> 统计量证实该区域内确实存在两个不同的基因表达聚集区域。</li><li>在 <strong>乳腺癌数据</strong> 中，利用 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong> 统计量找到了一些 <strong>与癌症进展相关的特异性基因（如 HEBP1、FAM234B、CSTA）</strong>，它们在某些肿瘤区域内高度聚集。</li></ul></li></ol><hr><h2 id="4-具体实现"><a class="anchor" href="#4-具体实现">#</a> <strong>4. 具体实现</strong></h2><h3 id="步骤-1计算局部空间自相关"><a class="anchor" href="#步骤-1计算局部空间自相关">#</a> <strong>步骤 1：计算局部空间自相关</strong></h3><p>对于每个基因：</p><ol><li>构建 <strong>空间权重矩阵</strong>，选取最近的 <strong>6 个相邻点</strong> 作为参考。</li><li>计算 <strong>每个点的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 统计量</strong>，得到基因的局部空间聚集度信息。</li></ol><h3 id="步骤-2wilcoxon-检验"><a class="anchor" href="#步骤-2wilcoxon-检验">#</a> <strong>步骤 2：Wilcoxon 检验</strong></h3><p>对比不同空间域之间的基因表达水平，检验在某个空间域中是否存在显著表达变化的基因。</p><h3 id="步骤-3可视化和分析"><a class="anchor" href="#步骤-3可视化和分析">#</a> <strong>步骤 3：可视化和分析</strong></h3><ul><li><strong>局部空间自相关（SA）热图</strong>：展示不同基因在不同空间点上的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 值，识别高表达聚集区域。</li><li><strong>空间表达模式图</strong>：在组织切片上可视化基因的表达水平，观察其空间分布。</li></ul><hr><h2 id="5-实例解析"><a class="anchor" href="#5-实例解析">#</a> <strong>5. 实例解析</strong></h2><h3 id="案例-1人类前额叶皮层dlpfc"><a class="anchor" href="#案例-1人类前额叶皮层dlpfc">#</a> <strong>案例 1：人类前额叶皮层（DLPFC）</strong></h3><p>在 DLPFC 数据集中，EnSDD 发现：</p><ul><li>在某些切片中，<strong>Layer 3 被自动分成两个子区域</strong>。</li><li>通过 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong> 统计量计算，发现 <strong>129 个基因在这两个子区域的表达显著不同</strong>。</li><li>进一步分析发现这些基因 <strong>与神经功能和甲状腺癌相关</strong>，揭示了 Layer 3 内部可能存在未被人工标注的异质性。</li></ul><h3 id="案例-2乳腺癌肿瘤区域"><a class="anchor" href="#案例-2乳腺癌肿瘤区域">#</a> <strong>案例 2：乳腺癌肿瘤区域</strong></h3><ul><li>EnSDD 识别了 <strong>肿瘤中心区域（IDC_5）</strong> 和 <strong>周围免疫浸润区域</strong>，并通过 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong> 统计量找到了一组特异性基因：<ul><li><strong>在 IDC_5 高表达的基因</strong>：HEBP1（与乳腺癌进展相关）</li><li><strong>在肿瘤边界高表达的基因</strong>：FAM234B（与肿瘤免疫浸润相关）</li></ul></li></ul><p>这些基因的空间表达模式揭示了 <strong>不同肿瘤区域的分子特征和潜在生物学机制</strong>，并可能成为新的肿瘤治疗靶点。</p><hr><h2 id="6-总结"><a class="anchor" href="#6-总结">#</a> <strong>6. 总结</strong></h2><ul><li><strong>空间自相关（SA）是 EnSDD 识别空间可变基因（SVGs）的关键步骤</strong>。</li><li><strong>Local Getis and Ord’s <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong> 统计量用于衡量基因在局部空间的聚集或分散模式。</li><li>通过 SA 分析，EnSDD 发现了新的 <strong>组织异质性</strong>，并揭示了 <strong>肿瘤微环境</strong> 中的关键分子特征。</li><li>该方法在 <strong>人类大脑 DLPFC、小鼠大脑、乳腺癌、前列腺癌和卵巢癌</strong> 数据中均表现良好，能够有效提升空间转录组数据的生物学解释能力。</li></ul><p>如果你对实现细节或代码感兴趣，可以让我帮你进一步解析如何在 Python 或 R 中实现 Local Getis and Ord’s <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 统计量计算！🚀</p></div></details><details class="danger"><summary>RCTD</summary><div><h3 id="rctdrobust-cell-type-decomposition"><a class="anchor" href="#rctdrobust-cell-type-decomposition">#</a> <strong>RCTD（Robust Cell Type Decomposition）</strong></h3><p>在 EnSDD 研究中，<strong>RCTD（Robust Cell Type Decomposition）</strong> 主要用于 <strong>推测空间转录组数据（SRT）中的细胞类型组成</strong>，即利用 <strong>单细胞转录组测序（scRNA-seq）数据</strong> 作为参考，对空间转录组数据中的每个 spot 进行 <strong>细胞类型分解（deconvolution）</strong>。</p><hr><h2 id="1-什么是-rctd"><a class="anchor" href="#1-什么是-rctd">#</a> <strong>1. 什么是 RCTD？</strong></h2><p><strong>RCTD</strong> 是一种 <strong>基于权重优化的去卷积方法</strong>，用于从空间转录组数据中估计每个 spot（空间点）中 <strong>不同细胞类型的组成比例</strong>。</p><p>在空间转录组数据（SRT）中，每个 spot 包含多个细胞的混合信号，而单细胞 RNA 测序（scRNA-seq）数据可以提供 <strong>单细胞级别的基因表达信息</strong>。RCTD 通过匹配 SRT 和 scRNA-seq 数据，<strong>估算每个 spot 内不同细胞类型的比例</strong>。</p><p><strong>关键思想：</strong></p><ul><li><strong>输入数据：</strong><ul><li><strong>空间转录组数据（SRT）</strong>：基因表达矩阵，每个 spot 可能包含多个细胞的混合基因表达。</li><li><strong>单细胞 RNA-seq 数据（scRNA-seq）</strong>：提供每种细胞类型的基因表达模式。</li></ul></li><li><strong>输出数据：</strong><ul><li>每个 spot 内部的 <strong>细胞类型组成比例</strong>，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spot 1: 70% 肿瘤细胞, 20% 巨噬细胞, 10% 成纤维细胞</span><br><span class="line">Spot 2: 50% 神经元, 30% 星形胶质细胞, 20% 少突胶质细胞</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>应用场景：</strong></p><ul><li><strong>分析肿瘤微环境（TME）</strong>，推测肿瘤区域内不同免疫细胞的分布情况。</li><li><strong>探索大脑结构</strong>，研究不同皮层层次的细胞组成差异。</li><li><strong>研究发育过程</strong>，分析不同组织区域的细胞类型变化。</li></ul><hr><h2 id="2-rctd-计算过程"><a class="anchor" href="#2-rctd-计算过程">#</a> <strong>2. RCTD 计算过程</strong></h2><h3 id="1-计算细胞类型的特征"><a class="anchor" href="#1-计算细胞类型的特征">#</a> <strong>(1) 计算细胞类型的 “特征”</strong></h3><p>RCTD 通过 scRNA-seq 数据，获取每种细胞类型的特征基因表达模式。例如：</p><ul><li>细胞类型 A：基因 1 高表达，基因 2 低表达。</li><li>细胞类型 B：基因 1 低表达，基因 2 高表达。</li></ul><p>这些信息用于 <strong>构建细胞类型的特征矩阵</strong>。</p><h3 id="2-计算-srt-数据中每个-spot-的基因表达模式"><a class="anchor" href="#2-计算-srt-数据中每个-spot-的基因表达模式">#</a> <strong>(2) 计算 SRT 数据中每个 spot 的基因表达模式</strong></h3><p>每个 spot 含有多个细胞，因此它的基因表达是 <strong>所有细胞类型的混合</strong>。RCTD 需要解出每个 spot 内 <strong>不同细胞类型的贡献比例</strong>。</p><h3 id="3-通过权重优化分解细胞类型"><a class="anchor" href="#3-通过权重优化分解细胞类型">#</a> <strong>(3) 通过权重优化分解细胞类型</strong></h3><p>RCTD 假设 SRT 中每个 spot 的基因表达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.07847em">X</span></span></span></span> 由 <strong>不同细胞类型的加权平均表达</strong> 组成：</p>\begin{align} X = W \cdot C + \epsilon \end{align}<p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.07847em">X</span></span></span></span> 是 SRT 数据的基因表达矩阵（待解）。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.07153em">C</span></span></span></span> 是 scRNA-seq 参考数据中每种细胞类型的基因表达模式（已知）。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">W</span></span></span></span> 是权重矩阵（待求解），表示每种细胞类型在每个 spot 的贡献比例。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">ϵ</span></span></span></span> 是噪声项。</li></ul><p>RCTD 采用 <strong>贝叶斯方法 + 线性优化</strong> 来求解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">W</span></span></span></span>，从而估计每个 spot 内部的细胞类型组成。</p><h3 id="4-归一化-计算细胞类型分布"><a class="anchor" href="#4-归一化-计算细胞类型分布">#</a> <strong>(4) 归一化 &amp; 计算细胞类型分布</strong></h3><p>为了确保所有细胞类型的比例总和为 1，RCTD 进行归一化处理，最终输出每个 spot 的细胞组成。</p><hr><h2 id="3-rctd-在-ensdd-研究中的应用"><a class="anchor" href="#3-rctd-在-ensdd-研究中的应用">#</a> <strong>3. RCTD 在 EnSDD 研究中的应用</strong></h2><p>EnSDD 通过 RCTD 进行细胞类型推测，帮助分析 <strong>不同空间域的细胞组成</strong>，特别是在 <strong>肿瘤微环境分析</strong> 方面表现突出。例如：</p><h3 id="1-在乳腺癌数据中的应用"><a class="anchor" href="#1-在乳腺癌数据中的应用">#</a> <strong>(1) 在乳腺癌数据中的应用</strong></h3><ul><li><strong>目标</strong>：分析肿瘤中心（IDC_5）与肿瘤边缘的细胞类型组成差异。</li><li><strong>结果</strong>：<ul><li><strong>IDC_5 肿瘤中心</strong>：癌细胞比例高，免疫细胞（如巨噬细胞、树突状细胞）比例低。</li><li><strong>肿瘤边缘区域</strong>：免疫细胞（如巨噬细胞和树突状细胞）显著富集，可能与 <strong>肿瘤免疫逃逸机制</strong> 相关。</li></ul></li></ul><p><strong>细胞比例结果（示例）：</strong></p><table><thead><tr><th>Spot</th><th>癌细胞</th><th>巨噬细胞</th><th>树突状细胞</th><th>CD4+ T 细胞</th></tr></thead><tbody><tr><td>1</td><td>70%</td><td>10%</td><td>10%</td><td>10%</td></tr><tr><td>2</td><td>40%</td><td>30%</td><td>20%</td><td>10%</td></tr></tbody></table><h3 id="2-在前列腺癌数据中的应用"><a class="anchor" href="#2-在前列腺癌数据中的应用">#</a> <strong>(2) 在前列腺癌数据中的应用</strong></h3><ul><li><strong>目标</strong>：研究肿瘤区域（Tumor）和肿瘤边界（Ecotone）的细胞类型差异。</li><li><strong>结果</strong>：<ul><li><strong>肿瘤区域</strong>：以 <strong>LE-KLK3 阳性上皮细胞</strong> 为主。</li><li><strong>肿瘤边界（Ecotone）</strong>：更高比例的 <strong>免疫细胞（MNP 和 B 细胞）</strong>，可能影响肿瘤的进展和免疫治疗反应。</li></ul></li></ul><h3 id="3-在卵巢癌数据中的应用"><a class="anchor" href="#3-在卵巢癌数据中的应用">#</a> <strong>(3) 在卵巢癌数据中的应用</strong></h3><ul><li><strong>目标</strong>：分析肿瘤、肿瘤 - 基质交界（Ecotone）和基质区域的细胞组成。</li><li><strong>结果</strong>：<ul><li><strong>肿瘤区域</strong>：EOC（上皮性卵巢癌细胞）占比高。</li><li><strong>肿瘤 - 基质交界</strong>：富含 <strong>上皮细胞、成纤维细胞（CAFs）、间皮细胞</strong>，可能在肿瘤侵袭过程中发挥作用。</li></ul></li></ul><hr><h2 id="4-rctd-与其他方法的对比"><a class="anchor" href="#4-rctd-与其他方法的对比">#</a> <strong>4. RCTD 与其他方法的对比</strong></h2><table><thead><tr><th>方法</th><th>原理</th><th>适用数据</th><th>主要特点</th></tr></thead><tbody><tr><td><strong>RCTD</strong></td><td>基于权重优化的细胞去卷积</td><td>scRNA-seq + SRT</td><td>计算准确，适用于高噪声数据</td></tr><tr><td><strong>Seurat (SPOTlight)</strong></td><td>线性回归 + NMF</td><td>scRNA-seq + SRT</td><td>适用于简单组织</td></tr><tr><td><strong>Stereoscope</strong></td><td>贝叶斯概率模型</td><td>scRNA-seq + SRT</td><td>适用于大规模数据</td></tr><tr><td><strong>Cell2location</strong></td><td>空间层次贝叶斯模型</td><td>scRNA-seq + SRT</td><td>适用于大规模数据，推测稀有细胞类型</td></tr></tbody></table><p>相比 Seurat 和 Stereoscope，<strong>RCTD 对噪声的鲁棒性更强，适用于高复杂度的组织，如癌症组织和大脑皮层</strong>。</p><hr><h2 id="5-结论"><a class="anchor" href="#5-结论">#</a> <strong>5. 结论</strong></h2><ul><li><strong>RCTD 用于估计 SRT 数据中每个 spot 的细胞组成</strong>，帮助 EnSDD 解析不同空间域的细胞类型分布。</li><li>通过 <strong>scRNA-seq 参考数据</strong>，RCTD 能够揭示 <strong>肿瘤微环境、神经组织层次结构等</strong>。</li><li>在 <strong>乳腺癌、前列腺癌、卵巢癌</strong> 数据中，RCTD 发现了 <strong>肿瘤 - 免疫相互作用的关键特征</strong>，有助于癌症生物标志物发现和治疗策略优化。</li></ul></div></details><details class="danger"><summary>RCTD</summary><div><h3 id="puritypur纯度"><a class="anchor" href="#puritypur纯度">#</a> <strong>Purity（Pur，纯度）</strong></h3><p><strong>Purity（纯度）</strong> 是一个用于评估聚类（Clustering）质量的指标，衡量聚类结果与真实类别标签（Ground Truth）的一致性。它的取值范围为 <strong>$$\begin{align}0, 1\end{align}$$</strong>，值越高，表示聚类结果越接近真实分类。</p><hr><h2 id="1-purity-公式"><a class="anchor" href="#1-purity-公式">#</a> <strong>1. Purity 公式</strong></h2>\begin{align} \text{Purity} = \frac{1}{N} \sum_{l=1}^{L} \max_{t} |u_l \cap v_t| \end{align}<p>其中：</p><ul><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span></strong>：样本总数（数据点总数）。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">L</span></span></span></span></strong>：预测聚类的数量（即 EnSDD 识别出的空间域数）。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span></span></span></span></strong>：真实类别（Ground Truth）数量（如人工标注的组织结构）。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">u_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong>：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span></span></span></span> 个预测聚类（即 EnSDD 识别出的某个空间域）。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">v_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2805559999999999em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></strong>：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">t</span></span></span></span> 个真实类别（如已知组织切片的层级）。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>u</mi><mi>l</mi></msub><mo>∩</mo><msub><mi>v</mi><mi>t</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|u_l \cap v_t|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2805559999999999em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></strong>：预测聚类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">u_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 内属于真实类别 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">v_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2805559999999999em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的样本数量。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>max</mi><mo>⁡</mo></mo><mi>t</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>u</mi><mi>l</mi></msub><mo>∩</mo><msub><mi>v</mi><mi>t</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\max_t |u_l \cap v_t|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2805559999999999em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2805559999999999em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></strong>：对于每个预测的聚类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">u_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，找出其中最多的真实类别样本数量。</li></ul><p><strong>解释：</strong></p><ol><li><strong>对于每个预测的聚类</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">u_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，找出其中占比最多的真实类别 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">v_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2805559999999999em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。</li><li><strong>求所有预测聚类的占比最多真实类别样本数的总和</strong>，并除以总样本数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>，得到纯度值。</li></ol><hr><h2 id="2-purity-计算示例"><a class="anchor" href="#2-purity-计算示例">#</a> <strong>2. Purity 计算示例</strong></h2><h3 id="1-示例数据"><a class="anchor" href="#1-示例数据">#</a> <strong>(1) 示例数据</strong></h3><p>假设我们有 10 个数据点，它们的真实类别（Ground Truth）和聚类算法（如 EnSDD）给出的预测聚类如下：</p><table><thead><tr><th>数据点编号</th><th>真实类别 (Ground Truth)</th><th>预测聚类 (Clustering)</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>1</td></tr><tr><td>2</td><td>A</td><td>1</td></tr><tr><td>3</td><td>A</td><td>2</td></tr><tr><td>4</td><td>B</td><td>2</td></tr><tr><td>5</td><td>B</td><td>2</td></tr><tr><td>6</td><td>B</td><td>3</td></tr><tr><td>7</td><td>C</td><td>3</td></tr><tr><td>8</td><td>C</td><td>3</td></tr><tr><td>9</td><td>C</td><td>3</td></tr><tr><td>10</td><td>C</td><td>3</td></tr></tbody></table><h3 id="2-计算每个聚类的最大类别"><a class="anchor" href="#2-计算每个聚类的最大类别">#</a> <strong>(2) 计算每个聚类的最大类别</strong></h3><ul><li><p><strong>聚类 1（u₁）</strong>：</p><ul><li>真实类别 A：2 个</li><li><strong>最大类别：A（2）</strong></li></ul></li><li><p><strong>聚类 2（u₂）</strong>：</p><ul><li>真实类别 A：1 个</li><li>真实类别 B：2 个</li><li><strong>最大类别：B（2）</strong></li></ul></li><li><p><strong>聚类 3（u₃）</strong>：</p><ul><li>真实类别 B：1 个</li><li>真实类别 C：4 个</li><li><strong>最大类别：C（4）</strong></li></ul></li></ul><h3 id="3-计算-purity"><a class="anchor" href="#3-计算-purity">#</a> <strong>(3) 计算 Purity</strong></h3>\begin{align} \text{Purity} = \frac{2 + 2 + 4}{10} = \frac{8}{10} = 0.8 \end{align}<hr><h2 id="3-purity-在-ensdd-论文中的应用"><a class="anchor" href="#3-purity-在-ensdd-论文中的应用">#</a> <strong>3. Purity 在 EnSDD 论文中的应用</strong></h2><p>在 EnSDD 研究中，Purity 主要用于 <strong>评估空间域划分（Spatial Domain Detection）的准确性</strong>，即检查 EnSDD 生成的空间域与人工标注的组织结构（如大脑层次结构或肿瘤组织分区）的匹配程度。</p><h3 id="实验结果示例"><a class="anchor" href="#实验结果示例">#</a> <strong>实验结果示例</strong></h3><ul><li>在 <strong>人类大脑 DLPFC 数据集</strong> 中：<ul><li>EnSDD 纯度（Purity）= <strong>0.704</strong>，优于 STAGATE（0.678）和 spaVAE（0.672）。</li></ul></li><li>在 <strong>乳腺癌数据</strong> 中：<ul><li>EnSDD 纯度（Purity）= <strong>0.668</strong>，高于其他方法。</li></ul></li></ul><p>这些结果表明，EnSDD 生成的空间域划分与真实组织结构的匹配度较高，能够更好地识别不同的组织区域。</p><hr><h2 id="4-purity-与-adjusted-rand-indexari的区别"><a class="anchor" href="#4-purity-与-adjusted-rand-indexari的区别">#</a> <strong>4. Purity 与 Adjusted Rand Index（ARI）的区别</strong></h2><table><thead><tr><th>指标</th><th>适用情况</th><th>计算方法</th><th>取值范围</th><th>主要特点</th></tr></thead><tbody><tr><td><strong>Purity（纯度）</strong></td><td>评估聚类质量</td><td>计算每个预测聚类中最大类别样本数的比例</td><td><strong>[0,1]</strong></td><td>直观易懂，但不能惩罚错误分类</td></tr><tr><td><strong>ARI（调整兰德指数）</strong></td><td>评估聚类与真实类别的一致性</td><td>计算正确分类与随机分类的差值</td><td><strong>[-1,1]</strong></td><td>适用于类数量不均衡的数据，惩罚错误分类</td></tr></tbody></table><p><strong>总结：</strong></p><ul><li><strong>Purity 直观易懂，适合快速评估聚类质量</strong>，但它 <strong>不考虑错误分类的影响</strong>，如果一个大类被错误拆分成多个小类，Purity 仍然可能较高。</li><li><strong>ARI 更加严格</strong>，它不仅考虑正确分类，还会对错误分类进行惩罚，因此对于聚类方法的评估更为精确。</li></ul><p>在 EnSDD 论文中，<strong>Purity 和 ARI 一起使用</strong>，以确保空间域检测方法的可靠性。</p><hr><h2 id="5-结论-2"><a class="anchor" href="#5-结论-2">#</a> <strong>5. 结论</strong></h2><ul><li><strong>Purity 衡量聚类质量，数值越高，说明 EnSDD 预测的空间域更接近真实组织结构。</strong></li><li><strong>与 ARI 结合使用时，Purity 提供直观的匹配度衡量，而 ARI 可检测错误分类的影响。</strong></li><li><strong>在 EnSDD 研究中，Purity 证明了该方法比 STAGATE、spaVAE 等方法具有更好的空间域检测能力。</strong></li></ul><p>如果你想了解 <strong>代码如何计算 Purity</strong> 或者 <strong>如何优化空间域划分算法</strong>，可以告诉我，我可以进一步解析！</p></div></details><hr><h3 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h3><p>在 Methods 部分，论文的关键在于如何将来自不同方法的聚类结果转化为二值相似矩阵，并利用上述优化模型进行加权融合，生成一个能够反映综合信息的共识相似矩阵。通过引入负熵正则化项，模型在防止过拟合的同时，也为各基础方法赋予了合理的权重。最终，这一共识相似矩阵被用来指导 Louvain 算法实现空间域的自动划分，进而为后续的基因表达和细胞类型分布分析提供基础。</p><h1 id="代码"><a class="anchor" href="#代码">#</a> 代码</h1><p>由于代码是 R 语言书写的，不熟悉的地方很多，特此全面的记录解读一番。</p><h2 id="run_individual_clustering"><a class="anchor" href="#run_individual_clustering">#</a> run_individual_clustering</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apply_BayesSpace <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span> platform <span class="operator">=</span> <span class="string">&quot;Visium&quot;</span><span class="punctuation">,</span> n.PCs <span class="operator">=</span> <span class="number">15</span><span class="punctuation">,</span> n.HVGs <span class="operator">=</span> <span class="number">2000</span><span class="punctuation">,</span></span><br><span class="line">                             n.setting <span class="operator">=</span> <span class="number">7</span><span class="punctuation">,</span> nrep <span class="operator">=</span> <span class="number">50000</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">### extract dataset</span></span><br><span class="line">  exp_data <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span>counts <span class="operator">=</span> as.matrix<span class="punctuation">(</span>Seurat.data<span class="operator">@</span>assays<span class="operator">$</span>SCT<span class="operator">@</span>counts<span class="punctuation">)</span><span class="punctuation">,</span> logcounts <span class="operator">=</span> as.matrix<span class="punctuation">(</span>Seurat.data<span class="operator">@</span>assays<span class="operator">$</span>SCT<span class="operator">@</span>data<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  df <span class="operator">&lt;-</span> Seurat.data<span class="operator">@</span>meta.data<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pixel_x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pixel_y&quot;</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">  temp_colnames <span class="operator">&lt;-</span> colnames<span class="punctuation">(</span>df<span class="punctuation">)</span></span><br><span class="line">  temp_colnames <span class="operator">&lt;-</span> sub<span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;row&quot;</span><span class="punctuation">,</span> temp_colnames<span class="punctuation">)</span></span><br><span class="line">  temp_colnames <span class="operator">&lt;-</span> sub<span class="punctuation">(</span><span class="string">&quot;y&quot;</span><span class="punctuation">,</span> <span class="string">&quot;col&quot;</span><span class="punctuation">,</span> temp_colnames<span class="punctuation">)</span></span><br><span class="line">  colnames<span class="punctuation">(</span>df<span class="punctuation">)</span> <span class="operator">&lt;-</span> temp_colnames</span><br><span class="line">  sce <span class="operator">&lt;-</span> SingleCellExperiment<span class="operator">::</span>SingleCellExperiment<span class="punctuation">(</span>assay <span class="operator">=</span> exp_data<span class="punctuation">,</span> colData <span class="operator">=</span> df<span class="punctuation">)</span></span><br><span class="line">  dec <span class="operator">&lt;-</span> scran<span class="operator">::</span>modelGeneVar<span class="punctuation">(</span>sce<span class="punctuation">)</span></span><br><span class="line">  top <span class="operator">&lt;-</span> scran<span class="operator">::</span>getTopHVGs<span class="punctuation">(</span>dec<span class="punctuation">,</span> n <span class="operator">=</span> n.HVGs<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  set.seed<span class="punctuation">(</span><span class="number">102</span><span class="punctuation">)</span></span><br><span class="line">  sce <span class="operator">&lt;-</span> scater<span class="operator">::</span>runPCA<span class="punctuation">(</span>sce<span class="punctuation">,</span> subset_row<span class="operator">=</span>top<span class="punctuation">)</span></span><br><span class="line">  sce <span class="operator">&lt;-</span> BayesSpace<span class="operator">::</span>spatialPreprocess<span class="punctuation">(</span>sce<span class="punctuation">,</span> platform<span class="operator">=</span>platform<span class="punctuation">,</span> skip.PCA<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span>platform <span class="operator">==</span> <span class="string">&quot;Visium&quot;</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="built_in">gamma</span> <span class="operator">&lt;-</span> 3</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span>platform <span class="operator">==</span> <span class="string">&quot;ST&quot;</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="built_in">gamma</span> <span class="operator">&lt;-</span> 2</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  set.seed<span class="punctuation">(</span><span class="number">150</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># if(is.choose.n.cell.type)&#123;</span></span><br><span class="line">  <span class="comment">#   sce &lt;- BayesSpace::qTune(sce = sce, qs = seq(n.min, n.max), platform = platform, nrep = nrep, gamma = gamma)</span></span><br><span class="line">  <span class="comment">#   logliks &lt;- attr(sce, &quot;q.logliks&quot;)</span></span><br><span class="line">  <span class="comment">#   opt_k &lt;- logliks$q[which(logliks$loglik == max(logliks$loglik))]</span></span><br><span class="line">  <span class="comment">#   sce &lt;- BayesSpace::spatialCluster(sce = sce, q = opt_k, platform = platform, nrep = nrep, gamma = gamma)</span></span><br><span class="line">  <span class="comment">#   #BayesSpace::clusterPlot(sce)</span></span><br><span class="line">  <span class="comment">#   res.cluster &lt;- sce$spatial.cluster</span></span><br><span class="line">  <span class="comment">#   names(res.cluster) &lt;- rownames(sce@colData)</span></span><br><span class="line">  <span class="comment"># &#125;else&#123;</span></span><br><span class="line">  sce <span class="operator">&lt;-</span> BayesSpace<span class="operator">::</span>spatialCluster<span class="punctuation">(</span>sce <span class="operator">=</span> sce<span class="punctuation">,</span> q <span class="operator">=</span> n.setting<span class="punctuation">,</span> d <span class="operator">=</span> n.PCs<span class="punctuation">,</span> platform <span class="operator">=</span> platform<span class="punctuation">,</span> nrep <span class="operator">=</span> nrep<span class="punctuation">,</span> <span class="built_in">gamma</span> <span class="operator">=</span> <span class="built_in">gamma</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># BayesSpace::clusterPlot(sce)</span></span><br><span class="line">  res.cluster <span class="operator">&lt;-</span> sce<span class="operator">$</span>spatial.cluster</span><br><span class="line">  <span class="built_in">names</span><span class="punctuation">(</span>res.cluster<span class="punctuation">)</span> <span class="operator">&lt;-</span> rownames<span class="punctuation">(</span>sce<span class="operator">@</span>colData<span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># &#125;</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>res.cluster<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><details class="danger"><summary>BayesSpace</summary><div><p>当然可以，我们来<strong>逐行解读</strong>这个 <code>apply_BayesSpace</code> 函数。它的功能是：在一个 <code>Seurat</code> 对象上使用 <code>BayesSpace</code> 包进行<strong>空间转录组聚类分析</strong>。你这段代码流程很完整，也有些细节挺有意思，我会分块讲解，穿插解释函数作用和每一步背后的意图。</p><hr><h3 id="函数定义和参数说明"><a class="anchor" href="#函数定义和参数说明">#</a> 🧠 函数定义和参数说明：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply_BayesSpace <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span> platform <span class="operator">=</span> <span class="string">&quot;Visium&quot;</span><span class="punctuation">,</span> n.PCs <span class="operator">=</span> <span class="number">15</span><span class="punctuation">,</span> n.HVGs <span class="operator">=</span> <span class="number">2000</span><span class="punctuation">,</span></span><br><span class="line">                             n.setting <span class="operator">=</span> <span class="number">7</span><span class="punctuation">,</span> nrep <span class="operator">=</span> <span class="number">50000</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br></pre></td></tr></table></figure><ul><li><code>Seurat.data</code> ：传入一个处理过的 Seurat 对象，假设已经做完 SCTransform。</li><li><code>platform</code> ：平台类型，如 <code>&quot;Visium&quot;</code> 或 <code>&quot;ST&quot;</code> （决定空间结构等处理方式）。</li><li><code>n.PCs</code> ：PCA 主成分数量，默认为 15。</li><li><code>n.HVGs</code> ：选择前多少个高变基因（Highly Variable Genes）。</li><li><code>n.setting</code> ：聚类数量，即 <code>q</code> 值，默认是 7 类。</li><li><code>nrep</code> ：MCMC 采样的迭代次数，BayesSpace 聚类时使用，默认 50000。</li></ul><hr><h3 id="步骤一从-seurat-对象中提取数据"><a class="anchor" href="#步骤一从-seurat-对象中提取数据">#</a> 📦 步骤一：从 Seurat 对象中提取数据</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exp_data <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span>counts <span class="operator">=</span> as.matrix<span class="punctuation">(</span>Seurat.data<span class="operator">@</span>assays<span class="operator">$</span>SCT<span class="operator">@</span>counts<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                 logcounts <span class="operator">=</span> as.matrix<span class="punctuation">(</span>Seurat.data<span class="operator">@</span>assays<span class="operator">$</span>SCT<span class="operator">@</span>data<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>提取标准化前后的表达矩阵：<ul><li><code>counts</code> : 原始计数</li><li><code>logcounts</code> : SCT 标准化后的 log-scale 表达值</li></ul></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df <span class="operator">&lt;-</span> Seurat.data<span class="operator">@</span>meta.data<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pixel_x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pixel_y&quot;</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><ul><li>从元数据中提取空间坐标。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temp_colnames <span class="operator">&lt;-</span> colnames<span class="punctuation">(</span>df<span class="punctuation">)</span></span><br><span class="line">temp_colnames <span class="operator">&lt;-</span> sub<span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;row&quot;</span><span class="punctuation">,</span> temp_colnames<span class="punctuation">)</span></span><br><span class="line">temp_colnames <span class="operator">&lt;-</span> sub<span class="punctuation">(</span><span class="string">&quot;y&quot;</span><span class="punctuation">,</span> <span class="string">&quot;col&quot;</span><span class="punctuation">,</span> temp_colnames<span class="punctuation">)</span></span><br><span class="line">colnames<span class="punctuation">(</span>df<span class="punctuation">)</span> <span class="operator">&lt;-</span> temp_colnames</span><br></pre></td></tr></table></figure><ul><li><code>BayesSpace</code> 需要用 <code>row</code> , <code>col</code> 命名空间位置，所以这里做了列名替换。</li></ul><hr><h3 id="步骤二构造-singlecellexperiment-对象"><a class="anchor" href="#步骤二构造-singlecellexperiment-对象">#</a> 📦 步骤二：构造 <code>SingleCellExperiment</code> 对象</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sce <span class="operator">&lt;-</span> SingleCellExperiment<span class="operator">::</span>SingleCellExperiment<span class="punctuation">(</span>assay <span class="operator">=</span> exp_data<span class="punctuation">,</span> colData <span class="operator">=</span> df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>创建一个符合 Bioconductor 标准的数据容器，包含表达矩阵和元数据。</li><li><code>BayesSpace</code> 是以 <code>SingleCellExperiment</code> 为输入格式。</li></ul><hr><h3 id="步骤三寻找高变基因并-pca"><a class="anchor" href="#步骤三寻找高变基因并-pca">#</a> 📈 步骤三：寻找高变基因并 PCA</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dec <span class="operator">&lt;-</span> scran<span class="operator">::</span>modelGeneVar<span class="punctuation">(</span>sce<span class="punctuation">)</span></span><br><span class="line">top <span class="operator">&lt;-</span> scran<span class="operator">::</span>getTopHVGs<span class="punctuation">(</span>dec<span class="punctuation">,</span> n <span class="operator">=</span> n.HVGs<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>用 <code>scran</code> 估计每个基因的变异程度，选择前 <code>n.HVGs</code> 个变异最大的基因（通常对降维和聚类效果好）。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set.seed<span class="punctuation">(</span><span class="number">102</span><span class="punctuation">)</span></span><br><span class="line">sce <span class="operator">&lt;-</span> scater<span class="operator">::</span>runPCA<span class="punctuation">(</span>sce<span class="punctuation">,</span> subset_row<span class="operator">=</span>top<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>在 top HVGs 上做 PCA 降维。</li></ul><hr><h3 id="步骤四预处理空间信息"><a class="anchor" href="#步骤四预处理空间信息">#</a> 🧼 步骤四：预处理空间信息</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sce <span class="operator">&lt;-</span> BayesSpace<span class="operator">::</span>spatialPreprocess<span class="punctuation">(</span>sce<span class="punctuation">,</span> platform<span class="operator">=</span>platform<span class="punctuation">,</span> skip.PCA<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>执行 <code>BayesSpace</code> 所需的空间预处理：<ul><li><code>skip.PCA=TRUE</code> 表示我们已经做过 PCA，不重复。</li><li>添加空间网格、邻接矩阵等结构信息。</li></ul></li></ul><hr><h3 id="️-步骤五设置-gamma-超参数平台特异"><a class="anchor" href="#️-步骤五设置-gamma-超参数平台特异">#</a> 🎚️ 步骤五：设置 <code>gamma</code> 超参数（平台特异）</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="punctuation">(</span>platform <span class="operator">==</span> <span class="string">&quot;Visium&quot;</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="built_in">gamma</span> <span class="operator">&lt;-</span> 3</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="keyword">if</span><span class="punctuation">(</span>platform <span class="operator">==</span> <span class="string">&quot;ST&quot;</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="built_in">gamma</span> <span class="operator">&lt;-</span> 2</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>gamma</code> 是 BayesSpace 聚类模型的平滑参数，控制聚类边界的 “平滑程度”。</li></ul><hr><h3 id="步骤六执行-bayesspace-聚类"><a class="anchor" href="#步骤六执行-bayesspace-聚类">#</a> 🔁 步骤六：执行 BayesSpace 聚类</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.seed<span class="punctuation">(</span><span class="number">150</span><span class="punctuation">)</span></span><br><span class="line">sce <span class="operator">&lt;-</span> BayesSpace<span class="operator">::</span>spatialCluster<span class="punctuation">(</span>sce <span class="operator">=</span> sce<span class="punctuation">,</span> q <span class="operator">=</span> n.setting<span class="punctuation">,</span> d <span class="operator">=</span> n.PCs<span class="punctuation">,</span></span><br><span class="line">                                  platform <span class="operator">=</span> platform<span class="punctuation">,</span> nrep <span class="operator">=</span> nrep<span class="punctuation">,</span> <span class="built_in">gamma</span> <span class="operator">=</span> <span class="built_in">gamma</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>开始空间聚类：<ul><li><code>q</code> : 聚类的簇数</li><li><code>d</code> : 使用的 PCA 数量（如前 15 个）</li><li><code>nrep</code> : MCMC 迭代次数（越多越稳定但越慢）</li></ul></li></ul><hr><h3 id="步骤七提取聚类结果"><a class="anchor" href="#步骤七提取聚类结果">#</a> 📊 步骤七：提取聚类结果</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.cluster <span class="operator">&lt;-</span> sce<span class="operator">$</span>spatial.cluster</span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>res.cluster<span class="punctuation">)</span> <span class="operator">&lt;-</span> rownames<span class="punctuation">(</span>sce<span class="operator">@</span>colData<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>聚类结果是一个向量（每个 spot 的聚类标签）。</li><li>给结果加上对应 spot 的名字。</li></ul><hr><h3 id="注释掉的代码自动寻找最佳聚类数"><a class="anchor" href="#注释掉的代码自动寻找最佳聚类数">#</a> 🔁（注释掉的代码）自动寻找最佳聚类数</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sce &lt;- BayesSpace::qTune(...) </span></span><br><span class="line"><span class="comment"># opt_k &lt;- ...</span></span><br><span class="line"><span class="comment"># sce &lt;- BayesSpace::spatialCluster(q = opt_k, ...)</span></span><br></pre></td></tr></table></figure><ul><li>这段注释代码原本用于自动寻找最优 <code>q</code> 值（聚类数），通过比较对数似然。但作者这里选择手动设定 <code>n.setting</code> 。</li></ul><hr><h3 id="返回结果"><a class="anchor" href="#返回结果">#</a> 🔚 返回结果</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span><span class="punctuation">(</span>res.cluster<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>返回一个聚类结果向量，用户可以根据它进行可视化、下游分析等。</li></ul><hr><h3 id="总结一句话"><a class="anchor" href="#总结一句话">#</a> ✅ 总结一句话：</h3><blockquote><p>这个函数将 Seurat 对象转换为 <code>SingleCellExperiment</code> ，挑选高变基因做 PCA，然后用 <code>BayesSpace</code> 进行空间聚类分析，并返回每个 spot 的聚类标签。</p></blockquote><hr><p>你可以配合 <code>BayesSpace::clusterPlot(sce)</code> 进行可视化，也可以把这个结果加到 Seurat 对象里，继续做差异分析。</p><p>如果你还想了解聚类原理或者对某个包函数不理解，可以继续问我！</p></div></details><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apply_SpaGCN <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span> SpaGCN_beta <span class="operator">=</span> <span class="number">55</span><span class="punctuation">,</span> SpaGCN_alpha <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> SpaGCN_p <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                         SpaGCN_l <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span> num.cluster <span class="operator">=</span> <span class="number">7</span><span class="punctuation">,</span> res.setting <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> SpaGCN_lr <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span></span><br><span class="line">                         SpaGCN_epoches <span class="operator">=</span> <span class="number">200</span><span class="punctuation">,</span> platform <span class="operator">=</span> <span class="string">&quot;Visium&quot;</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  temp <span class="operator">&lt;-</span> Seurat.data<span class="operator">@</span>images</span><br><span class="line">  counts_path <span class="operator">&lt;-</span> temp<span class="operator">$</span>counts_path</span><br><span class="line">  meta_path <span class="operator">&lt;-</span> temp<span class="operator">$</span>loc_path</span><br><span class="line">  img_path <span class="operator">&lt;-</span> temp<span class="operator">$</span>img_path</span><br><span class="line"></span><br><span class="line">  <span class="comment">### for install python scripts in R package</span></span><br><span class="line">  <span class="comment"># EnSDD_pyexec(pyfile = system.file(&quot;python&quot;, &quot;apply_spaGCN.py&quot;,</span></span><br><span class="line">  <span class="comment">#                                   package = &quot;EnSDD&quot;))</span></span><br><span class="line">  reticulate<span class="operator">::</span>source_python<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;python&quot;</span><span class="punctuation">,</span> <span class="string">&quot;apply_spaGCN.py&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    package <span class="operator">=</span> <span class="string">&quot;EnSDD&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># reticulate::source_python(&#x27;/home/vision/Downloads/LHS/EnDecon/EnSDD/inst/python/apply_spaGCN.py&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  run_spaGCN<span class="punctuation">(</span>counts_path<span class="punctuation">,</span> meta_path<span class="punctuation">,</span> img_path<span class="punctuation">,</span> platform <span class="operator">=</span> platform<span class="punctuation">,</span> res_setting_by_user <span class="operator">=</span> res.setting<span class="punctuation">,</span></span><br><span class="line">             b <span class="operator">=</span> <span class="built_in">as.integer</span><span class="punctuation">(</span>SpaGCN_beta<span class="punctuation">)</span><span class="punctuation">,</span> a <span class="operator">=</span> SpaGCN_alpha<span class="punctuation">,</span> p <span class="operator">=</span> SpaGCN_p<span class="punctuation">,</span></span><br><span class="line">             n_clusters <span class="operator">=</span> <span class="built_in">as.integer</span><span class="punctuation">(</span>num.cluster<span class="punctuation">)</span><span class="punctuation">,</span> lr <span class="operator">=</span> SpaGCN_lr<span class="punctuation">,</span></span><br><span class="line">             max_epochs <span class="operator">=</span> <span class="built_in">as.integer</span><span class="punctuation">(</span>SpaGCN_epoches<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  res.path <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span>dirname<span class="punctuation">(</span>img_path<span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;/spaGCN_res&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/spaGCN_label.txt&quot;</span><span class="punctuation">)</span></span><br><span class="line">  res_temp <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span>res.path<span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;\t&quot;</span><span class="punctuation">)</span></span><br><span class="line">  res <span class="operator">&lt;-</span> res_temp<span class="operator">$</span>V2</span><br><span class="line">  <span class="built_in">names</span><span class="punctuation">(</span>res<span class="punctuation">)</span> <span class="operator">&lt;-</span> res_temp<span class="operator">$</span>V1</span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">sum</span><span class="punctuation">(</span>res <span class="operator">==</span> <span class="number">0</span><span class="punctuation">)</span> <span class="operator">!=</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    res <span class="operator">&lt;-</span> res <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  res <span class="operator">&lt;-</span> res<span class="punctuation">[</span>colnames<span class="punctuation">(</span>Seurat.data<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">  unlink<span class="punctuation">(</span>paste0<span class="punctuation">(</span>dirname<span class="punctuation">(</span>img_path<span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;/spaGCN_res&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> recursive<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>res<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><details class="danger"><summary>SpaGCN</summary><div><p>当然可以！下面我来<strong>逐行解读</strong>这段 <code>apply_SpaGCN</code> 函数的 R 代码。这段代码的功能是：调用 Python 实现的 <strong>SpaGCN</strong> 空间聚类算法，并返回聚类结果。它通过 <code>reticulate</code> 接口从 R 中运行 Python 脚本。</p><hr><h3 id="函数定义及参数说明"><a class="anchor" href="#函数定义及参数说明">#</a> 🧠 函数定义及参数说明</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply_SpaGCN <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span></span><br><span class="line">                         SpaGCN_beta <span class="operator">=</span> <span class="number">55</span><span class="punctuation">,</span></span><br><span class="line">                         SpaGCN_alpha <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                         SpaGCN_p <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                         SpaGCN_l <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                         num.cluster <span class="operator">=</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">                         res.setting <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">                         SpaGCN_lr <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span></span><br><span class="line">                         SpaGCN_epoches <span class="operator">=</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">                         platform <span class="operator">=</span> <span class="string">&quot;Visium&quot;</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br></pre></td></tr></table></figure><ul><li><code>Seurat.data</code> : Seurat 对象（空间数据），包含图像路径信息</li><li><code>SpaGCN_beta</code> , <code>SpaGCN_alpha</code> , <code>SpaGCN_p</code> , <code>SpaGCN_l</code> : 是 SpaGCN 聚类算法的超参数，控制空间权重、邻域强度等</li><li><code>num.cluster</code> : 聚类簇数量</li><li><code>res.setting</code> : 聚类分辨率设置（用户自定义）</li><li><code>SpaGCN_lr</code> : 学习率</li><li><code>SpaGCN_epoches</code> : 训练迭代次数</li><li><code>platform</code> : 平台，如 &quot;Visium&quot;，决定空间坐标解读方式</li></ul><hr><h3 id="1-提取图像路径"><a class="anchor" href="#1-提取图像路径">#</a> 📦 1. 提取图像路径</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temp <span class="operator">&lt;-</span> Seurat.data<span class="operator">@</span>images</span><br><span class="line">counts_path <span class="operator">&lt;-</span> temp<span class="operator">$</span>counts_path</span><br><span class="line">meta_path <span class="operator">&lt;-</span> temp<span class="operator">$</span>loc_path</span><br><span class="line">img_path <span class="operator">&lt;-</span> temp<span class="operator">$</span>img_path</span><br></pre></td></tr></table></figure><p>假设 <code>Seurat.data@images</code> 存放了一些自定义字段（比如用 <code>$counts_path</code> 来表示 count 矩阵路径、meta 信息和图像路径）：</p><ul><li><code>counts_path</code> : 表达矩阵（spot × gene）的文本路径</li><li><code>meta_path</code> : spot 的空间位置信息</li><li><code>img_path</code> : H&amp;E 图像文件路径</li></ul><p>⚠️ 这些字段可能是你自己前期写入 <code>SeuratObject@images</code> 的，不是默认字段。</p><hr><h3 id="2-加载-python-脚本"><a class="anchor" href="#2-加载-python-脚本">#</a> 🐍 2. 加载 Python 脚本</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reticulate<span class="operator">::</span>source_python<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;python&quot;</span><span class="punctuation">,</span> <span class="string">&quot;apply_spaGCN.py&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;EnSDD&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><code>source_python(...)</code> ：通过 R 的 <code>reticulate</code> 包加载 Python 脚本</li><li><code>system.file(...)</code> ：定位 R 包 <code>EnSDD</code> 中的 <code>apply_spaGCN.py</code> 脚本路径<ul><li>假设你安装了一个 R 包叫 <code>EnSDD</code> ，它里面封装了运行 SpaGCN 所需的 Python 脚本</li></ul></li></ul><p>📝 被注释的 <code>EnSDD_pyexec(...)</code> 也可能是某个自定义封装，但你实际使用的是 <code>reticulate</code> 。</p><hr><h3 id="3-调用-python-的-run_spagcn-函数"><a class="anchor" href="#3-调用-python-的-run_spagcn-函数">#</a> 🚀 3. 调用 Python 的 <code>run_spaGCN</code> 函数</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">run_spaGCN<span class="punctuation">(</span>counts_path<span class="punctuation">,</span> meta_path<span class="punctuation">,</span> img_path<span class="punctuation">,</span></span><br><span class="line">           platform <span class="operator">=</span> platform<span class="punctuation">,</span></span><br><span class="line">           res_setting_by_user <span class="operator">=</span> res.setting<span class="punctuation">,</span></span><br><span class="line">           b <span class="operator">=</span> <span class="built_in">as.integer</span><span class="punctuation">(</span>SpaGCN_beta<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">           a <span class="operator">=</span> SpaGCN_alpha<span class="punctuation">,</span></span><br><span class="line">           p <span class="operator">=</span> SpaGCN_p<span class="punctuation">,</span></span><br><span class="line">           n_clusters <span class="operator">=</span> <span class="built_in">as.integer</span><span class="punctuation">(</span>num.cluster<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">           lr <span class="operator">=</span> SpaGCN_lr<span class="punctuation">,</span></span><br><span class="line">           max_epochs <span class="operator">=</span> <span class="built_in">as.integer</span><span class="punctuation">(</span>SpaGCN_epoches<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>这个函数在 <code>apply_spaGCN.py</code> 中定义，接收参数并执行 SpaGCN 空间聚类任务</li><li>SpaGCN 是一个 GCN（图卷积网络）框架，结合空间坐标和图像信息进行聚类</li><li>参数解析：<ul><li><code>b = beta</code> ：控制空间光滑性</li><li><code>a = alpha</code> 、 <code>p</code> ：控制边权的计算</li><li><code>n_clusters</code> ：聚类个数</li><li><code>res_setting_by_user</code> : 分辨率</li><li><code>lr</code> : 学习率</li><li><code>max_epochs</code> : 迭代次数</li></ul></li></ul><p>✅ 此处训练过程全在 Python 中执行，输出为文件结果。</p><hr><h3 id="4-加载结果并处理"><a class="anchor" href="#4-加载结果并处理">#</a> 📁 4. 加载结果并处理</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.path <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span>dirname<span class="punctuation">(</span>img_path<span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;/spaGCN_res&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/spaGCN_label.txt&quot;</span><span class="punctuation">)</span></span><br><span class="line">res_temp <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span>res.path<span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;\t&quot;</span><span class="punctuation">)</span></span><br><span class="line">res <span class="operator">&lt;-</span> res_temp<span class="operator">$</span>V2</span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>res<span class="punctuation">)</span> <span class="operator">&lt;-</span> res_temp<span class="operator">$</span>V1</span><br></pre></td></tr></table></figure><ul><li>Python 会在图片所在文件夹下创建 <code>spaGCN_res/spaGCN_label.txt</code></li><li>文件中记录的是： <code>spot名称 \t 聚类标签</code></li><li>把 <code>V2</code> 作为聚类标签， <code>V1</code> 为 spot 名，转换为一个 R 命名向量</li></ul><hr><h3 id="5-spagcn-聚类结果中可能含有-0-类-调整为从1开始"><a class="anchor" href="#5-spagcn-聚类结果中可能含有-0-类-调整为从1开始">#</a> 🔢 5. SpaGCN 聚类结果中可能含有 &quot;0&quot; 类 → 调整为从 1 开始</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">sum</span><span class="punctuation">(</span>res <span class="operator">==</span> <span class="number">0</span><span class="punctuation">)</span> <span class="operator">!=</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  res <span class="operator">&lt;-</span> res <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>如果存在 0 类，就全部 +1，使得聚类编号从 1 开始（防止误差）</li></ul><hr><h3 id="6-根据-seurat-的列顺序排列聚类结果并清理中间文件夹"><a class="anchor" href="#6-根据-seurat-的列顺序排列聚类结果并清理中间文件夹">#</a> ✅ 6. 根据 Seurat 的列顺序排列聚类结果，并清理中间文件夹</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res <span class="operator">&lt;-</span> res<span class="punctuation">[</span>colnames<span class="punctuation">(</span>Seurat.data<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">unlink<span class="punctuation">(</span>paste0<span class="punctuation">(</span>dirname<span class="punctuation">(</span>img_path<span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;/spaGCN_res&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> recursive<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">return</span><span class="punctuation">(</span>res<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>确保返回的聚类向量顺序和 Seurat 中列顺序一致</li><li>删除 SpaGCN 临时输出文件夹，避免污染</li><li>返回：spot-level 聚类标签</li></ul><hr><h3 id="总结一句话-2"><a class="anchor" href="#总结一句话-2">#</a> 🎉 总结一句话：</h3><blockquote><p><code>apply_SpaGCN()</code> 是一个 R 函数，用于封装和调用 Python 的 <code>SpaGCN</code> 空间聚类过程，输入是 Seurat 对象，输出是每个 spot 的聚类标签。</p></blockquote><hr><p>如果你想看 <code>apply_spaGCN.py</code> 文件里 <code>run_spaGCN()</code> 是如何实现的，也可以把那个 Python 文件贴给我，我可以继续帮你逐行解读～</p><p>或者你想把这个结果接回 Seurat 进行可视化的话，也可以问我哦。</p></div></details><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">run_individual_cluster <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>counts_path<span class="punctuation">,</span> loc_path<span class="punctuation">,</span> img_path<span class="punctuation">,</span> python_env<span class="punctuation">,</span> n_HVG <span class="operator">=</span> <span class="number">2000</span><span class="punctuation">,</span> n_PCA <span class="operator">=</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">                                   number.setting.by.user <span class="operator">=</span> <span class="number">7</span><span class="punctuation">,</span>  saving_results <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">                                   BayesSpace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> DR.SC <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> SpaGCN <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> stLearn <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">                                   GraphST <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> STAGATE <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">                                   BayesSpace_nrep <span class="operator">=</span> <span class="number">50000</span><span class="punctuation">,</span></span><br><span class="line">                                   DR.SC_n_SVGs <span class="operator">=</span> <span class="number">600</span><span class="punctuation">,</span> DR.SC_latent_q <span class="operator">=</span> <span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">                                   SpaGCN_beta <span class="operator">=</span> <span class="number">55</span><span class="punctuation">,</span> SpaGCN_alpha <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> SpaGCN_p <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span> SpaGCN_l <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                                   SpaGCN_res.setting <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> SpaGCN_lr <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span> SpaGCN_epoches <span class="operator">=</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">                                   stLearn_n.PCs <span class="operator">=</span> <span class="number">30</span><span class="punctuation">,</span> stLearn_normalize_type <span class="operator">=</span> <span class="string">&quot;physical_distance&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                   GraphST_lambda1 <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> GraphST_lambda2 <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> GraphST_tool <span class="operator">=</span> <span class="string">&quot;mclust&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                   GraphST_radius <span class="operator">=</span> <span class="number">50</span><span class="punctuation">,</span> GraphST_refinement <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> GraphST_n_PCs <span class="operator">=</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">                                   STAGATE_alpha <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">is.null</span><span class="punctuation">(</span>python_env<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;if you want to use the environment of your own python, please set it manual.</span></span><br><span class="line"><span class="string">         Otherwise, the code will create R_reticulate environment and install the essential</span></span><br><span class="line"><span class="string">         python packages for running SpaGCN, stLearn, GraphST, STAGATE.</span></span><br><span class="line"><span class="string">         We strongly recommend the user to construct anaconda env and install python</span></span><br><span class="line"><span class="string">         packages by running the .yml file we provided.&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="keyword">else</span><span class="punctuation">&#123;</span></span><br><span class="line">    reticulate<span class="operator">::</span>use_python<span class="punctuation">(</span>python_env<span class="punctuation">,</span> require <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line">    reticulate<span class="operator">::</span>py_config<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  message<span class="punctuation">(</span><span class="string">&quot;Some methods, including STAGATE, DR.SC, BayesSpace</span></span><br><span class="line"><span class="string">          needs the number of clusters setting by users, Other methods select the number</span></span><br><span class="line"><span class="string">          of cluster by various strategies.\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">  Methods <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;BayesSpace&quot;</span><span class="punctuation">,</span> <span class="string">&quot;DR.SC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;SpaGCN&quot;</span><span class="punctuation">,</span> <span class="string">&quot;stLearn&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GraphST&quot;</span><span class="punctuation">,</span> <span class="string">&quot;STAGATE&quot;</span><span class="punctuation">)</span></span><br><span class="line">  Methods.idx <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>BayesSpace<span class="punctuation">,</span> DR.SC<span class="punctuation">,</span> SpaGCN<span class="punctuation">,</span> stLearn<span class="punctuation">,</span> GraphST<span class="punctuation">,</span> STAGATE<span class="punctuation">)</span></span><br><span class="line">  Methods.used <span class="operator">&lt;-</span> Methods<span class="punctuation">[</span>Methods.idx<span class="punctuation">]</span></span><br><span class="line">  K <span class="operator">&lt;-</span> <span class="built_in">length</span><span class="punctuation">(</span>Methods.used<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  Seurat.data <span class="operator">&lt;-</span> data_process<span class="punctuation">(</span>counts_path<span class="punctuation">,</span> loc_path<span class="punctuation">,</span> img_path<span class="punctuation">,</span> n_HVG<span class="punctuation">,</span> n_PCA<span class="punctuation">)</span></span><br><span class="line">  <span class="comment">### global setting</span></span><br><span class="line">  sequencing_platform <span class="operator">=</span> <span class="string">&quot;Visium&quot;</span></span><br><span class="line"></span><br><span class="line">  res.clustering <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">  time.methods <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">  k <span class="operator">&lt;-</span> 1</span><br><span class="line">  <span class="comment"># apply Giotto</span></span><br><span class="line">  <span class="comment"># if(Giotto)&#123;</span></span><br><span class="line">  <span class="comment">#   cat(&quot;Run Giotto_LD, Giotto_KM, Giotto_H, Giotto_HM...\n&quot;)</span></span><br><span class="line">  <span class="comment">#   pred.Giotto &lt;- Sys.time()</span></span><br><span class="line">  <span class="comment">#   temp.Giotto &lt;- apply_Giotto(Seurat.data, LD_k = Giotto_LD_k, LD_resolution = Giotto_LD_resolution,</span></span><br><span class="line">  <span class="comment">#                               num_cluster = number.setting.by.user, HM_walk_step = Giotto_HM_walk_step)</span></span><br><span class="line">  <span class="comment">#   end.Giotto &lt;- Sys.time()</span></span><br><span class="line">  <span class="comment">#   time.Giotto &lt;- difftime(end.Giotto, pred.Giotto, units = &quot;mins&quot;)</span></span><br><span class="line">  <span class="comment">#   cat(&quot;Run time for Giotto: &quot;, time.Giotto, &quot;min&quot;,&quot;\n&quot;)</span></span><br><span class="line">  <span class="comment">#   time.methods &lt;- c(time.methods, time.Giotto)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#   res.clustering$Giotto_LD &lt;- temp.Giotto$Giotto_LD</span></span><br><span class="line">  <span class="comment">#   res.clustering$Giotto_KM &lt;- temp.Giotto$Giotto_KM</span></span><br><span class="line">  <span class="comment">#   res.clustering$Giotto_H &lt;- temp.Giotto$Giotto_H</span></span><br><span class="line">  <span class="comment">#   res.clustering$Giotto_HM &lt;- temp.Giotto$Giotto_HM</span></span><br><span class="line">  <span class="comment">#   k &lt;- k + 1</span></span><br><span class="line">  <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># apply Seurat</span></span><br><span class="line">  <span class="comment"># if(Seurat)&#123;</span></span><br><span class="line">  <span class="comment">#   cat(&quot;Run Seurat...\n&quot;)</span></span><br><span class="line">  <span class="comment">#   pred.Seurat &lt;- Sys.time()</span></span><br><span class="line">  <span class="comment">#   temp.Seurat &lt;- apply_Seurat(Seurat.data, Seurat_k_neighbor, Seurat.resolution, number.setting.by.user)</span></span><br><span class="line">  <span class="comment">#   end.Seurat &lt;- Sys.time()</span></span><br><span class="line">  <span class="comment">#   time.Seurat &lt;- difftime(end.Seurat, pred.Seurat, units = &quot;mins&quot;)</span></span><br><span class="line">  <span class="comment">#   cat(&quot;Run time for Seurat: &quot;, time.Seurat, &quot;min&quot;,&quot;\n&quot;)</span></span><br><span class="line">  <span class="comment">#   time.methods &lt;- c(time.methods, time.Seurat)</span></span><br><span class="line">  <span class="comment">#   res.clustering$Seurat &lt;- temp.Seurat</span></span><br><span class="line">  <span class="comment">#   k &lt;- k + 1</span></span><br><span class="line">  <span class="comment"># &#125;</span></span><br><span class="line">  <span class="comment"># apply BayesSpace</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span>BayesSpace<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Run BayesSpace...\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">    pred.BayesSpace <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    temp.BayesSpace <span class="operator">&lt;-</span> apply_BayesSpace<span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span> platform <span class="operator">=</span> sequencing_platform<span class="punctuation">,</span> n.PCs <span class="operator">=</span> n_PCA<span class="punctuation">,</span></span><br><span class="line">                                        n.HVGs <span class="operator">=</span> n_HVG<span class="punctuation">,</span> n.setting <span class="operator">=</span> number.setting.by.user<span class="punctuation">,</span></span><br><span class="line">                                        nrep <span class="operator">=</span> BayesSpace_nrep<span class="punctuation">)</span></span><br><span class="line">    end.BayesSpace <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    time.BayesSpace <span class="operator">&lt;-</span> difftime<span class="punctuation">(</span>end.BayesSpace<span class="punctuation">,</span> pred.BayesSpace<span class="punctuation">,</span> units <span class="operator">=</span> <span class="string">&quot;mins&quot;</span><span class="punctuation">)</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Run time for BayesSpace: &quot;</span><span class="punctuation">,</span> time.BayesSpace<span class="punctuation">,</span> <span class="string">&quot;min&quot;</span><span class="punctuation">,</span><span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">    time.methods <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>time.methods<span class="punctuation">,</span> time.BayesSpace<span class="punctuation">)</span></span><br><span class="line">    res.clustering<span class="operator">$</span>BayesSpace <span class="operator">&lt;-</span> temp.BayesSpace</span><br><span class="line">    k <span class="operator">&lt;-</span> k <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="comment"># apply DR.SC</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span>DR.SC<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Run DR.SC...\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">    pred.DR.SC <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    temp.DR.SC <span class="operator">&lt;-</span> apply_DR.SC<span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span> n_SVGs <span class="operator">=</span> DR.SC_n_SVGs<span class="punctuation">,</span> latent_q <span class="operator">=</span> DR.SC_latent_q<span class="punctuation">,</span></span><br><span class="line">                              num.ct <span class="operator">=</span> number.setting.by.user<span class="punctuation">,</span> platform <span class="operator">=</span> sequencing_platform<span class="punctuation">)</span></span><br><span class="line">    end.DR.SC <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    time.DR.SC <span class="operator">&lt;-</span> difftime<span class="punctuation">(</span>end.DR.SC<span class="punctuation">,</span> pred.DR.SC<span class="punctuation">,</span> units <span class="operator">=</span> <span class="string">&quot;mins&quot;</span><span class="punctuation">)</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Run time for DR.SC: &quot;</span><span class="punctuation">,</span> time.DR.SC<span class="punctuation">,</span> <span class="string">&quot;min&quot;</span><span class="punctuation">,</span><span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">    time.methods <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>time.methods<span class="punctuation">,</span> time.DR.SC<span class="punctuation">)</span></span><br><span class="line">    res.clustering<span class="operator">$</span>DR.SC <span class="operator">&lt;-</span> temp.DR.SC</span><br><span class="line">    k <span class="operator">&lt;-</span> k <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="comment"># apply SpaGCN</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span>SpaGCN<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Run SpaGCN...\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">    pred.SpaGCN <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    temp.SpaGCN <span class="operator">&lt;-</span> apply_SpaGCN<span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span> SpaGCN_beta<span class="punctuation">,</span> SpaGCN_alpha<span class="punctuation">,</span> SpaGCN_p<span class="punctuation">,</span></span><br><span class="line">                                SpaGCN_l<span class="punctuation">,</span> number.setting.by.user<span class="punctuation">,</span> SpaGCN_res.setting<span class="punctuation">,</span> SpaGCN_lr<span class="punctuation">,</span></span><br><span class="line">                                SpaGCN_epoches<span class="punctuation">,</span> sequencing_platform<span class="punctuation">)</span></span><br><span class="line">    end.SpaGCN <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    time.SpaGCN <span class="operator">&lt;-</span> difftime<span class="punctuation">(</span>end.SpaGCN<span class="punctuation">,</span> pred.SpaGCN<span class="punctuation">,</span> units <span class="operator">=</span> <span class="string">&quot;mins&quot;</span><span class="punctuation">)</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Run time for SpaGCN: &quot;</span><span class="punctuation">,</span> time.SpaGCN<span class="punctuation">,</span> <span class="string">&quot;min&quot;</span><span class="punctuation">,</span><span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">    time.methods <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>time.methods<span class="punctuation">,</span> time.SpaGCN<span class="punctuation">)</span></span><br><span class="line">    res.clustering<span class="operator">$</span>SpaGCN <span class="operator">&lt;-</span> temp.SpaGCN</span><br><span class="line">    k <span class="operator">&lt;-</span> k <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="comment"># apply stLearn</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span>stLearn<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Run stLearn...\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">    pred.stLearn <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    temp.stLearn <span class="operator">&lt;-</span> apply_stLearn<span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span> stLearn_n.PCs<span class="punctuation">,</span> number.setting.by.user<span class="punctuation">,</span> stLearn_normalize_type<span class="punctuation">)</span></span><br><span class="line">    end.stLearn <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    time.stLearn <span class="operator">&lt;-</span> difftime<span class="punctuation">(</span>end.stLearn<span class="punctuation">,</span> pred.stLearn<span class="punctuation">,</span> units <span class="operator">=</span> <span class="string">&quot;mins&quot;</span><span class="punctuation">)</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Run time for stLearn: &quot;</span><span class="punctuation">,</span> time.stLearn<span class="punctuation">,</span> <span class="string">&quot;min&quot;</span><span class="punctuation">,</span><span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">    time.methods <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>time.methods<span class="punctuation">,</span> time.stLearn<span class="punctuation">)</span></span><br><span class="line">    res.clustering<span class="operator">$</span>stLearn <span class="operator">&lt;-</span> temp.stLearn</span><br><span class="line">    k <span class="operator">&lt;-</span> k <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="comment"># apply GraphST</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span>GraphST<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Run GraphST...\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">    pred.GraphST <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    temp.GraphST <span class="operator">&lt;-</span> apply_GraphST<span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span> number.setting.by.user<span class="punctuation">,</span> GraphST_lambda1<span class="punctuation">,</span> GraphST_lambda2<span class="punctuation">,</span></span><br><span class="line">                                  GraphST_tool<span class="punctuation">,</span> GraphST_radius<span class="punctuation">,</span> GraphST_n_PCs<span class="punctuation">,</span> GraphST_refinement<span class="punctuation">)</span></span><br><span class="line">    end.GraphST <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    time.GraphST <span class="operator">&lt;-</span> difftime<span class="punctuation">(</span>end.GraphST<span class="punctuation">,</span> pred.GraphST<span class="punctuation">,</span> units <span class="operator">=</span> <span class="string">&quot;mins&quot;</span><span class="punctuation">)</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Run time for GraphST: &quot;</span><span class="punctuation">,</span> time.GraphST<span class="punctuation">,</span> <span class="string">&quot;min&quot;</span><span class="punctuation">,</span><span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">    time.methods <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>time.methods<span class="punctuation">,</span> time.GraphST<span class="punctuation">)</span></span><br><span class="line">    res.clustering<span class="operator">$</span>GraphST <span class="operator">&lt;-</span> temp.GraphST</span><br><span class="line">    k <span class="operator">&lt;-</span> k <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="comment"># apply STAGATE</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span>STAGATE<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Run STAGATE...\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">    pred.STAGATE <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    temp.STAGATE <span class="operator">&lt;-</span> apply_STAGATE<span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span> number.setting.by.user<span class="punctuation">,</span> STAGATE_alpha<span class="punctuation">)</span></span><br><span class="line">    end.STAGATE <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    time.STAGATE <span class="operator">&lt;-</span> difftime<span class="punctuation">(</span>end.STAGATE<span class="punctuation">,</span> pred.STAGATE<span class="punctuation">,</span> units <span class="operator">=</span> <span class="string">&quot;mins&quot;</span><span class="punctuation">)</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Run time for STAGATE: &quot;</span><span class="punctuation">,</span> time.STAGATE<span class="punctuation">,</span> <span class="string">&quot;min&quot;</span><span class="punctuation">,</span><span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">    time.methods <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>time.methods<span class="punctuation">,</span> time.STAGATE<span class="punctuation">)</span></span><br><span class="line">    res.clustering<span class="operator">$</span>STAGATE <span class="operator">&lt;-</span> temp.STAGATE</span><br><span class="line">    k <span class="operator">&lt;-</span> k <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">names</span><span class="punctuation">(</span>time.methods<span class="punctuation">)</span> <span class="operator">&lt;-</span> Methods.used</span><br><span class="line">  <span class="comment">### check NA in the methods</span></span><br><span class="line">  index.list <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">  <span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="built_in">length</span><span class="punctuation">(</span>res.clustering<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    na.index <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>res.clustering<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    <span class="keyword">if</span><span class="punctuation">(</span>na.index <span class="operator">!=</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">      index.list <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>index.list<span class="punctuation">,</span> i<span class="punctuation">)</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">length</span><span class="punctuation">(</span>index.list<span class="punctuation">)</span> <span class="operator">!=</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    methods.names.tmp <span class="operator">&lt;-</span> <span class="built_in">names</span><span class="punctuation">(</span>res.clustering<span class="punctuation">)</span><span class="punctuation">[</span>index.list<span class="punctuation">]</span></span><br><span class="line">    <span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> methods.names.tmp<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">      res.clustering<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="literal">NULL</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="comment">### check NA in the methods</span></span><br><span class="line">  res.clustering.matrix <span class="operator">&lt;-</span> lapply<span class="punctuation">(</span>res.clustering<span class="punctuation">,</span> clust2Mat<span class="punctuation">)</span></span><br><span class="line">  res <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span>clustering.vec <span class="operator">=</span> res.clustering <span class="punctuation">,</span> clustering.mat <span class="operator">=</span> res.clustering.matrix<span class="punctuation">,</span> time <span class="operator">=</span> time.methods<span class="punctuation">)</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span>saving_results<span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;Saving individual clustering analysis results...\n&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">    save<span class="punctuation">(</span>res<span class="punctuation">,</span> file <span class="operator">=</span> <span class="string">&quot;res.clustering.RData&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>res<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><details class="danger"><summary>run_individual_clustering</summary><div><p>当然可以！这段代码是一个 STAGATE 方法的调用和结果处理模块，通常嵌套在一个更大的函数体内，负责：</p><blockquote><p><strong>运行 STAGATE 空间聚类，记录运行时间，处理聚类结果并保存。</strong></p></blockquote><p>我会按逻辑结构详细解释每个部分👇：</p><hr><h3 id="1-判断是否执行-stagate-聚类"><a class="anchor" href="#1-判断是否执行-stagate-聚类">#</a> ✅ 1. 判断是否执行 STAGATE 聚类</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="punctuation">(</span>STAGATE<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br></pre></td></tr></table></figure><ul><li>如果传入的 <code>STAGATE</code> 参数为 <code>TRUE</code> ，就会执行 STAGATE 聚类分析。</li></ul><hr><h3 id="2-调用-apply_stagate-函数并计时"><a class="anchor" href="#2-调用-apply_stagate-函数并计时">#</a> 🧪 2. 调用 <code>apply_STAGATE()</code> 函数并计时</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat<span class="punctuation">(</span><span class="string">&quot;Run STAGATE...\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">pred.STAGATE <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">temp.STAGATE <span class="operator">&lt;-</span> apply_STAGATE<span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span> number.setting.by.user<span class="punctuation">,</span> STAGATE_alpha<span class="punctuation">)</span></span><br><span class="line">end.STAGATE <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">time.STAGATE <span class="operator">&lt;-</span> difftime<span class="punctuation">(</span>end.STAGATE<span class="punctuation">,</span> pred.STAGATE<span class="punctuation">,</span> units <span class="operator">=</span> <span class="string">&quot;mins&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>打印提示语： <code>Run STAGATE...</code></li><li>记录开始时间 <code>pred.STAGATE</code></li><li>调用 STAGATE 聚类函数 <code>apply_STAGATE()</code> ，传入参数：<ul><li><code>Seurat.data</code> ：Seurat 格式空间转录组对象</li><li><code>number.setting.by.user</code> ：用户设定的聚类簇数</li><li><code>STAGATE_alpha</code> ：控制聚类图平滑程度的参数（STAGATE 超参数）</li></ul></li><li>记录结束时间 <code>end.STAGATE</code></li><li>计算运行时间（分钟） <code>time.STAGATE</code></li></ul><hr><h3 id="3-保存-stagate-聚类结果到列表对象中"><a class="anchor" href="#3-保存-stagate-聚类结果到列表对象中">#</a> 📝 3. 保存 STAGATE 聚类结果到列表对象中</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat<span class="punctuation">(</span><span class="string">&quot;Run time for STAGATE: &quot;</span><span class="punctuation">,</span> time.STAGATE<span class="punctuation">,</span> <span class="string">&quot;min&quot;</span><span class="punctuation">,</span><span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">time.methods <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>time.methods<span class="punctuation">,</span> time.STAGATE<span class="punctuation">)</span></span><br><span class="line">res.clustering<span class="operator">$</span>STAGATE <span class="operator">&lt;-</span> temp.STAGATE</span><br><span class="line">k <span class="operator">&lt;-</span> k <span class="operator">+</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>输出 STAGATE 的运行时间</li><li>把运行时间加入时间列表 <code>time.methods</code></li><li>把聚类标签结果 <code>temp.STAGATE</code> 保存进聚类结果列表 <code>res.clustering$STAGATE</code></li><li><code>k</code> 是用来统计或记录方法数量的变量，这里自增（可能用于 ensemble 阶段）</li></ul><hr><h3 id="4-检查是否有包含-na-的聚类方法清理无效结果"><a class="anchor" href="#4-检查是否有包含-na-的聚类方法清理无效结果">#</a> 🧼 4. 检查是否有包含 NA 的聚类方法，清理无效结果</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>time.methods<span class="punctuation">)</span> <span class="operator">&lt;-</span> Methods.used</span><br><span class="line">index.list <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="built_in">length</span><span class="punctuation">(</span>res.clustering<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  na.index <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>res.clustering<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span>na.index <span class="operator">!=</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    index.list <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>index.list<span class="punctuation">,</span> i<span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>将时间向量命名（与方法对应）</li><li>检查每种聚类方法的结果中是否存在 NA 值</li><li>如果某方法含 NA，就将其索引加入 <code>index.list</code></li></ul><hr><h3 id="5-删除含-na-的聚类方法"><a class="anchor" href="#5-删除含-na-的聚类方法">#</a> 🧽 5. 删除含 NA 的聚类方法</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">length</span><span class="punctuation">(</span>index.list<span class="punctuation">)</span> <span class="operator">!=</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  methods.names.tmp <span class="operator">&lt;-</span> <span class="built_in">names</span><span class="punctuation">(</span>res.clustering<span class="punctuation">)</span><span class="punctuation">[</span>index.list<span class="punctuation">]</span></span><br><span class="line">  <span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> methods.names.tmp<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    res.clustering<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="literal">NULL</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>若有 NA，获取含 NA 方法的名称</li><li>从结果列表中将其移除（设置为 NULL）</li></ul><hr><h3 id="6-聚类向量转为矩阵后续可用于-ensemble"><a class="anchor" href="#6-聚类向量转为矩阵后续可用于-ensemble">#</a> 📐 6. 聚类向量转为矩阵（后续可用于 ensemble）</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.clustering.matrix <span class="operator">&lt;-</span> lapply<span class="punctuation">(</span>res.clustering<span class="punctuation">,</span> clust2Mat<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><code>clust2Mat</code> ：将每种方法的聚类标签向量转换为 <strong>二值指示矩阵</strong>（每行一个样本，每列一个簇，1 表示属于某簇）</li></ul><hr><h3 id="7-打包最终结果为列表对象"><a class="anchor" href="#7-打包最终结果为列表对象">#</a> 📦 7. 打包最终结果为列表对象</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span></span><br><span class="line">  clustering.vec <span class="operator">=</span> res.clustering<span class="punctuation">,</span></span><br><span class="line">  clustering.mat <span class="operator">=</span> res.clustering.matrix<span class="punctuation">,</span></span><br><span class="line">  time <span class="operator">=</span> time.methods</span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>结构说明：</p><ul><li><code>clustering.vec</code> : 不同方法对应的聚类标签向量（含 STAGATE）</li><li><code>clustering.mat</code> : 聚类标签的二值表示矩阵（用于后续集成）</li><li><code>time</code> : 每种方法的运行时间</li></ul><hr><h3 id="8-可选保存结果到-rdata"><a class="anchor" href="#8-可选保存结果到-rdata">#</a> 💾 8. 可选保存结果到 <code>.RData</code></h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="punctuation">(</span>saving_results<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  cat<span class="punctuation">(</span><span class="string">&quot;Saving individual clustering analysis results...\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">  save<span class="punctuation">(</span>res<span class="punctuation">,</span> file <span class="operator">=</span> <span class="string">&quot;res.clustering.RData&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>如果 <code>saving_results = TRUE</code> ，则保存结果到 <code>res.clustering.RData</code> 文件</li></ul><hr><h3 id="9-返回最终聚类结果对象"><a class="anchor" href="#9-返回最终聚类结果对象">#</a> 🔚 9. 返回最终聚类结果对象</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span><span class="punctuation">(</span>res<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><hr><h2 id="总结一下这段代码做了什么"><a class="anchor" href="#总结一下这段代码做了什么">#</a> 🔁 总结一下这段代码做了什么？</h2><table><thead><tr><th>步骤</th><th>操作</th></tr></thead><tbody><tr><td>1</td><td>判断是否启用 STAGATE 方法</td></tr><tr><td>2</td><td>调用 <code>apply_STAGATE()</code> 聚类，记录时间</td></tr><tr><td>3</td><td>将结果保存到列表，统计运行时间</td></tr><tr><td>4</td><td>清除含 NA 的聚类方法结果</td></tr><tr><td>5</td><td>转换聚类结果为二值矩阵</td></tr><tr><td>6</td><td>打包为列表，保存到本地</td></tr><tr><td>7</td><td>返回聚类结果</td></tr></tbody></table><hr><p>如果你还想看看 <code>apply_STAGATE()</code> 的具体内容（即 STAGATE 是如何被调用、处理数据的），可以发我代码，我也可以逐行讲解！</p><p>或者你也可以告诉我，你是在哪个项目 / 代码库里看到的这些，比如是 EnSDD、SpaGCN 或其他空间分析工具～我可以更有针对性地解释模块设计逻辑。</p></div></details><details class="danger"><summary>clust2Mat</summary><div><p>clust2Mat: Function to compute adjacency matrix of cluster graph given a vector of cluster memberships<br>Description<br>Given a list of cluster memberships, this function computes the adjacency matrix for the associated cluster graph. The adjacency matrix is a matrix whose rows and columns are the nodes of the cluster graph and whose entries are 0's or 1's. A 1 entry indicates that the corresponding nodes are connected, and a 0 indocates that they are not.<br>Usage<br>clust2Mat(memb)<br>Arguments<br>memb<br>A numeric vector, with each entry representing a node, the entry's value being the number of the cluster to which that node belongs.<br>Value<br>Details<br>Given a vector of cluster membership numbers, where the number of entries is the number of nodes n, the function computes an nxn ``adjacency matrix'' for the corresponding cluster graph. The cluster graph is the graph in which two nodes are connected by an edge if and only if they are members of the same cluster. The adjacency matrix for the graph has rows and columns representing the nodes, in the same order as the input vector. The (i,j) entry is 1 if and only if node i and node j are in the same cluster. Otherwise, the entry is 0. By convention, diagonal entries are 0.</p></div></details><h2 id="spatial-domain-detection"><a class="anchor" href="#spatial-domain-detection">#</a> Spatial domain detection</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## setting the number of clustering equal to the annotation provided by SEDR</span></span><br><span class="line">library<span class="punctuation">(</span>reticulate<span class="punctuation">)</span></span><br><span class="line">reticulate<span class="operator">::</span>source_python<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;python&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Visualization_HBC_clustering.py&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;EnSDD&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">label_setting <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span> <span class="number">16</span><span class="punctuation">,</span> <span class="number">17</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">,</span> <span class="number">25</span><span class="punctuation">)</span></span><br><span class="line">sankey_df <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="built_in">length</span><span class="punctuation">(</span>label_setting<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  message<span class="punctuation">(</span>paste0<span class="punctuation">(</span><span class="string">&quot;Setting the number of clusters: &quot;</span><span class="punctuation">,</span> label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># res &lt;- run_individual_cluster(counts_path, loc_path, img_path, python_env, n_HVG = 2000, n_PCA = 30,                         number.setting.by.user = label_setting[i],</span></span><br><span class="line">  <span class="comment">#                               saving_results = TRUE)</span></span><br><span class="line">  <span class="comment"># save(res, file = paste0(&quot;./data/res_individual_&quot;, label_setting[i], &quot;_all.RData&quot;))</span></span><br><span class="line">  res.tmp <span class="operator">&lt;-</span> load<span class="punctuation">(</span>paste0<span class="punctuation">(</span><span class="string">&quot;../data/res_individual_&quot;</span><span class="punctuation">,</span> label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">,</span> <span class="string">&quot;_all.RData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">   assign<span class="punctuation">(</span><span class="string">&quot;res&quot;</span><span class="punctuation">,</span> get<span class="punctuation">(</span>res.tmp<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment">#### if the user want to integrate other SDD methods into EnSDD for ensemble, for example SiGra and spaVAE.</span></span><br><span class="line">  <span class="comment">### please refer to the following guideline</span></span><br><span class="line">  <span class="comment">### where the res represents the SDD results generated by EnSDD function run_individual_cluster </span></span><br><span class="line">  <span class="comment">### clustering_df represents the data frame, the row represents the samples and the column represents the labels generated by users. Cautious: the column need the names of the method setting by users. </span></span><br><span class="line">  <span class="comment">### For details, please load the data published on the Zenodo.</span></span><br><span class="line">  <span class="comment">#res_all &lt;- patch_deal(res, clustering_df) </span></span><br><span class="line">  </span><br><span class="line">  res.ensemble <span class="operator">&lt;-</span> solve_ensemble<span class="punctuation">(</span>res<span class="operator">$</span>clustering.mat<span class="punctuation">,</span> lambda <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> prob.quantile <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span> niter <span class="operator">=</span> <span class="number">100</span><span class="punctuation">,</span> epsilon <span class="operator">=</span> <span class="number">1e-5</span><span class="punctuation">)</span></span><br><span class="line">  </span><br><span class="line">  sim_net_louvain <span class="operator">&lt;-</span> res.ensemble<span class="operator">$</span>H</span><br><span class="line">  res.ensemble.clustering.louvain <span class="operator">&lt;-</span> Louvain_clustering_binary<span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span> similarity_mat <span class="operator">=</span> sim_net_louvain<span class="punctuation">,</span> setting_k <span class="operator">=</span> label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">,</span> max.res <span class="operator">=</span> <span class="number">8</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  meta_data <span class="operator">&lt;-</span> Seurat.data<span class="operator">@</span>meta.data</span><br><span class="line">  res.vec <span class="operator">&lt;-</span> res<span class="operator">$</span>clustering.vec</span><br><span class="line">  res.vec.df <span class="operator">&lt;-</span> as.data.frame<span class="punctuation">(</span>res.vec<span class="punctuation">)</span></span><br><span class="line">  res.vec.df<span class="operator">$</span>EnSDD <span class="operator">&lt;-</span> res.ensemble.clustering.louvain<span class="punctuation">[</span>rownames<span class="punctuation">(</span>meta_data<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">  </span><br><span class="line">  domain_name <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span><span class="string">&#x27;Domain_&#x27;</span><span class="punctuation">,</span> label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">  sankey_df<span class="punctuation">[[</span>domain_name<span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> res.ensemble.clustering.louvain<span class="punctuation">[</span>rownames<span class="punctuation">(</span>meta_data<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">  </span><br><span class="line">  meta_data_all <span class="operator">&lt;-</span> cbind<span class="punctuation">(</span>meta_data<span class="punctuation">,</span> res.vec.df<span class="punctuation">)</span></span><br><span class="line">  write.table<span class="punctuation">(</span>meta_data_all<span class="punctuation">,</span> file <span class="operator">=</span> paste0<span class="punctuation">(</span><span class="string">&quot;../data/clustering.res.&quot;</span><span class="punctuation">,</span> label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">,</span> <span class="string">&quot;.txt&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;\t&quot;</span><span class="punctuation">)</span></span><br><span class="line">  </span><br><span class="line">  meta_data_path <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span><span class="string">&quot;../data/clustering.res.&quot;</span><span class="punctuation">,</span> label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">,</span> <span class="string">&quot;.txt&quot;</span><span class="punctuation">)</span></span><br><span class="line">  visualization_clustering<span class="punctuation">(</span>counts_path<span class="punctuation">,</span> meta_data_path<span class="punctuation">,</span> img_path<span class="punctuation">,</span> cluster_num <span class="operator">=</span> <span class="built_in">as.integer</span><span class="punctuation">(</span>label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span> spot_diameter_fullres <span class="operator">=</span> <span class="number">150</span><span class="punctuation">,</span> spot_size <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># unlike(&#x27;res.clustering.txt&#x27;)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><details class="danger"><summary>Spatial doamin detection</summary><div><p>当然可以！我们一起来<strong>逐行解读</strong>这段代码，它的作用是：</p><blockquote><p><strong>基于多个聚类数量设置运行聚类分析，并可视化每种聚类结果（例如用于 EnSDD 的聚类 ensemble 处理）</strong>。</p></blockquote><p>它主要涉及：</p><ul><li>加载 Python 脚本（可视化）</li><li>读取多个不同聚类数下的聚类结果</li><li>做 ensemble 聚类（融合多个方法 / 模型结果）</li><li>用 Louvain 算法在相似度矩阵上聚类</li><li>存储结果并生成聚类可视化图像</li></ul><hr><h2 id="准备阶段"><a class="anchor" href="#准备阶段">#</a> 🔧 准备阶段</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## setting the number of clustering equal to the annotation provided by SEDR</span></span><br><span class="line">library<span class="punctuation">(</span>reticulate<span class="punctuation">)</span></span><br><span class="line">reticulate<span class="operator">::</span>source_python<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;python&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Visualization_HBC_clustering.py&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;EnSDD&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><code>reticulate</code> : 用于 R 调用 Python</li><li><code>source_python(...)</code> : 加载 Python 文件（用于空间聚类可视化 <code>visualization_clustering()</code> ）</li></ul><hr><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label_setting <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span> <span class="number">16</span><span class="punctuation">,</span> <span class="number">17</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">,</span> <span class="number">25</span><span class="punctuation">)</span></span><br><span class="line">sankey_df <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><code>label_setting</code> : 聚类数的多个设置（不同聚类簇个数）</li><li><code>sankey_df</code> : 用来保存每个设定下的聚类标签，可能用于后续的 <strong>Sankey plot 可视化流向图</strong></li></ul><hr><h2 id="遍历多个聚类数设定"><a class="anchor" href="#遍历多个聚类数设定">#</a> 🔁 遍历多个聚类数设定</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="built_in">length</span><span class="punctuation">(</span>label_setting<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  message<span class="punctuation">(</span>paste0<span class="punctuation">(</span><span class="string">&quot;Setting the number of clusters: &quot;</span><span class="punctuation">,</span> label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>逐个设置聚类簇数，准备执行后续流程。</p><hr><h2 id="加载已有的聚类结果-rdata"><a class="anchor" href="#加载已有的聚类结果-rdata">#</a> 📦 加载已有的聚类结果 <code>.RData</code></h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.tmp <span class="operator">&lt;-</span> load<span class="punctuation">(</span>paste0<span class="punctuation">(</span><span class="string">&quot;../data/res_individual_&quot;</span><span class="punctuation">,</span> label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">,</span> <span class="string">&quot;_all.RData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">assign<span class="punctuation">(</span><span class="string">&quot;res&quot;</span><span class="punctuation">,</span> get<span class="punctuation">(</span>res.tmp<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>加载保存好的结果文件</li><li>结果中保存了 <code>clustering.mat</code> （聚类标签矩阵）和 <code>clustering.vec</code> （单一聚类标签向量）</li></ul><hr><h2 id="聚类结果融合ensemble"><a class="anchor" href="#聚类结果融合ensemble">#</a> 🧠 聚类结果融合（Ensemble）</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.ensemble <span class="operator">&lt;-</span> solve_ensemble<span class="punctuation">(</span>res<span class="operator">$</span>clustering.mat<span class="punctuation">,</span> lambda <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> prob.quantile <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span> niter <span class="operator">=</span> <span class="number">100</span><span class="punctuation">,</span> epsilon <span class="operator">=</span> <span class="number">1e-5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>使用 <code>solve_ensemble()</code> 函数对聚类矩阵做 <strong>集成聚类融合</strong>：</p><ul><li><code>clustering.mat</code> : 多模型、多参数下的聚类标签（行：spot，列：不同聚类方案）</li><li>输出 <code>res.ensemble$H</code> : 相似度矩阵（用于后续 Louvain 聚类）</li></ul><hr><h2 id="louvain-聚类基于集成的相似度网络"><a class="anchor" href="#louvain-聚类基于集成的相似度网络">#</a> 📊 Louvain 聚类（基于集成的相似度网络）</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sim_net_louvain <span class="operator">&lt;-</span> res.ensemble<span class="operator">$</span>H</span><br><span class="line">res.ensemble.clustering.louvain <span class="operator">&lt;-</span> Louvain_clustering_binary<span class="punctuation">(</span>Seurat.data<span class="punctuation">,</span> similarity_mat <span class="operator">=</span> sim_net_louvain<span class="punctuation">,</span> setting_k <span class="operator">=</span> label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">,</span> max.res <span class="operator">=</span> <span class="number">8</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>Louvain_clustering_binary()</code> 对相似度矩阵 <code>H</code> 进行社区检测（聚类）</li><li><code>setting_k</code> : 目标聚类数</li><li><code>max.res</code> : 最大分辨率（控制 Louvain 聚类是否更细或更粗）</li></ul><hr><h2 id="聚类结果格式化并保存"><a class="anchor" href="#聚类结果格式化并保存">#</a> 📝 聚类结果格式化并保存</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meta_data <span class="operator">&lt;-</span> Seurat.data<span class="operator">@</span>meta.data</span><br><span class="line">res.vec <span class="operator">&lt;-</span> res<span class="operator">$</span>clustering.vec</span><br><span class="line">res.vec.df <span class="operator">&lt;-</span> as.data.frame<span class="punctuation">(</span>res.vec<span class="punctuation">)</span></span><br><span class="line">res.vec.df<span class="operator">$</span>EnSDD <span class="operator">&lt;-</span> res.ensemble.clustering.louvain<span class="punctuation">[</span>rownames<span class="punctuation">(</span>meta_data<span class="punctuation">)</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><ul><li>构造一个包含两个聚类标签的 data frame：<ul><li>原始标签： <code>res.vec</code></li><li>融合聚类标签（EnSDD 集成结果）： <code>res.ensemble.clustering.louvain</code></li></ul></li></ul><hr><h2 id="结果写入文件并加入总表"><a class="anchor" href="#结果写入文件并加入总表">#</a> 🗂 结果写入文件并加入总表</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">domain_name <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span><span class="string">&#x27;Domain_&#x27;</span><span class="punctuation">,</span> label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">sankey_df<span class="punctuation">[[</span>domain_name<span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> res.ensemble.clustering.louvain<span class="punctuation">[</span>rownames<span class="punctuation">(</span>meta_data<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">meta_data_all <span class="operator">&lt;-</span> cbind<span class="punctuation">(</span>meta_data<span class="punctuation">,</span> res.vec.df<span class="punctuation">)</span></span><br><span class="line">write.table<span class="punctuation">(</span>meta_data_all<span class="punctuation">,</span> file <span class="operator">=</span> paste0<span class="punctuation">(</span><span class="string">&quot;../data/clustering.res.&quot;</span><span class="punctuation">,</span> label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">,</span> <span class="string">&quot;.txt&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;\t&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>把每个聚类设定的集成标签加入 <code>sankey_df</code> ，方便后续绘制 Sankey 流图</li><li>将聚类结果保存为 <code>.txt</code> 文件，以便后续可视化或分析</li></ul><hr><h2 id="调用-python-进行聚类可视化"><a class="anchor" href="#调用-python-进行聚类可视化">#</a> 🖼 调用 Python 进行聚类可视化</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meta_data_path <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span><span class="string">&quot;../data/clustering.res.&quot;</span><span class="punctuation">,</span> label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">,</span> <span class="string">&quot;.txt&quot;</span><span class="punctuation">)</span></span><br><span class="line">visualization_clustering<span class="punctuation">(</span>counts_path<span class="punctuation">,</span> meta_data_path<span class="punctuation">,</span> img_path<span class="punctuation">,</span></span><br><span class="line">                         cluster_num <span class="operator">=</span> <span class="built_in">as.integer</span><span class="punctuation">(</span>label_setting<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                         spot_diameter_fullres <span class="operator">=</span> <span class="number">150</span><span class="punctuation">,</span></span><br><span class="line">                         spot_size <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>使用之前加载的 <code>Visualization_HBC_clustering.py</code> 中的 <code>visualization_clustering()</code> ：</p><ul><li>输入：<ul><li>表达数据（ <code>counts_path</code> ）</li><li>聚类结果路径</li><li>图像路径</li></ul></li><li>输出：空间聚类的图像（spot 被聚类标签着色）</li></ul><hr><h2 id="清理注释掉"><a class="anchor" href="#清理注释掉">#</a> 🧹 清理（注释掉）</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># unlike(&#x27;res.clustering.txt&#x27;)</span></span><br></pre></td></tr></table></figure><p>这行可能是个笔误或作者写错了，可能本意是 <code>unlink()</code> 删除文件。</p><hr><h2 id="总结一句话-3"><a class="anchor" href="#总结一句话-3">#</a> ✅ 总结一句话：</h2><blockquote><p>该代码是为了测试多个聚类簇数设置下的空间聚类效果，结合 EnSDD 的聚类融合方法和 Python 的可视化函数，输出空间聚类图和标签，为后续分析（如 Sankey plot）做准备。</p></blockquote><hr><p>如果你有任何一个函数想继续详细分析（比如 <code>solve_ensemble()</code> 或 <code>visualization_clustering()</code> 的内部逻辑），可以发我，我继续给你拆解！😎</p></div></details><h2 id="solve_ensemble-关键"><a class="anchor" href="#solve_ensemble-关键">#</a> solve_ensemble 关键</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">solve_ensemble <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> lambda <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> prob.quantile <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                           niter <span class="operator">=</span> <span class="number">100</span><span class="punctuation">,</span> epsilon <span class="operator">=</span> <span class="number">1e-5</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  options<span class="punctuation">(</span>digits <span class="operator">=</span> <span class="number">7</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># Results.clustering &lt;- Results.clustering.all[[1]]</span></span><br><span class="line">  num.methods <span class="operator">&lt;-</span> <span class="built_in">length</span><span class="punctuation">(</span>Results.clustering<span class="punctuation">)</span></span><br><span class="line">  num.spots <span class="operator">&lt;-</span> nrow<span class="punctuation">(</span>Results.clustering<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">  num.cell.type <span class="operator">&lt;-</span> ncol<span class="punctuation">(</span>Results.clustering<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## initialization V by the mean of individual values</span></span><br><span class="line">  w <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">/</span>num.methods<span class="punctuation">,</span> num.methods<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  H <span class="operator">&lt;-</span>  Reduce<span class="punctuation">(</span><span class="string">&quot;+&quot;</span><span class="punctuation">,</span> Map<span class="punctuation">(</span><span class="string">&quot;*&quot;</span><span class="punctuation">,</span> Results.clustering<span class="punctuation">,</span> w<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">is.null</span><span class="punctuation">(</span>lambda<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;We will adpote a value for lambda in our algorithm...&quot;</span><span class="punctuation">,</span> <span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  k <span class="operator">&lt;-</span> 1</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="punctuation">(</span>k <span class="operator">&lt;=</span> niter<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="keyword">if</span><span class="punctuation">(</span>k <span class="operator">==</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">      loss_all_temp <span class="operator">&lt;-</span> 0</span><br><span class="line">      temp2 <span class="operator">&lt;-</span>  sapply<span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> L2_norm<span class="punctuation">,</span> Y <span class="operator">=</span> H<span class="punctuation">)</span></span><br><span class="line">      <span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">is.null</span><span class="punctuation">(</span>lambda<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">        lambda <span class="operator">&lt;-</span> quantile<span class="punctuation">(</span>temp2<span class="punctuation">,</span> probs <span class="operator">=</span> prob.quantile<span class="punctuation">)</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="keyword">else</span><span class="punctuation">&#123;</span></span><br><span class="line">      loss_all_temp <span class="operator">&lt;-</span> loss_all</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="comment">##### update w</span></span><br><span class="line">    temp2 <span class="operator">&lt;-</span>  sapply<span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> L2_norm<span class="punctuation">,</span> Y <span class="operator">=</span> H<span class="punctuation">)</span></span><br><span class="line">    w <span class="operator">&lt;-</span> <span class="built_in">exp</span><span class="punctuation">(</span><span class="operator">-</span>temp2<span class="operator">/</span>lambda<span class="punctuation">)</span><span class="operator">/</span><span class="built_in">sum</span><span class="punctuation">(</span><span class="built_in">exp</span><span class="punctuation">(</span><span class="operator">-</span>temp2<span class="operator">/</span>lambda<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    H <span class="operator">&lt;-</span>  Reduce<span class="punctuation">(</span><span class="string">&quot;+&quot;</span><span class="punctuation">,</span> Map<span class="punctuation">(</span><span class="string">&quot;*&quot;</span><span class="punctuation">,</span> Results.clustering<span class="punctuation">,</span> w<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">    loss_main <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>sapply<span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> L2_norm<span class="punctuation">,</span> Y <span class="operator">=</span> H<span class="punctuation">)</span> <span class="operator">*</span> w<span class="punctuation">)</span></span><br><span class="line">    loss_entropy <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>w <span class="operator">*</span> <span class="built_in">log</span><span class="punctuation">(</span>w<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    loss_all <span class="operator">&lt;-</span> loss_main <span class="operator">+</span> lambda <span class="operator">*</span> loss_entropy</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cat(&quot;iter: &quot;, k, &quot;loss_main: &quot;, loss_main, &quot;loss_entropy: &quot;, loss_entropy,</span></span><br><span class="line">    <span class="comment">#     &quot;loss_all: &quot;, loss_all, &quot;lambda: &quot;, lambda, &quot;\n&quot;)</span></span><br><span class="line">    <span class="keyword">if</span><span class="punctuation">(</span>k <span class="operator">==</span> niter<span class="punctuation">)</span></span><br><span class="line">      cat<span class="punctuation">(</span><span class="string">&quot;The method maybe not convergens, the algorithm need an larger max_epoches!&quot;</span><span class="punctuation">,</span> <span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">    diff_iter <span class="operator">&lt;-</span> <span class="built_in">abs</span><span class="punctuation">(</span>loss_all <span class="operator">-</span> loss_all_temp<span class="punctuation">)</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;iter: &quot;</span><span class="punctuation">,</span> k<span class="punctuation">,</span> <span class="string">&quot;loss_main: &quot;</span><span class="punctuation">,</span> loss_main<span class="punctuation">,</span> <span class="string">&quot;loss_entropy: &quot;</span><span class="punctuation">,</span> loss_entropy<span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;loss_all: &quot;</span><span class="punctuation">,</span> loss_all<span class="punctuation">,</span> <span class="string">&quot;lambda: &quot;</span><span class="punctuation">,</span> lambda<span class="punctuation">,</span> <span class="string">&quot;diff&quot;</span><span class="punctuation">,</span></span><br><span class="line">        diff_iter<span class="punctuation">,</span> <span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span><span class="punctuation">(</span>diff_iter <span class="operator">&lt;</span> epsilon <span class="operator">|</span> k <span class="operator">&gt;=</span> niter<span class="punctuation">)</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    k <span class="operator">&lt;-</span> k <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  colnames<span class="punctuation">(</span>H<span class="punctuation">)</span> <span class="operator">&lt;-</span> colnames<span class="punctuation">(</span>Results.clustering<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>H <span class="operator">=</span> H<span class="punctuation">,</span> w <span class="operator">=</span> w<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><details class="danger"><summary>solve_ensemble</summary><div><p>好呀！我们来详细解读一下这个 <code>solve_ensemble</code> 函数 —— 它实现的是一个聚类<strong>集成（Ensemble Clustering）<strong>方法，用于融合多个聚类结果，输出一个</strong>共识相似度矩阵</strong> <code>H</code> ，并自动学习每个聚类结果的权重 <code>w</code> 。</p><hr><h2 id="目标简述"><a class="anchor" href="#目标简述">#</a> 🧠 目标简述</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solve_ensemble<span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>输入：多个聚类方法生成的<strong>样本 - 样本相似度矩阵</strong>（比如你前面问过的 <code>clust2Mat</code> 转换出来的）</li><li>输出：<ul><li><code>H</code> ：最终融合后的相似度矩阵（作为新的聚类输入）</li><li><code>w</code> ：每个方法的权重（表示该方法对最终共识的贡献程度）</li></ul></li></ul><p>该方法基于一个<strong>优化目标</strong>，使用迭代优化来寻找最合适的加权平均。</p><hr><h2 id="输入参数说明"><a class="anchor" href="#输入参数说明">#</a> 📥 输入参数说明</h2><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>Results.clustering</code></td><td><code>list</code> 类型，多个方法生成的相似度矩阵，每个元素是一个 N×N 矩阵</td></tr><tr><td><code>lambda</code></td><td>平衡主损失项和熵正则项的超参数，如果为空，会根据分布自适应选择</td></tr><tr><td><code>prob.quantile</code></td><td>用于估计 <code>lambda</code> 的分位数（默认 0.5，代表中位数）</td></tr><tr><td><code>niter</code></td><td>最多迭代次数</td></tr><tr><td><code>epsilon</code></td><td>收敛判据：两次迭代的总损失变化小于这个值时停止</td></tr></tbody></table><hr><h2 id="算法结构详解"><a class="anchor" href="#算法结构详解">#</a> 🔧 算法结构详解</h2><hr><h3 id="1-参数初始化"><a class="anchor" href="#1-参数初始化">#</a> 1. 参数初始化</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num.methods <span class="operator">&lt;-</span> <span class="built_in">length</span><span class="punctuation">(</span>Results.clustering<span class="punctuation">)</span></span><br><span class="line">num.spots <span class="operator">&lt;-</span> nrow<span class="punctuation">(</span>Results.clustering<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">num.cell.type <span class="operator">&lt;-</span> ncol<span class="punctuation">(</span>Results.clustering<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>拿到方法数量、样本数、细胞类型数（实际没用）。</p><hr><h3 id="2-初始化权重和共识矩阵"><a class="anchor" href="#2-初始化权重和共识矩阵">#</a> 2. 初始化权重和共识矩阵</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w <span class="operator">&lt;-</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span> <span class="operator">/</span> num.methods<span class="punctuation">,</span> num.methods<span class="punctuation">)</span>  <span class="comment"># 初始权重平均</span></span><br><span class="line">H <span class="operator">&lt;-</span> Reduce<span class="punctuation">(</span><span class="string">&quot;+&quot;</span><span class="punctuation">,</span> Map<span class="punctuation">(</span><span class="string">&quot;*&quot;</span><span class="punctuation">,</span> Results.clustering<span class="punctuation">,</span> w<span class="punctuation">)</span><span class="punctuation">)</span>  <span class="comment"># 加权平均得到初始共识矩阵</span></span><br></pre></td></tr></table></figure><p>📌 <strong>共识矩阵 <code>H</code> 是多个相似度矩阵的加权平均</strong>。</p><hr><h3 id="3-计算初始-loss-和-lambda如未指定"><a class="anchor" href="#3-计算初始-loss-和-lambda如未指定">#</a> 3. 计算初始 loss 和 lambda（如未指定）</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temp2 <span class="operator">&lt;-</span> sapply<span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> L2_norm<span class="punctuation">,</span> Y <span class="operator">=</span> H<span class="punctuation">)</span></span><br><span class="line"><span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">is.null</span><span class="punctuation">(</span>lambda<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    lambda <span class="operator">&lt;-</span> quantile<span class="punctuation">(</span>temp2<span class="punctuation">,</span> probs <span class="operator">=</span> prob.quantile<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>temp2</code> 是每个方法和当前共识矩阵之间的 <strong>L2 距离（差异）</strong>。</li><li>如果没有指定 <code>lambda</code> ，就根据这些距离的分布自适应选一个中位数。</li></ul><hr><h3 id="4-主循环迭代优化权重和共识矩阵"><a class="anchor" href="#4-主循环迭代优化权重和共识矩阵">#</a> 4. 主循环：迭代优化权重和共识矩阵</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="punctuation">(</span>k <span class="operator">&lt;=</span> niter<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>每一轮迭代包括 3 步：</p><h4 id="步骤1更新权重"><a class="anchor" href="#步骤1更新权重">#</a> 🌀 步骤 1：更新权重</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp2 <span class="operator">&lt;-</span> sapply<span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> L2_norm<span class="punctuation">,</span> Y <span class="operator">=</span> H<span class="punctuation">)</span></span><br><span class="line">w <span class="operator">&lt;-</span> <span class="built_in">exp</span><span class="punctuation">(</span><span class="operator">-</span>temp2<span class="operator">/</span>lambda<span class="punctuation">)</span><span class="operator">/</span><span class="built_in">sum</span><span class="punctuation">(</span><span class="built_in">exp</span><span class="punctuation">(</span><span class="operator">-</span>temp2<span class="operator">/</span>lambda<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>越接近 <code>H</code> 的聚类方法，其权重 <code>w</code> 越大。</li><li>形式上是 Softmax，受 <code>lambda</code> 控制平滑程度。</li></ul><h4 id="步骤2更新共识矩阵"><a class="anchor" href="#步骤2更新共识矩阵">#</a> 🌀 步骤 2：更新共识矩阵</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H <span class="operator">&lt;-</span> Reduce<span class="punctuation">(</span><span class="string">&quot;+&quot;</span><span class="punctuation">,</span> Map<span class="punctuation">(</span><span class="string">&quot;*&quot;</span><span class="punctuation">,</span> Results.clustering<span class="punctuation">,</span> w<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>用新的权重对所有相似度矩阵加权平均。</li></ul><h4 id="步骤3计算损失函数"><a class="anchor" href="#步骤3计算损失函数">#</a> 🌀 步骤 3：计算损失函数</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loss_main <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>sapply<span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> L2_norm<span class="punctuation">,</span> Y <span class="operator">=</span> H<span class="punctuation">)</span> <span class="operator">*</span> w<span class="punctuation">)</span></span><br><span class="line">loss_entropy <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>w <span class="operator">*</span> <span class="built_in">log</span><span class="punctuation">(</span>w<span class="punctuation">)</span><span class="punctuation">)</span>  <span class="comment"># 熵惩罚项</span></span><br><span class="line">loss_all <span class="operator">&lt;-</span> loss_main <span class="operator">+</span> lambda <span class="operator">*</span> loss_entropy</span><br></pre></td></tr></table></figure><ul><li>主损失 <code>loss_main</code> ：共识矩阵和原始方法之间的加权差异</li><li>正则项 <code>loss_entropy</code> ：鼓励权重分布均匀，避免过拟合</li><li>总损失是两者的加权和</li></ul><hr><h3 id="5-收敛判断与跳出循环"><a class="anchor" href="#5-收敛判断与跳出循环">#</a> 5. 收敛判断与跳出循环</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diff_iter <span class="operator">&lt;-</span> <span class="built_in">abs</span><span class="punctuation">(</span>loss_all <span class="operator">-</span> loss_all_temp<span class="punctuation">)</span></span><br><span class="line"><span class="keyword">if</span><span class="punctuation">(</span>diff_iter <span class="operator">&lt;</span> epsilon <span class="operator">|</span> k <span class="operator">&gt;=</span> niter<span class="punctuation">)</span></span><br><span class="line">  <span class="keyword">break</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-返回结果"><a class="anchor" href="#6-返回结果">#</a> 6. 返回结果</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>H <span class="operator">=</span> H<span class="punctuation">,</span> w <span class="operator">=</span> w<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><hr><h2 id="最终输出解释"><a class="anchor" href="#最终输出解释">#</a> ✅ 最终输出解释</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span><span class="punctuation">(</span></span><br><span class="line">  H <span class="operator">=</span> 聚类共识相似度矩阵<span class="punctuation">,</span></span><br><span class="line">  w <span class="operator">=</span> 各方法权重向量</span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>你可以把 <code>H</code> 当作一个新的样本之间的相似度矩阵，再送入例如 Louvain 聚类、谱聚类等进一步聚类分析中。</p><hr><h2 id="总结一张图逻辑结构"><a class="anchor" href="#总结一张图逻辑结构">#</a> 📌 总结一张图（逻辑结构）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">多种聚类结果（A, B, C...） =&gt; [相似度矩阵1, 2, 3...]</span><br><span class="line"></span><br><span class="line">初始化：</span><br><span class="line">    权重 w = 平均</span><br><span class="line">    共识矩阵 H = w 加权求和</span><br><span class="line"></span><br><span class="line">迭代：</span><br><span class="line">    1. 计算每个方法与 H 的距离（L2）</span><br><span class="line">    2. Softmax 更新权重 w</span><br><span class="line">    3. 用 w 更新共识矩阵 H</span><br><span class="line">    4. 计算损失函数：L2 + 熵</span><br><span class="line">    5. 检查收敛条件（loss 差值 &lt; ε）</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">    - 最终共识矩阵 H</span><br><span class="line">    - 每个方法的权重 w</span><br></pre></td></tr></table></figure><hr><p>如果你也想看 <code>L2_norm</code> 这个函数我也可以帮你查或分析下～</p></div></details><h2 id="utils"><a class="anchor" href="#utils">#</a> utils</h2><h3 id="data_process"><a class="anchor" href="#data_process">#</a> data_process</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">data_process <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>counts_path<span class="punctuation">,</span> loc_path<span class="punctuation">,</span> img_path<span class="punctuation">,</span> n_HVG <span class="operator">=</span> <span class="number">2000</span><span class="punctuation">,</span> n_PCA <span class="operator">=</span> <span class="number">20</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">### input counts file</span></span><br><span class="line">  counts <span class="operator">=</span> read.table<span class="punctuation">(</span>counts_path<span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&#x27;\t&#x27;</span><span class="punctuation">)</span></span><br><span class="line">  counts_ST <span class="operator">&lt;-</span> as.matrix<span class="punctuation">(</span>counts<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">### input location file</span></span><br><span class="line">  coordinates <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>read.table<span class="punctuation">(</span>loc_path<span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&#x27;\t&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  colnames<span class="punctuation">(</span>counts_ST<span class="punctuation">)</span> <span class="operator">&lt;-</span> rownames<span class="punctuation">(</span>coordinates<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">### create Seurat object</span></span><br><span class="line">  suppressWarnings<span class="punctuation">(</span><span class="punctuation">&#123;</span>Seurat.ST <span class="operator">&lt;-</span> Seurat<span class="operator">::</span>CreateSeuratObject<span class="punctuation">(</span>counts <span class="operator">=</span> counts_ST<span class="punctuation">,</span> assay <span class="operator">=</span> <span class="string">&quot;Spatial&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                                            meta.data <span class="operator">=</span> coordinates<span class="punctuation">)</span><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line">  Seurat.ST <span class="operator">&lt;-</span> Seurat<span class="operator">::</span>SCTransform<span class="punctuation">(</span>Seurat.ST<span class="punctuation">,</span> assay <span class="operator">=</span> <span class="string">&quot;Spatial&quot;</span><span class="punctuation">,</span> verbose <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">### select HVG genes</span></span><br><span class="line">  Seurat.ST <span class="operator">&lt;-</span> Seurat<span class="operator">::</span>FindVariableFeatures<span class="punctuation">(</span>Seurat.ST<span class="punctuation">,</span> nfeatures <span class="operator">=</span> n_HVG<span class="punctuation">,</span> verbose <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment">### PCA</span></span><br><span class="line">  Seurat.ST <span class="operator">&lt;-</span> Seurat<span class="operator">::</span>ScaleData<span class="punctuation">(</span>Seurat.ST<span class="punctuation">,</span> verbose <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">  Seurat.ST <span class="operator">&lt;-</span> Seurat<span class="operator">::</span>RunPCA<span class="punctuation">(</span>Seurat.ST<span class="punctuation">,</span> npcs <span class="operator">=</span> n_PCA<span class="punctuation">,</span> verbose <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  data.list <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span>counts_path <span class="operator">=</span> counts_path<span class="punctuation">,</span> loc_path <span class="operator">=</span> loc_path<span class="punctuation">,</span> img_path <span class="operator">=</span> img_path<span class="punctuation">)</span></span><br><span class="line">  Seurat.ST<span class="operator">@</span>images <span class="operator">&lt;-</span> data.list</span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>Seurat.ST<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><details class="danger"><summary>dataprocess</summary><div><p>这段 R 代码定义了一个用于空间转录组数据预处理的函数 <code>data_process</code> 。它使用了 Seurat 包来创建 Seurat 对象并执行标准的数据预处理流程（如标准化、变量基因筛选、PCA）。下面是对这段代码逐行的详细解析：</p><hr><h3 id="函数定义"><a class="anchor" href="#函数定义">#</a> 🔧 函数定义</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_process <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>counts_path<span class="punctuation">,</span> loc_path<span class="punctuation">,</span> img_path<span class="punctuation">,</span> n_HVG <span class="operator">=</span> <span class="number">2000</span><span class="punctuation">,</span> n_PCA <span class="operator">=</span> <span class="number">20</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>定义了一个函数 <code>data_process</code> ，接受以下参数：</p><ul><li><code>counts_path</code> ：表达矩阵的路径（行是基因，列是空间点）</li><li><code>loc_path</code> ：空间位置信息的路径（spot 坐标）</li><li><code>img_path</code> ：图片路径，暂时没被实际读取</li><li><code>n_HVG</code> ：选择多少个高变异基因（默认 2000）</li><li><code>n_PCA</code> ：使用多少主成分进行 PCA（默认 20）</li></ul><hr><h3 id="读取表达矩阵"><a class="anchor" href="#读取表达矩阵">#</a> 📂 读取表达矩阵</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counts <span class="operator">=</span> read.table<span class="punctuation">(</span>counts_path<span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&#x27;\t&#x27;</span><span class="punctuation">)</span></span><br><span class="line">counts_ST <span class="operator">&lt;-</span> as.matrix<span class="punctuation">(</span>counts<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>读取表达矩阵文件，并转为矩阵形式。假设行为基因、列为空间点（spot）。</p><hr><h3 id="读取坐标信息"><a class="anchor" href="#读取坐标信息">#</a> 📍 读取坐标信息</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coordinates <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>read.table<span class="punctuation">(</span>loc_path<span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&#x27;\t&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>读取空间坐标信息，通常包含每个 spot 的 <code>x</code> , <code>y</code> 坐标。</p><hr><h3 id="对齐-counts-和坐标"><a class="anchor" href="#对齐-counts-和坐标">#</a> 🧬 对齐 counts 和坐标</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colnames<span class="punctuation">(</span>counts_ST<span class="punctuation">)</span> <span class="operator">&lt;-</span> rownames<span class="punctuation">(</span>coordinates<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>将 <code>counts_ST</code> 的列名设置为空间坐标的 rownames，确保表达矩阵的列与坐标信息对齐。</p><hr><h3 id="创建-seurat-对象"><a class="anchor" href="#创建-seurat-对象">#</a> 🔬 创建 Seurat 对象</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">suppressWarnings<span class="punctuation">(</span><span class="punctuation">&#123;</span></span><br><span class="line">  Seurat.ST <span class="operator">&lt;-</span> Seurat<span class="operator">::</span>CreateSeuratObject<span class="punctuation">(</span>counts <span class="operator">=</span> counts_ST<span class="punctuation">,</span> assay <span class="operator">=</span> <span class="string">&quot;Spatial&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                          meta.data <span class="operator">=</span> coordinates<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>用表达矩阵和空间坐标创建一个 Seurat 对象，使用 <code>Spatial</code> 作为 assay 名称，并把坐标作为元数据添加进去。</p><hr><h3 id="标准化处理"><a class="anchor" href="#标准化处理">#</a> 📊 标准化处理</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Seurat.ST <span class="operator">&lt;-</span> Seurat<span class="operator">::</span>SCTransform<span class="punctuation">(</span>Seurat.ST<span class="punctuation">,</span> assay <span class="operator">=</span> <span class="string">&quot;Spatial&quot;</span><span class="punctuation">,</span> verbose <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>使用 <code>SCTransform</code> 对数据进行标准化，这是一种较新的标准化方法，比传统的 <code>NormalizeData</code> 更鲁棒。</p><hr><h3 id="高变异基因选择"><a class="anchor" href="#高变异基因选择">#</a> 📈 高变异基因选择</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Seurat.ST <span class="operator">&lt;-</span> Seurat<span class="operator">::</span>FindVariableFeatures<span class="punctuation">(</span>Seurat.ST<span class="punctuation">,</span> nfeatures <span class="operator">=</span> n_HVG<span class="punctuation">,</span> verbose <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>从标准化后的数据中选择 <code>n_HVG</code> 个高变异基因（默认 2000 个）。</p><hr><h3 id="pca降维"><a class="anchor" href="#pca降维">#</a> 📐 PCA 降维</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Seurat.ST <span class="operator">&lt;-</span> Seurat<span class="operator">::</span>ScaleData<span class="punctuation">(</span>Seurat.ST<span class="punctuation">,</span> verbose <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">Seurat.ST <span class="operator">&lt;-</span> Seurat<span class="operator">::</span>RunPCA<span class="punctuation">(</span>Seurat.ST<span class="punctuation">,</span> npcs <span class="operator">=</span> n_PCA<span class="punctuation">,</span> verbose <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>先对数据标准化（center &amp; scale），再进行 PCA 降维，保留 <code>n_PCA</code> 个主成分。</p><hr><h3 id="️-处理图片信息未使用"><a class="anchor" href="#️-处理图片信息未使用">#</a> 🖼️ 处理图片信息（未使用）</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data.list <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span>counts_path <span class="operator">=</span> counts_path<span class="punctuation">,</span> loc_path <span class="operator">=</span> loc_path<span class="punctuation">,</span> img_path <span class="operator">=</span> img_path<span class="punctuation">)</span></span><br><span class="line">Seurat.ST<span class="operator">@</span>images <span class="operator">&lt;-</span> data.list</span><br></pre></td></tr></table></figure><p>将文件路径信息存储到 <code>Seurat.ST@images</code> 槽中。注意这里并没有真正读入图像，只是把路径作为一个列表存进去。如果后续不使用这个结构，可能没太大意义。</p><hr><h3 id="返回结果-2"><a class="anchor" href="#返回结果-2">#</a> 🔁 返回结果</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span><span class="punctuation">(</span>Seurat.ST<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>返回预处理后的 Seurat 对象。</p><hr><h3 id="总结-3"><a class="anchor" href="#总结-3">#</a> ✅ 总结</h3><p>这是一个用于空间转录组数据预处理的函数，完成了以下几步：</p><ol><li><strong>读取表达矩阵与坐标</strong></li><li><strong>创建 Seurat 对象</strong></li><li><strong>SCTransform 标准化</strong></li><li><strong>选择高变异基因</strong></li><li><strong>PCA 降维</strong></li><li><strong>保存原始路径信息到 Seurat 对象中</strong></li></ol><p>如你后续要加上图像处理功能（例如和 histology 图像配准），可以使用 <code>Read10X_Image()</code> 或 <code>ReadImage()</code> 之类的方法来真正地载入图像。</p><hr><p>如果你有具体的输入数据结构（比如坐标文件长什么样），我也可以帮你判断这段代码是否能跑通，或者怎么修改以适应不同的数据来源。你想继续深入看看这部分吗？</p></div></details><h3 id="clust2mat"><a class="anchor" href="#clust2mat">#</a> clust2Mat</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clust2Mat <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>memb<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  N <span class="operator">&lt;-</span> <span class="built_in">length</span><span class="punctuation">(</span>memb<span class="punctuation">)</span></span><br><span class="line">  mat_cn <span class="operator">&lt;-</span> <span class="built_in">as.numeric</span><span class="punctuation">(</span>outer<span class="punctuation">(</span>memb<span class="punctuation">,</span> memb<span class="punctuation">,</span> FUN <span class="operator">=</span> <span class="string">&quot;==&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-</span> outer<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span>N<span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span>N<span class="punctuation">,</span> <span class="string">&quot;==&quot;</span><span class="punctuation">)</span></span><br><span class="line">  rownames<span class="punctuation">(</span>mat_cn<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">names</span><span class="punctuation">(</span>memb<span class="punctuation">)</span></span><br><span class="line">  colnames<span class="punctuation">(</span>mat_cn<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">names</span><span class="punctuation">(</span>memb<span class="punctuation">)</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>mat_cn<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><details class="danger"><summary>clust2Mat</summary><div><p>这段 R 代码定义了一个名为 <code>clust2Mat</code> 的函数，用于把<strong>聚类标签（cluster membership）向量</strong>转换成一个 <strong>共聚类关系矩阵</strong>。下面我们来逐步分析：</p><hr><h3 id="函数定义-2"><a class="anchor" href="#函数定义-2">#</a> 🔧 函数定义</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clust2Mat <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>memb<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br></pre></td></tr></table></figure><ul><li><code>memb</code> 是一个向量，表示每个样本的聚类标签。<ul><li>可以是一个<strong>具名向量</strong>（比如 <code>names(memb)</code> 是样本名）。</li><li>每个元素的值是对应样本所属的聚类编号。</li></ul></li></ul><hr><h3 id="获取样本数量"><a class="anchor" href="#获取样本数量">#</a> 📏 获取样本数量</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N <span class="operator">&lt;-</span> <span class="built_in">length</span><span class="punctuation">(</span>memb<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>获取一共多少个样本（即多少个聚类成员）。</li></ul><hr><h3 id="构造共聚类矩阵"><a class="anchor" href="#构造共聚类矩阵">#</a> 📐 构造共聚类矩阵</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mat_cn <span class="operator">&lt;-</span> <span class="built_in">as.numeric</span><span class="punctuation">(</span>outer<span class="punctuation">(</span>memb<span class="punctuation">,</span> memb<span class="punctuation">,</span> FUN <span class="operator">=</span> <span class="string">&quot;==&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-</span> outer<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span>N<span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span>N<span class="punctuation">,</span> <span class="string">&quot;==&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>这是核心逻辑。逐步拆解如下：</p><h4 id="outermemb-memb-fun"><a class="anchor" href="#outermemb-memb-fun">#</a> ✅ <code>outer(memb, memb, FUN = &quot;==&quot;)</code></h4><ul><li>构造一个 <code>N x N</code> 的矩阵，表示每对样本是否属于<strong>同一个聚类</strong>。</li><li>例如，如果 <code>memb = c(&quot;A&quot; = 1, &quot;B&quot; = 1, &quot;C&quot; = 2)</code> ，则结果是：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     A     B     C</span><br><span class="line">A  TRUE  TRUE  FALSE</span><br><span class="line">B  TRUE  TRUE  FALSE</span><br><span class="line">C  FALSE FALSE  TRUE</span><br></pre></td></tr></table></figure><h4 id="asnumeric"><a class="anchor" href="#asnumeric">#</a> ✅ <code>as.numeric(...)</code></h4><ul><li>把逻辑值 <code>TRUE/FALSE</code> 转为 <code>1/0</code> 。</li></ul><h4 id="outer1n-1n"><a class="anchor" href="#outer1n-1n">#</a> ✅ <code>outer(1:N, 1:N, &quot;==&quot;)</code></h4><ul><li>构造一个对角矩阵，主对角线上是 <code>TRUE</code> ，其他是 <code>FALSE</code> ，表示 <code>i == j</code> ，也就是样本与自身是否相等。</li></ul><h4 id="两者相减"><a class="anchor" href="#两者相减">#</a> ✅ 两者相减：</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">as.numeric</span><span class="punctuation">(</span>outer<span class="punctuation">(</span>memb<span class="punctuation">,</span> memb<span class="punctuation">,</span> FUN <span class="operator">=</span> <span class="string">&quot;==&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-</span> outer<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span>N<span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span>N<span class="punctuation">,</span> <span class="string">&quot;==&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>这样可以将<strong>对角线上</strong>的 “自我比较” 从 <code>1</code> 减为 <code>0</code> ，避免误判为共聚类（因为我们通常不关心 “自己和自己” 是否在一类中）。</p><h4 id="举个例子"><a class="anchor" href="#举个例子">#</a> ✅ 举个例子：</h4><p>如果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memb <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;A&quot;</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> <span class="string">&quot;B&quot;</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> <span class="string">&quot;C&quot;</span> <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>则：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outer<span class="punctuation">(</span>memb<span class="punctuation">,</span> memb<span class="punctuation">,</span> <span class="string">&quot;==&quot;</span><span class="punctuation">)</span> <span class="operator">=</span></span><br><span class="line">     A     B     C</span><br><span class="line">A  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">FALSE</span></span><br><span class="line">B  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">FALSE</span></span><br><span class="line">C  <span class="literal">FALSE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p>减去对角线：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     A     B     C</span><br><span class="line">A     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">B     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">C     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>A</code> 和 <code>B</code> 属于同一类，设为 1</li><li>自己和自己不算，设为 0</li><li><code>C</code> 和其他不同类，设为 0</li></ul><hr><h3 id="️-设置行列名"><a class="anchor" href="#️-设置行列名">#</a> 🏷️ 设置行列名</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rownames<span class="punctuation">(</span>mat_cn<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">names</span><span class="punctuation">(</span>memb<span class="punctuation">)</span></span><br><span class="line">colnames<span class="punctuation">(</span>mat_cn<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">names</span><span class="punctuation">(</span>memb<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>给矩阵的行列设置名字，以方便后续查看或可视化。</p><hr><h3 id="返回矩阵"><a class="anchor" href="#返回矩阵">#</a> 🔁 返回矩阵</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span><span class="punctuation">(</span>mat_cn<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>返回共聚类矩阵。</p><hr><h3 id="总结-4"><a class="anchor" href="#总结-4">#</a> ✅ 总结</h3><p>这个函数的作用是：</p><blockquote><p>将聚类结果向量 <code>memb</code> 转换为一个 <strong>共聚类矩阵</strong>，其中：</p><ul><li>如果两个样本属于同一个聚类，值为 <code>1</code></li><li>否则为 <code>0</code></li><li>对角线（自己和自己）是 <code>0</code></li></ul></blockquote><hr><h3 id="应用场景"><a class="anchor" href="#应用场景">#</a> 👀 应用场景</h3><p>这种矩阵常用于：</p><ul><li>聚类结果的可视化（热图）</li><li>多个聚类之间的一致性比较（比如聚类稳定性评估）</li><li>作为图结构的邻接矩阵输入</li></ul><hr><p>如果你打算用这个矩阵进一步构建图、聚类评价指标（比如 NMI、ARI）或者做图神经网络的输入，也可以继续聊，我可以帮你转换或对接成你要的格式！</p></div></details><h3 id="solve_ensemble"><a class="anchor" href="#solve_ensemble">#</a> solve_ensemble</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########### ensemble strategy ###############</span></span><br><span class="line"><span class="comment">#&#x27; The adaptive weighted ensemble-based learning method to integrate the multiple binary spots similarity matrix</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27; <span class="doctag">@importFrom</span> parallel makeCluster stopCluster parApply</span></span><br><span class="line"><span class="comment">#&#x27; <span class="doctag">@importFrom</span> abind abind</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27; <span class="doctag">@param <span class="variable">Results.clustering</span></span> a list contains all the results of individual similarity matrix. The elements of list is a matrix, spots * spots.</span></span><br><span class="line"><span class="comment">#&#x27; <span class="doctag">@param <span class="variable">lambda</span></span> hyper-parameter constrain the weight of individual methods for ensemble. If the parameter is set to NULL, then, we will adopt the value in our algorithm.</span></span><br><span class="line"><span class="comment">#&#x27; <span class="doctag">@param <span class="variable">prob.quantile</span></span> numeric of probabilities with values in [0,1]. Default setting is 0.5.</span></span><br><span class="line"><span class="comment">#&#x27; <span class="doctag">@param <span class="variable">niter</span></span> a positive integer represents the maximum number of updating algorithm. Default setting is 100.</span></span><br><span class="line"><span class="comment">#&#x27; <span class="doctag">@param <span class="variable">epsilon</span></span> a parameter represents the stop criterion.</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27; <span class="doctag">@return</span> a list contains a matrix of the ensemble similarity of spots and a vector of the weight assigned to base results.</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27;<span class="doctag">@export</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">solve_ensemble <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> lambda <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> prob.quantile <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                           niter <span class="operator">=</span> <span class="number">100</span><span class="punctuation">,</span> epsilon <span class="operator">=</span> <span class="number">1e-5</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  options<span class="punctuation">(</span>digits <span class="operator">=</span> <span class="number">7</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># Results.clustering &lt;- Results.clustering.all[[1]]</span></span><br><span class="line">  num.methods <span class="operator">&lt;-</span> <span class="built_in">length</span><span class="punctuation">(</span>Results.clustering<span class="punctuation">)</span></span><br><span class="line">  num.spots <span class="operator">&lt;-</span> nrow<span class="punctuation">(</span>Results.clustering<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">  num.cell.type <span class="operator">&lt;-</span> ncol<span class="punctuation">(</span>Results.clustering<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## initialization V by the mean of individual values</span></span><br><span class="line">  w <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">/</span>num.methods<span class="punctuation">,</span> num.methods<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  H <span class="operator">&lt;-</span>  Reduce<span class="punctuation">(</span><span class="string">&quot;+&quot;</span><span class="punctuation">,</span> Map<span class="punctuation">(</span><span class="string">&quot;*&quot;</span><span class="punctuation">,</span> Results.clustering<span class="punctuation">,</span> w<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">is.null</span><span class="punctuation">(</span>lambda<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;We will adpote a value for lambda in our algorithm...&quot;</span><span class="punctuation">,</span> <span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  k <span class="operator">&lt;-</span> 1</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="punctuation">(</span>k <span class="operator">&lt;=</span> niter<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="keyword">if</span><span class="punctuation">(</span>k <span class="operator">==</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">      loss_all_temp <span class="operator">&lt;-</span> 0</span><br><span class="line">      temp2 <span class="operator">&lt;-</span>  sapply<span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> L2_norm<span class="punctuation">,</span> Y <span class="operator">=</span> H<span class="punctuation">)</span></span><br><span class="line">      <span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">is.null</span><span class="punctuation">(</span>lambda<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">        lambda <span class="operator">&lt;-</span> quantile<span class="punctuation">(</span>temp2<span class="punctuation">,</span> probs <span class="operator">=</span> prob.quantile<span class="punctuation">)</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="keyword">else</span><span class="punctuation">&#123;</span></span><br><span class="line">      loss_all_temp <span class="operator">&lt;-</span> loss_all</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="comment">##### update w</span></span><br><span class="line">    temp2 <span class="operator">&lt;-</span>  sapply<span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> L2_norm<span class="punctuation">,</span> Y <span class="operator">=</span> H<span class="punctuation">)</span></span><br><span class="line">    w <span class="operator">&lt;-</span> <span class="built_in">exp</span><span class="punctuation">(</span><span class="operator">-</span>temp2<span class="operator">/</span>lambda<span class="punctuation">)</span><span class="operator">/</span><span class="built_in">sum</span><span class="punctuation">(</span><span class="built_in">exp</span><span class="punctuation">(</span><span class="operator">-</span>temp2<span class="operator">/</span>lambda<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    H <span class="operator">&lt;-</span>  Reduce<span class="punctuation">(</span><span class="string">&quot;+&quot;</span><span class="punctuation">,</span> Map<span class="punctuation">(</span><span class="string">&quot;*&quot;</span><span class="punctuation">,</span> Results.clustering<span class="punctuation">,</span> w<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">    loss_main <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>sapply<span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> L2_norm<span class="punctuation">,</span> Y <span class="operator">=</span> H<span class="punctuation">)</span> <span class="operator">*</span> w<span class="punctuation">)</span></span><br><span class="line">    loss_entropy <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>w <span class="operator">*</span> <span class="built_in">log</span><span class="punctuation">(</span>w<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    loss_all <span class="operator">&lt;-</span> loss_main <span class="operator">+</span> lambda <span class="operator">*</span> loss_entropy</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cat(&quot;iter: &quot;, k, &quot;loss_main: &quot;, loss_main, &quot;loss_entropy: &quot;, loss_entropy,</span></span><br><span class="line">    <span class="comment">#     &quot;loss_all: &quot;, loss_all, &quot;lambda: &quot;, lambda, &quot;\n&quot;)</span></span><br><span class="line">    <span class="keyword">if</span><span class="punctuation">(</span>k <span class="operator">==</span> niter<span class="punctuation">)</span></span><br><span class="line">      cat<span class="punctuation">(</span><span class="string">&quot;The method maybe not convergens, the algorithm need an larger max_epoches!&quot;</span><span class="punctuation">,</span> <span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">    diff_iter <span class="operator">&lt;-</span> <span class="built_in">abs</span><span class="punctuation">(</span>loss_all <span class="operator">-</span> loss_all_temp<span class="punctuation">)</span></span><br><span class="line">    cat<span class="punctuation">(</span><span class="string">&quot;iter: &quot;</span><span class="punctuation">,</span> k<span class="punctuation">,</span> <span class="string">&quot;loss_main: &quot;</span><span class="punctuation">,</span> loss_main<span class="punctuation">,</span> <span class="string">&quot;loss_entropy: &quot;</span><span class="punctuation">,</span> loss_entropy<span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;loss_all: &quot;</span><span class="punctuation">,</span> loss_all<span class="punctuation">,</span> <span class="string">&quot;lambda: &quot;</span><span class="punctuation">,</span> lambda<span class="punctuation">,</span> <span class="string">&quot;diff&quot;</span><span class="punctuation">,</span></span><br><span class="line">        diff_iter<span class="punctuation">,</span> <span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span><span class="punctuation">(</span>diff_iter <span class="operator">&lt;</span> epsilon <span class="operator">|</span> k <span class="operator">&gt;=</span> niter<span class="punctuation">)</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    k <span class="operator">&lt;-</span> k <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  colnames<span class="punctuation">(</span>H<span class="punctuation">)</span> <span class="operator">&lt;-</span> colnames<span class="punctuation">(</span>Results.clustering<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>H <span class="operator">=</span> H<span class="punctuation">,</span> w <span class="operator">=</span> w<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><details class="danger"><summary>solve_ensemble</summary><div><p>你贴的这段 R 代码 <code>solve_ensemble</code> 实现了一个 <strong>自适应加权集成聚类算法</strong>，用于将多个二值相似度矩阵（通常是从不同算法得到的聚类结果）合并为一个集成结果，关键是：<strong>自动学习每个方法的权重</strong>。</p><p>我给你拆解成几个直观的模块来讲：</p><hr><h2 id="1-函数目标概述"><a class="anchor" href="#1-函数目标概述">#</a> 🧩 1. 函数目标概述</h2><p>这个函数的目标是：</p><blockquote><p><strong>根据多个聚类 / 相似性矩阵，学习出一个最佳的加权平均矩阵（ <code>H</code> ），并同时学习出每个矩阵的权重（ <code>w</code> ）</strong>。</p></blockquote><hr><h2 id="️-2-输入参数说明"><a class="anchor" href="#️-2-输入参数说明">#</a> ⚙️ 2. 输入参数说明</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">solve_ensemble <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> lambda <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> prob.quantile <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                           niter <span class="operator">=</span> <span class="number">100</span><span class="punctuation">,</span> epsilon <span class="operator">=</span> <span class="number">1e-5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><code>Results.clustering</code> ：一个 list，包含多个 <strong>spot × spot 的二值相似度矩阵</strong>（比如是否同属一类）。</li><li><code>lambda</code> ：控制权重平滑程度的超参数。若为 <code>NULL</code> ，则自动估计（后面会说怎么估）。</li><li><code>prob.quantile</code> ：如果 <code>lambda = NULL</code> ，就用这参数来通过多个方法间差异的分布估计 lambda。</li><li><code>niter</code> ：最大迭代轮数。</li><li><code>epsilon</code> ：损失函数收敛的阈值，若变化小于此值就停止。</li></ul><hr><h2 id="3-核心迭代部分解析"><a class="anchor" href="#3-核心迭代部分解析">#</a> 🔁 3. 核心迭代部分解析</h2><h3 id="初始化"><a class="anchor" href="#初始化">#</a> ✅ 初始化</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">/</span>num.methods<span class="punctuation">,</span> num.methods<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">H <span class="operator">&lt;-</span> Reduce<span class="punctuation">(</span><span class="string">&quot;+&quot;</span><span class="punctuation">,</span> Map<span class="punctuation">(</span><span class="string">&quot;*&quot;</span><span class="punctuation">,</span> Results.clustering<span class="punctuation">,</span> w<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>初始时：给每个相似度矩阵一个平均权重 <code>1/num.methods</code></li><li>用 <code>Reduce + Map</code> 加权平均得到初始集成相似矩阵 <code>H</code></li></ul><hr><h3 id="迭代更新"><a class="anchor" href="#迭代更新">#</a> 🔄 迭代更新</h3><p>每轮做两件事：</p><h4 id="1-更新每个相似度矩阵的离散度"><a class="anchor" href="#1-更新每个相似度矩阵的离散度">#</a> ① 更新每个相似度矩阵的 “离散度”</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp2 <span class="operator">&lt;-</span> sapply<span class="punctuation">(</span>Results.clustering<span class="punctuation">,</span> L2_norm<span class="punctuation">,</span> Y <span class="operator">=</span> H<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>这个 <code>temp2</code> 是每个矩阵与当前集成矩阵 <code>H</code> 的 <strong>L2 距离</strong>，越小表示越接近集成矩阵，说明该方法越 “可靠”。</p><blockquote><p><code>L2_norm(A, Y)</code> 是外部定义的函数，表示矩阵 Frobenius 距离：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∥</mi><mi>A</mi><mo>−</mo><mi>Y</mi><msubsup><mi mathvariant="normal">∥</mi><mi>F</mi><mn>2</mn></msubsup><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></munder><mo stretchy="false">(</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>−</mo><msub><mi>Y</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\|A - Y\|^2_F = \sum_{i,j} (A_{ij} - Y_{ij})^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∥</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.22222em">Y</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-2.4530000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">F</span></span></span><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.247em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.463782em;vertical-align:-1.413777em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em"><span style="top:-1.8723309999999997em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span style="top:-3.0500049999999996em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.150216em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p></blockquote><h4 id="2-自动设置-lambda如果第一次设置为-null"><a class="anchor" href="#2-自动设置-lambda如果第一次设置为-null">#</a> ② 自动设置 lambda（如果第一次设置为 NULL）</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">is.null</span><span class="punctuation">(</span>lambda<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  lambda <span class="operator">&lt;-</span> quantile<span class="punctuation">(</span>temp2<span class="punctuation">,</span> probs <span class="operator">=</span> prob.quantile<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>lambda 控制每个方法的重要程度是否能显著拉开；比如选第 50% 分位作为自动估计值。</p><hr><h3 id="更新权重-w"><a class="anchor" href="#更新权重-w">#</a> ✅ 更新权重 w</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w <span class="operator">&lt;-</span> <span class="built_in">exp</span><span class="punctuation">(</span><span class="operator">-</span>temp2<span class="operator">/</span>lambda<span class="punctuation">)</span><span class="operator">/</span><span class="built_in">sum</span><span class="punctuation">(</span><span class="built_in">exp</span><span class="punctuation">(</span><span class="operator">-</span>temp2<span class="operator">/</span>lambda<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>这一步是关键：根据每个方法和 <code>H</code> 的距离，做一个 softmax，加权越小的越重要（因为它离 <code>H</code> 更近）。</p><blockquote><p>类似于加权平均的 soft attention 机制。</p></blockquote><hr><h3 id="重新计算-h"><a class="anchor" href="#重新计算-h">#</a> ✅ 重新计算 H</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H <span class="operator">&lt;-</span> Reduce<span class="punctuation">(</span><span class="string">&quot;+&quot;</span><span class="punctuation">,</span> Map<span class="punctuation">(</span><span class="string">&quot;*&quot;</span><span class="punctuation">,</span> Results.clustering<span class="punctuation">,</span> w<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>用新的权重更新集成矩阵。</p><hr><h3 id="计算损失函数"><a class="anchor" href="#计算损失函数">#</a> ✅ 计算损失函数</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loss_main <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>sapply<span class="punctuation">(</span>...<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">loss_entropy <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>w <span class="operator">*</span> <span class="built_in">log</span><span class="punctuation">(</span>w<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">loss_all <span class="operator">&lt;-</span> loss_main <span class="operator">+</span> lambda <span class="operator">*</span> loss_entropy</span><br></pre></td></tr></table></figure><p>总损失由两部分组成：</p><ol><li><strong>主要误差项</strong>（ <code>loss_main</code> ）：每个矩阵和集成矩阵的距离（代表一致性）</li><li><strong>熵正则项</strong>（ <code>loss_entropy</code> ）：惩罚权重过于集中（希望不要太偏）</li></ol><blockquote><p>损失函数形式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>w</mi><mi>i</mi></msub><mo>⋅</mo><mi mathvariant="normal">∥</mi><msub><mi>A</mi><mi>i</mi></msub><mo>−</mo><mi>H</mi><msup><mi mathvariant="normal">∥</mi><mn>2</mn></msup><mo>+</mo><mi>λ</mi><mo>⋅</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>w</mi><mi>i</mi></msub><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L = \sum_i w_i \cdot \|A_i - H\|^2 + \lambda \cdot \sum_i w_i \log(w_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.327674em;vertical-align:-1.277669em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em"><span style="top:-1.872331em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.050005em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.02691em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∥</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.08125em">H</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:2.327674em;vertical-align:-1.277669em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em"><span style="top:-1.872331em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.050005em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.02691em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.02691em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p></blockquote><hr><h2 id="最终输出"><a class="anchor" href="#最终输出">#</a> ✅ 最终输出</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>H <span class="operator">=</span> H<span class="punctuation">,</span> w <span class="operator">=</span> w<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><code>H</code> ：最终的集成相似度矩阵（可用于后续聚类）</li><li><code>w</code> ：每个方法的权重（代表各自的可靠程度）</li></ul><hr><h2 id="总结一句话-4"><a class="anchor" href="#总结一句话-4">#</a> 🎯 总结一句话：</h2><blockquote><p><strong><code>solve_ensemble</code> 用自适应的 soft weighting 方式，把多个二值聚类矩阵集成成一个更稳定、更综合的相似性矩阵，并学出每个方法的相对权重。</strong></p></blockquote><hr><h2 id="应用场景-2"><a class="anchor" href="#应用场景-2">#</a> 🚀 应用场景</h2><ul><li>多模型聚类集成（比如图聚类、谱聚类、k-means 等）</li><li>空间转录组多模态数据整合</li><li>图神经网络中的邻接矩阵集成</li><li>任意相似度矩阵融合场景</li></ul><hr><p>如果你有具体的 <code>Results.clustering</code> 示例或者想接着看看后续聚类操作（比如怎么从 <code>H</code> 得到最终的 cluster label），我也可以帮你对接上～</p></div></details><h3 id="weighted_average"><a class="anchor" href="#weighted_average">#</a> weighted_average</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">weighted_average <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> w<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  index_non_zero <span class="operator">&lt;-</span> which<span class="punctuation">(</span>x <span class="operator">!=</span> <span class="number">0</span><span class="punctuation">,</span> arr.ind <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">  x_use <span class="operator">&lt;-</span> x<span class="punctuation">[</span>index_non_zero<span class="punctuation">]</span></span><br><span class="line">  w_use <span class="operator">&lt;-</span> w<span class="punctuation">[</span>index_non_zero<span class="punctuation">]</span></span><br><span class="line">  results <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>x_use <span class="operator">*</span> w_use<span class="punctuation">)</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>results<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><details class="danger"><summary>weighted_average</summary><div><p>这段 R 代码定义了一个函数 <code>weighted_average</code> ，它的作用是：<strong>计算矩阵 <code>x</code> 中非零元素的加权平均（不做归一化）</strong>，即仅在非零元素上对 <code>x</code> 和权重 <code>w</code> 做加权求和。</p><p>我们来逐步分析它做了什么：</p><hr><h3 id="函数功能分解"><a class="anchor" href="#函数功能分解">#</a> ✅ 函数功能分解：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weighted_average <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> w<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br></pre></td></tr></table></figure><ul><li><code>x</code> : 一个矩阵或向量，包含原始数值（如某些度量、得分、相似度等）</li><li><code>w</code> : 和 <code>x</code> 相同维度的权重矩阵 / 向量</li></ul><hr><h3 id="1-提取非零位置"><a class="anchor" href="#1-提取非零位置">#</a> 1. 提取非零位置：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index_non_zero <span class="operator">&lt;-</span> which<span class="punctuation">(</span>x <span class="operator">!=</span> <span class="number">0</span><span class="punctuation">,</span> arr.ind <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><code>which(x != 0)</code> ：找到 <code>x</code> 中非零元素的索引</li><li><code>arr.ind = TRUE</code> ：如果 <code>x</code> 是矩阵，返回二维下标（行列索引），而不是扁平化的一维索引</li></ul><hr><h3 id="2-获取对应的非零值和权重"><a class="anchor" href="#2-获取对应的非零值和权重">#</a> 2. 获取对应的非零值和权重：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_use <span class="operator">&lt;-</span> x<span class="punctuation">[</span>index_non_zero<span class="punctuation">]</span></span><br><span class="line">w_use <span class="operator">&lt;-</span> w<span class="punctuation">[</span>index_non_zero<span class="punctuation">]</span></span><br></pre></td></tr></table></figure><ul><li>提取 <code>x</code> 中非零元素的位置</li><li>并提取对应的权重</li></ul><hr><h3 id="3-加权求和"><a class="anchor" href="#3-加权求和">#</a> 3. 加权求和：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>x_use <span class="operator">*</span> w_use<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>直接把 <code>x</code> 的非零值与对应权重相乘后求和</li></ul><blockquote><p>❗注意：这个不是标准的 “加权平均”（没有除以权重总和），更准确说法是 “加权和”。</p></blockquote><hr><h3 id="4-返回值"><a class="anchor" href="#4-返回值">#</a> 4. 返回值：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span><span class="punctuation">(</span>results<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><hr><h3 id="举个例子-2"><a class="anchor" href="#举个例子-2">#</a> ✅ 举个例子：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">w <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.3</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">weighted_average<span class="punctuation">(</span>x<span class="punctuation">,</span> w<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>非零位置是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2] = 1     对应权重 = 0.4</span><br><span class="line">[2,1] = 2     对应权重 = 0.2</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1*0.4 + 2*0.2 = 0.4 + 0.4 = 0.8</span><br></pre></td></tr></table></figure><hr><h3 id="总结-5"><a class="anchor" href="#总结-5">#</a> 🧠 总结：</h3><p>这个函数常用于：</p><ul><li>对相似度矩阵等稀疏数据，在非零区域进行加权处理</li><li>某些 “mask”-like 或 “边权”-like 结构（如图中的边权重加权）</li></ul><hr><p>如果你想要做<strong>标准化的加权平均</strong>，可以在最后加一行：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>x_use <span class="operator">*</span> w_use<span class="punctuation">)</span> <span class="operator">/</span> <span class="built_in">sum</span><span class="punctuation">(</span>w_use<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>要不要我帮你改成这个形式？或者说你是在哪个上下文中用这个函数的？我可以帮你判断是不是少了归一化。</p></div></details><h3 id="patch_deal"><a class="anchor" href="#patch_deal">#</a> patch_deal</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########### ensemble strategy ###########</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########### patch dealing ##############</span></span><br><span class="line"><span class="comment">#&#x27; This function aims to integrate the results obtained by user own running</span></span><br><span class="line"><span class="comment">#&#x27; spatial domain methods.</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27; <span class="doctag">@param <span class="variable">res</span></span> a list contains all the results of base SDD methods contain in EnSDD methods.</span></span><br><span class="line"><span class="comment">#&#x27; <span class="doctag">@param <span class="variable">clustering_df</span></span> a data frame contains the clustering label generated by SDD methods generated by users. The row represents the spot and the column represents the methods.</span></span><br><span class="line"><span class="comment">#&#x27; <span class="doctag">@return</span> a list contains clustering labels, spot-spot similarity matrix and running time.</span></span><br><span class="line">patch_deal <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>res<span class="punctuation">,</span> clustering_df<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">is.null</span><span class="punctuation">(</span>colnames<span class="punctuation">(</span>clustering_df<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    stop<span class="punctuation">(</span><span class="string">&#x27;Please provide the methods of clustering results&#x27;</span><span class="punctuation">)</span></span><br><span class="line">  res.final <span class="operator">=</span> res</span><br><span class="line"></span><br><span class="line">  n_path <span class="operator">&lt;-</span> ncol<span class="punctuation">(</span>clustering_df<span class="punctuation">)</span></span><br><span class="line">  names_all <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">names</span><span class="punctuation">(</span>res.final<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span> colnames<span class="punctuation">(</span>clustering_df<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  spot_names <span class="operator">=</span> <span class="built_in">names</span><span class="punctuation">(</span>res.final<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">  ori_len <span class="operator">=</span> <span class="built_in">length</span><span class="punctuation">(</span>res.final<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">  clustering_df <span class="operator">=</span> clustering_df<span class="punctuation">[</span>spot_names<span class="punctuation">,</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## integrate</span></span><br><span class="line">  <span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span>n_path<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    tmp <span class="operator">=</span> clustering_df<span class="punctuation">[</span><span class="punctuation">,</span>i<span class="punctuation">]</span></span><br><span class="line">    <span class="built_in">names</span><span class="punctuation">(</span>tmp<span class="punctuation">)</span> <span class="operator">=</span> spot_names</span><br><span class="line">    tmp_sim_mat <span class="operator">=</span> clust2Mat<span class="punctuation">(</span>memb <span class="operator">=</span> tmp<span class="punctuation">)</span></span><br><span class="line">    res.final<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>ori_len <span class="operator">+</span> i<span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">=</span> tmp</span><br><span class="line">    res.final<span class="punctuation">[[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>ori_len <span class="operator">+</span> i<span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">=</span> tmp_sim_mat</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="built_in">names</span><span class="punctuation">(</span>res.final<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">=</span> names_all</span><br><span class="line">  <span class="built_in">names</span><span class="punctuation">(</span>res.final<span class="punctuation">[[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">=</span> names_all</span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>res.final<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><details class="danger"><summary>patch_deal</summary><div><p>这段 R 代码的核心功能是：</p><blockquote><p><strong>将用户自定义聚类结果（ <code>clustering_df</code> ）转化为相应的相似度矩阵，并整合到已有的聚类结果列表 <code>res</code> 中，作为扩展后的 ensemble 输入。</strong></p></blockquote><p>下面是详细分析：</p><hr><h2 id="函数定义和参数"><a class="anchor" href="#函数定义和参数">#</a> 🔧 函数定义和参数</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch_deal <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>res<span class="punctuation">,</span> clustering_df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="参数说明"><a class="anchor" href="#参数说明">#</a> 参数说明：</h3><ul><li><code>res</code> ：一个列表，结构是 <code>res[[1]]</code> 为聚类标签列表（每个方法一个向量）， <code>res[[2]]</code> 为相应的 spot-spot 相似度矩阵（如 0-1 表示同聚类）。</li><li><code>clustering_df</code> ：用户自己运行的聚类结果，每列是一种方法的聚类标签，每行是一个 spot。</li></ul><hr><h2 id="代码解析步骤"><a class="anchor" href="#代码解析步骤">#</a> 🧩 代码解析步骤：</h2><h3 id="1-检查聚类列名"><a class="anchor" href="#1-检查聚类列名">#</a> 1. 检查聚类列名：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">is.null</span><span class="punctuation">(</span>colnames<span class="punctuation">(</span>clustering_df<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  stop<span class="punctuation">(</span><span class="string">&#x27;Please provide the methods of clustering results&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>要求 <code>clustering_df</code> 的每列命名为方法名。</p><hr><h3 id="2-初始化和准备变量"><a class="anchor" href="#2-初始化和准备变量">#</a> 2. 初始化和准备变量：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res.final <span class="operator">=</span> res</span><br><span class="line">n_path <span class="operator">&lt;-</span> ncol<span class="punctuation">(</span>clustering_df<span class="punctuation">)</span>  <span class="comment"># 用户方法数量</span></span><br><span class="line">names_all <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">names</span><span class="punctuation">(</span>res.final<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span> colnames<span class="punctuation">(</span>clustering_df<span class="punctuation">)</span><span class="punctuation">)</span>  <span class="comment"># 所有方法名</span></span><br><span class="line">spot_names <span class="operator">=</span> <span class="built_in">names</span><span class="punctuation">(</span>res.final<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span>  <span class="comment"># spot 的名字</span></span><br><span class="line">ori_len <span class="operator">=</span> <span class="built_in">length</span><span class="punctuation">(</span>res.final<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span>  <span class="comment"># 原本已有的 base 方法数量</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-按照已有顺序对-clustering_df-进行重排"><a class="anchor" href="#3-按照已有顺序对-clustering_df-进行重排">#</a> 3. 按照已有顺序对 <code>clustering_df</code> 进行重排：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clustering_df <span class="operator">=</span> clustering_df<span class="punctuation">[</span>spot_names<span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>确保 <code>clustering_df</code> 中的行顺序和 <code>res</code> 中的顺序一致。</p><hr><h3 id="4-主循环将用户的聚类标签转为-similarity-matrix"><a class="anchor" href="#4-主循环将用户的聚类标签转为-similarity-matrix">#</a> 4. 主循环：将用户的聚类标签转为 similarity matrix</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span>n_path<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  tmp <span class="operator">=</span> clustering_df<span class="punctuation">[</span><span class="punctuation">,</span>i<span class="punctuation">]</span>  <span class="comment"># 第i个用户方法的聚类标签</span></span><br><span class="line">  <span class="built_in">names</span><span class="punctuation">(</span>tmp<span class="punctuation">)</span> <span class="operator">=</span> spot_names</span><br><span class="line"></span><br><span class="line">  tmp_sim_mat <span class="operator">=</span> clust2Mat<span class="punctuation">(</span>memb <span class="operator">=</span> tmp<span class="punctuation">)</span>  <span class="comment"># 调用之前定义的函数，转为 similarity matrix</span></span><br><span class="line"></span><br><span class="line">  res.final<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>ori_len <span class="operator">+</span> i<span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">=</span> tmp         <span class="comment"># 添加聚类标签</span></span><br><span class="line">  res.final<span class="punctuation">[[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>ori_len <span class="operator">+</span> i<span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">=</span> tmp_sim_mat <span class="comment"># 添加对应的 similarity matrix</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="这里调用了你之前的函数"><a class="anchor" href="#这里调用了你之前的函数">#</a> 🚩这里调用了你之前的函数：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clust2Mat <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>memb<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  N <span class="operator">&lt;-</span> <span class="built_in">length</span><span class="punctuation">(</span>memb<span class="punctuation">)</span></span><br><span class="line">  mat_cn <span class="operator">&lt;-</span> <span class="built_in">as.numeric</span><span class="punctuation">(</span>outer<span class="punctuation">(</span>memb<span class="punctuation">,</span> memb<span class="punctuation">,</span> FUN <span class="operator">=</span> <span class="string">&quot;==&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-</span> outer<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span>N<span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span>N<span class="punctuation">,</span> <span class="string">&quot;==&quot;</span><span class="punctuation">)</span></span><br><span class="line">  rownames<span class="punctuation">(</span>mat_cn<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">names</span><span class="punctuation">(</span>memb<span class="punctuation">)</span></span><br><span class="line">  colnames<span class="punctuation">(</span>mat_cn<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">names</span><span class="punctuation">(</span>memb<span class="punctuation">)</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>mat_cn<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>该函数把聚类标签向量变成了一个 <strong>binary similarity matrix</strong>，元素为 1 表示属于同一个聚类，主对角线为 0。</p><hr><h3 id="5-更新方法名"><a class="anchor" href="#5-更新方法名">#</a> 5. 更新方法名：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>res.final<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">=</span> names_all</span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>res.final<span class="punctuation">[[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">=</span> names_all</span><br></pre></td></tr></table></figure><p>添加新方法后重新标记所有方法名。</p><hr><h3 id="返回值"><a class="anchor" href="#返回值">#</a> ✅ 返回值：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span><span class="punctuation">(</span>res.final<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>这个 <code>res.final</code> 是完整更新过的 ensemble 输入，包含基础方法 + 用户方法的聚类标签和 similarity 矩阵。</p><hr><h2 id="总结图示"><a class="anchor" href="#总结图示">#</a> 🔁 总结图示</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">clustering_df:</span><br><span class="line">            method1 method2</span><br><span class="line">spot1        1        2</span><br><span class="line">spot2        1        2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line">每一列 -&gt; clustering 向量 -&gt; similarity matrix</span><br><span class="line"></span><br><span class="line">加入：</span><br><span class="line">res[[1]]  # 标签列表</span><br><span class="line">res[[2]]  # 相似度矩阵列表</span><br></pre></td></tr></table></figure><hr><p>如果你希望我可视化一下这种 “聚类 → similarity 矩阵” 的转化，我也可以画一个示意图。要不要？</p></div></details><h2 id="plot_sankey"><a class="anchor" href="#plot_sankey">#</a> plot_Sankey</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data = read.table(&quot;C:/data/Vandy Onedrive/OneDrive - Vanderbilt/Desktop/Coranl_df.txt&quot;)</span></span><br><span class="line"></span><br><span class="line">create_df_Sankey &lt;- function(cluster1, cluster2)&#123;</span><br><span class="line">  c1toc2 &lt;- NULL</span><br><span class="line"></span><br><span class="line">  levels1 &lt;- unique(cluster1)</span><br><span class="line">  levels2 &lt;- unique(cluster2)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:length(levels1))&#123;</span><br><span class="line">    res &lt;- NULL</span><br><span class="line">    <span class="keyword">for</span>(j <span class="keyword">in</span> <span class="number">1</span>:length(levels2)) &#123;</span><br><span class="line">      tmp &lt;- length(which(cluster1 == levels1[i] &amp; cluster2 == levels2[j]))</span><br><span class="line">      res &lt;- c(res, tmp)</span><br><span class="line">    &#125;</span><br><span class="line">    c1toc2 &lt;- rbind(c1toc2, res)</span><br><span class="line">  &#125;</span><br><span class="line">  colnames(c1toc2) &lt;- levels2</span><br><span class="line">  rownames(c1toc2) &lt;- levels1</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>(c1toc2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plot_sankey_fun = function(links)&#123;</span><br><span class="line">  nodes &lt;- data.frame(</span><br><span class="line">    name=c(<span class="keyword">as</span>.character(links$source),</span><br><span class="line">           <span class="keyword">as</span>.character(links$target)) %&gt;% unique()</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  links$IDsource &lt;- <span class="keyword">match</span>(links$source, nodes$name)-<span class="number">1</span></span><br><span class="line">  links$IDtarget &lt;- <span class="keyword">match</span>(links$target, nodes$name)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  p &lt;- networkD3::sankeyNetwork(Links = links, Nodes = nodes,</span><br><span class="line">                                Source = <span class="string">&quot;IDsource&quot;</span>, Target = <span class="string">&quot;IDtarget&quot;</span>,</span><br><span class="line">                                Value = <span class="string">&quot;value&quot;</span>, NodeID = <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                                sinksRight=FALSE, fontSize = <span class="number">12</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#&#x27; This function is designed for the visualization of Sankey diagram.</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27; @importFrom networkD3 sankeyNetwork</span></span><br><span class="line"><span class="comment">#&#x27; @importFrom reshape2 melt</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27; @param df the data frame, where row represents the sample, column represents the multiple clusters</span></span><br><span class="line"><span class="comment">#&#x27; @param filter filter the number of interaction in Sankey diagram. Default setting is 5.</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"><span class="comment">#&#x27; @export</span></span><br><span class="line"><span class="comment">#&#x27;</span></span><br><span class="line"></span><br><span class="line">plot_sankey &lt;- function(df, <span class="built_in">filter</span> = <span class="number">5</span>)&#123;</span><br><span class="line">  data &lt;- df</span><br><span class="line">  df_list &lt;- <span class="built_in">list</span>()</span><br><span class="line">  <span class="comment"># source_sk &lt;- c()</span></span><br><span class="line">  <span class="comment"># target_sk &lt;- c()</span></span><br><span class="line">  <span class="comment"># values_sk &lt;- c()</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:(ncol(df)-<span class="number">1</span>)) &#123;</span><br><span class="line">    tmp1 &lt;- create_df_Sankey(df[,i], df[,(i+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    level_row &lt;- paste0(<span class="string">&#x27;Domain&#x27;</span>, length(levels(<span class="keyword">as</span>.factor(df[,i]))), <span class="string">&#x27;_&#x27;</span>, rownames(tmp1))</span><br><span class="line">    level_col &lt;- paste0(<span class="string">&#x27;Domain&#x27;</span>, length(levels(<span class="keyword">as</span>.factor(df[,i+<span class="number">1</span>]))), <span class="string">&#x27;_&#x27;</span>, colnames(tmp1))</span><br><span class="line"></span><br><span class="line">    rownames(tmp1) &lt;- level_row</span><br><span class="line">    colnames(tmp1) &lt;- level_col</span><br><span class="line"></span><br><span class="line">    tmp2 &lt;- reshape2::melt(tmp1)</span><br><span class="line">    tmp2 = tmp2[tmp2$value &gt;= <span class="built_in">filter</span>, ]</span><br><span class="line">    <span class="comment"># source_sk &lt;- c(source_sk, tmp2[,1])</span></span><br><span class="line">    <span class="comment"># target_sk &lt;- c(target_sk, tmp2[,2])</span></span><br><span class="line">    <span class="comment"># values_sk &lt;- c(values_sk, tmp2[,3])</span></span><br><span class="line"></span><br><span class="line">    df_list[[i]] &lt;- tmp2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  source_sk &lt;- c()</span><br><span class="line">  target_sk &lt;- c()</span><br><span class="line">  values_sk &lt;- c()</span><br><span class="line">  <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>:length(df_list)) &#123;</span><br><span class="line">    source_sk &lt;- c(source_sk, <span class="keyword">as</span>.character(df_list[[j]][,<span class="number">1</span>]))</span><br><span class="line">    target_sk &lt;- c(target_sk, <span class="keyword">as</span>.character(df_list[[j]][,<span class="number">2</span>]))</span><br><span class="line">    values_sk &lt;- c(values_sk, df_list[[j]][,<span class="number">3</span>])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  links &lt;- data.frame(</span><br><span class="line">    source=source_sk,</span><br><span class="line">    target=target_sk,</span><br><span class="line">    value=values_sk</span><br><span class="line">  )</span><br><span class="line">  p = plot_sankey_fun(links)</span><br><span class="line">  p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details class="danger"><summary>Sankey</summary><div><p>这段 <strong>R 语言代码</strong> 的主要功能是：** 根据多个聚类（cluster）之间的对应关系，绘制 Sankey 图（桑基图）来可视化聚类之间的映射关系变化。** 下面是对每个部分的逐步解释。</p><hr><h2 id="1-create_df_sankey-函数"><a class="anchor" href="#1-create_df_sankey-函数">#</a> 🔧 1. <code>create_df_Sankey</code> 函数</h2><p><strong>功能</strong>：生成一个二维的频次矩阵，表示 <code>cluster1</code> 和 <code>cluster2</code> 中各个类别之间的映射频率。</p><h3 id="参数"><a class="anchor" href="#参数">#</a> 参数：</h3><ul><li><code>cluster1</code> ：第一列聚类标签向量</li><li><code>cluster2</code> ：第二列聚类标签向量</li></ul><h3 id="过程"><a class="anchor" href="#过程">#</a> 过程：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span><span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="built_in">length</span><span class="punctuation">(</span>levels1<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="keyword">for</span><span class="punctuation">(</span>j <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="built_in">length</span><span class="punctuation">(</span>levels2<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    tmp <span class="operator">&lt;-</span> <span class="built_in">length</span><span class="punctuation">(</span>which<span class="punctuation">(</span>cluster1 <span class="operator">==</span> levels1<span class="punctuation">[</span>i<span class="punctuation">]</span> <span class="operator">&amp;</span> cluster2 <span class="operator">==</span> levels2<span class="punctuation">[</span>j<span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>遍历 <code>cluster1</code> 中的每个类别（ <code>level1[i]</code> ）和 <code>cluster2</code> 中的每个类别（ <code>level2[j]</code> ），统计有多少个样本从 <code>cluster1 == level1[i]</code> 映射到了 <code>cluster2 == level2[j]</code> 。</p><h3 id="返回值-2"><a class="anchor" href="#返回值-2">#</a> 返回值：</h3><p>一个 <strong>频次矩阵</strong>（行是 <code>cluster1</code> 的类别，列是 <code>cluster2</code> 的类别）。</p><hr><h2 id="2-plot_sankey_fun-函数"><a class="anchor" href="#2-plot_sankey_fun-函数">#</a> 📊 2. <code>plot_sankey_fun</code> 函数</h2><p><strong>功能</strong>：根据传入的 <code>links</code> 数据框，绘制 Sankey 图。</p><h3 id="输入"><a class="anchor" href="#输入">#</a> 输入：</h3><p><code>links</code> 是一个 data.frame，包含三列：</p><ul><li><code>source</code> : 源节点（字符串）</li><li><code>target</code> : 目标节点（字符串）</li><li><code>value</code> : 权重或频次</li></ul><h3 id="关键步骤"><a class="anchor" href="#关键步骤">#</a> 关键步骤：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodes <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>name <span class="operator">=</span> unique<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">as.character</span><span class="punctuation">(</span>links<span class="operator">$</span>source<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">as.character</span><span class="punctuation">(</span>links<span class="operator">$</span>target<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>生成唯一节点名，构成节点表。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">links<span class="operator">$</span>IDsource <span class="operator">&lt;-</span> match<span class="punctuation">(</span>links<span class="operator">$</span>source<span class="punctuation">,</span> nodes<span class="operator">$</span>name<span class="punctuation">)</span> <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">links<span class="operator">$</span>IDtarget <span class="operator">&lt;-</span> match<span class="punctuation">(</span>links<span class="operator">$</span>target<span class="punctuation">,</span> nodes<span class="operator">$</span>name<span class="punctuation">)</span> <span class="operator">-</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>把 <code>source</code> 和 <code>target</code> 映射为 0-based 的整数 ID，这是 <code>networkD3::sankeyNetwork()</code> 要求的格式。</p><hr><h2 id="3-plot_sankey-函数主函数"><a class="anchor" href="#3-plot_sankey-函数主函数">#</a> 🌉 3. <code>plot_sankey</code> 函数（主函数）</h2><p><strong>功能</strong>：整合多个聚类层次之间的关系，绘制一张完整的 Sankey 图。</p><h3 id="参数-2"><a class="anchor" href="#参数-2">#</a> 参数：</h3><ul><li><code>df</code> ：一个 data frame，行表示样本，列表示不同的聚类（cluster）结果。</li><li><code>filter</code> ：过滤阈值，小于这个频次的映射不展示。</li></ul><hr><h3 id="过程详解"><a class="anchor" href="#过程详解">#</a> 过程详解：</h3><h4 id="step-1两两列之间调用-create_df_sankey"><a class="anchor" href="#step-1两两列之间调用-create_df_sankey">#</a> Step 1：两两列之间调用 <code>create_df_Sankey</code> ：</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="punctuation">(</span>ncol<span class="punctuation">(</span>df<span class="punctuation">)</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  tmp1 <span class="operator">&lt;-</span> create_df_Sankey<span class="punctuation">(</span>df<span class="punctuation">[</span><span class="punctuation">,</span>i<span class="punctuation">]</span><span class="punctuation">,</span> df<span class="punctuation">[</span><span class="punctuation">,</span><span class="punctuation">(</span>i<span class="operator">+</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>生成 <code>i</code> 和 <code>i+1</code> 列之间的频次关系矩阵。</p><h4 id="step-2为了避免节点名冲突为每个节点加上前缀"><a class="anchor" href="#step-2为了避免节点名冲突为每个节点加上前缀">#</a> Step 2：为了避免节点名冲突，为每个节点加上前缀：</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">level_row <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span><span class="string">&#x27;Domain&#x27;</span><span class="punctuation">,</span> <span class="built_in">length</span><span class="punctuation">(</span>levels<span class="punctuation">(</span>as.factor<span class="punctuation">(</span>df<span class="punctuation">[</span><span class="punctuation">,</span>i<span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&#x27;_&#x27;</span><span class="punctuation">,</span> rownames<span class="punctuation">(</span>tmp1<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">level_col <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span><span class="string">&#x27;Domain&#x27;</span><span class="punctuation">,</span> <span class="built_in">length</span><span class="punctuation">(</span>levels<span class="punctuation">(</span>as.factor<span class="punctuation">(</span>df<span class="punctuation">[</span><span class="punctuation">,</span>i<span class="operator">+</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&#x27;_&#x27;</span><span class="punctuation">,</span> colnames<span class="punctuation">(</span>tmp1<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h4 id="step-3使用-reshape2melt-把矩阵转换成长格式并过滤"><a class="anchor" href="#step-3使用-reshape2melt-把矩阵转换成长格式并过滤">#</a> Step 3：使用 <code>reshape2::melt</code> 把矩阵转换成长格式，并过滤：</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp2 <span class="operator">&lt;-</span> reshape2<span class="operator">::</span>melt<span class="punctuation">(</span>tmp1<span class="punctuation">)</span></span><br><span class="line">tmp2 <span class="operator">=</span> tmp2<span class="punctuation">[</span>tmp2<span class="operator">$</span>value <span class="operator">&gt;=</span> filter<span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>转换成包含三列（source, target, value）形式，去掉低频连接。</p><h4 id="step-4汇总所有连接信息到-links"><a class="anchor" href="#step-4汇总所有连接信息到-links">#</a> Step 4：汇总所有连接信息到 <code>links</code> ：</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source_sk <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>source_sk<span class="punctuation">,</span> <span class="built_in">as.character</span><span class="punctuation">(</span>df_list<span class="punctuation">[[</span>j<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">target_sk <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>target_sk<span class="punctuation">,</span> <span class="built_in">as.character</span><span class="punctuation">(</span>df_list<span class="punctuation">[[</span>j<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">values_sk <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>values_sk<span class="punctuation">,</span> df_list<span class="punctuation">[[</span>j<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>最终构建：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">links <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>source<span class="operator">=</span>source_sk<span class="punctuation">,</span> target<span class="operator">=</span>target_sk<span class="punctuation">,</span> value<span class="operator">=</span>values_sk<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h4 id="step-5调用-plot_sankey_fun-绘图"><a class="anchor" href="#step-5调用-plot_sankey_fun-绘图">#</a> Step 5：调用 <code>plot_sankey_fun()</code> 绘图。</h4><hr><h2 id="总结-6"><a class="anchor" href="#总结-6">#</a> 📌 总结</h2><p>这段代码的用途是在有多个层次聚类标签的情况下，比如：</p><table><thead><tr><th>cluster1</th><th>cluster2</th><th>cluster3</th></tr></thead><tbody><tr><td>A</td><td>X</td><td>L</td></tr><tr><td>A</td><td>Y</td><td>M</td></tr><tr><td>B</td><td>X</td><td>L</td></tr><tr><td>B</td><td>Y</td><td>N</td></tr></tbody></table><p>它将展示从 <code>cluster1</code> → <code>cluster2</code> → <code>cluster3</code> 的路径关系图，并用 <strong>Sankey 图</strong> 形式可视化流动和分布情况（常见于 <strong>单细胞聚类可视化</strong>，也可用于任何类别映射追踪）。</p><hr><p>如果你有这个函数的实际数据样例或者想绘制的聚类结果，我也可以帮你进一步分析或展示可视化结果。</p></div></details><div class="tags"><a href="/tags/%E7%94%9F%E7%89%A9/" rel="tag"><i class="ic i-tag"></i> 生物</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B1%BB/" rel="tag"><i class="ic i-tag"></i> 学习笔记类</a> <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="ic i-tag"></i> 算法</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-05-14 15:59:34" itemprop="dateModified" datetime="2025-05-14T15:59:34+08:00">2025-05-14</time> </span><span id="article/EnSDD/" class="item leancloud_visitors" data-flag-title="EnSDD" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Lemon Sour <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="http://amentiraz.github.io/article/EnSDD/" title="EnSDD">http://amentiraz.github.io/article/EnSDD/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/article/DeepST/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;amentirazblogpic.oss-cn-hangzhou.aliyuncs.com&#x2F;blogpic&#x2F;%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925124522.jpg" title="DeepST"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 论文</span><h3>DeepST</h3></a></div><div class="item right"><a href="/music/%E5%B8%B8%E8%A7%81%E5%92%8C%E5%BC%A6/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;amentirazblogpic.oss-cn-hangzhou.aliyuncs.com&#x2F;blogpic&#x2F;%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240925124558.png" title="常见和弦"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 乐理</span><h3>常见和弦</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BA%E6%96%87%E8%A6%81%E7%82%B9%E6%8F%90%E7%82%BCenhancing-spatial-domain-detection-in-spatial-transcriptomics-with-ensdd"><span class="toc-number">1.</span> <span class="toc-text">论文要点提炼：《Enhancing Spatial Domain Detection in Spatial Transcriptomics with EnSDD》</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A0%94%E7%A9%B6%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text">1. 研究背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A0%94%E7%A9%B6%E7%9B%AE%E6%A0%87"><span class="toc-number">1.2.</span> <span class="toc-text">2. 研究目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E5%88%9B%E6%96%B0"><span class="toc-number">1.3.</span> <span class="toc-text">3. 方法创新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BB%E8%A6%81%E5%AE%9E%E9%AA%8C%E4%B8%8E%E7%BB%93%E6%9E%9C"><span class="toc-number">1.4.</span> <span class="toc-text">4. 主要实验与结果</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%A8%E4%BA%BA%E7%B1%BB%E5%A4%A7%E8%84%91-dlpfc-%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8A%E7%9A%84%E8%A1%A8%E7%8E%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">(1) 在人类大脑 DLPFC 数据集上的表现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8%E5%B0%8F%E9%BC%A0%E5%A4%A7%E8%84%91%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8A%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">(2) 在小鼠大脑数据集上的验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%A8%E7%99%8C%E7%97%87%E7%BB%84%E7%BB%87%E4%B9%B3%E8%85%BA%E7%99%8C-%E5%89%8D%E5%88%97%E8%85%BA%E7%99%8C%E5%92%8C%E5%8D%B5%E5%B7%A2%E7%99%8C%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">(3) 在癌症组织（乳腺癌、前列腺癌和卵巢癌）上的应用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%B4%A1%E7%8C%AE%E4%B8%8E%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B"><span class="toc-number">1.5.</span> <span class="toc-text">5. 贡献与未来展望</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">总结</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#two-main-challenges"><span class="toc-number"></span> <span class="toc-text">two main challenges:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ensddensemble-learning-for-spatial-domain-detection-offers-several-advantages"><span class="toc-number"></span> <span class="toc-text">EnSDD(Ensemble-learning for Spatial Domain Detection) offers several advantages:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#methods%E9%83%A8%E5%88%86"><span class="toc-number"></span> <span class="toc-text">Methods 部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E5%80%BC%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E6%9E%84%E9%80%A0"><span class="toc-number">1.</span> <span class="toc-text">1. 二值相似矩阵构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A0%E6%9D%83%E8%9E%8D%E5%90%88%E5%85%AC%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">2. 优化模型与加权融合公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">📌 优化问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%B1%82"><span class="toc-number">4.</span> <span class="toc-text">🎯 要求：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.</span> <span class="toc-text">🧮 计算步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8E%E6%98%AF%E6%95%B4%E4%BD%93%E5%81%8F%E5%AF%BC%E4%B8%BA"><span class="toc-number">6.</span> <span class="toc-text">🧾 于是整体偏导为：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C"><span class="toc-number">7.</span> <span class="toc-text">✅ 最终结果：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%A0%E8%A6%81%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%83%E5%8F%AA%E9%9C%80%E8%AE%A9%E5%81%8F%E5%AF%BC%E4%B8%BA-0"><span class="toc-number">8.</span> <span class="toc-text">💡 如果你要最小化它，只需让偏导为 0：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%BB%99%E7%9A%84%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E6%98%AF"><span class="toc-number"></span> <span class="toc-text">🔢 你给的目标函数是：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%B8%8F-%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%86%99%E5%87%BA-lagrangian-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">✏️ 第一步：写出 Lagrangian 拉格朗日函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E5%AF%B9%E6%AF%8F%E4%B8%AA-omega_m-%E6%B1%82%E5%81%8F%E5%AF%BC%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">🧮 第二步：对每个 ωm\omega_mωm​ 求偏导数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%E7%94%A8%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E6%B1%82%E5%87%BA-c"><span class="toc-number"></span> <span class="toc-text">✅ 第三步：用约束条件求出 CCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C-2"><span class="toc-number"></span> <span class="toc-text">🎉 最终结果：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-number"></span> <span class="toc-text">📌 补充说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%86%E5%BC%80%E7%9C%8Bmathcall-%E5%AF%B9%E4%BA%8E%E5%8D%95%E4%B8%AA-omega_m-%E6%98%AF"><span class="toc-number"></span> <span class="toc-text">🔍 拆开看，(\mathcal {L}) 对于单个 (\omega_m) 是：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%90%E9%A1%B9%E5%AF%B9-omega_m-%E6%B1%82%E5%AF%BC"><span class="toc-number"></span> <span class="toc-text">🧮 逐项对 ωm\omega_mωm​ 求导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A1%B9"><span class="toc-number">1.</span> <span class="toc-text">第一项：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A1%B9%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">第二项（关键点）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A1%B9"><span class="toc-number">3.</span> <span class="toc-text">第三项：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%8A%E4%B8%89%E9%A1%B9%E5%8A%A0%E8%B5%B7%E6%9D%A5%E5%BE%97%E5%88%B0%E5%81%8F%E5%AF%BC"><span class="toc-number"></span> <span class="toc-text">🔚 把三项加起来，得到偏导：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AD%A6%E5%88%B0%E4%BB%80%E4%B9%88"><span class="toc-number"></span> <span class="toc-text">🎯 总结一下你学到什么：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">3. 空间域的划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%90%8E%E7%BB%AD%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">4. 后续分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E8%87%AA%E7%9B%B8%E5%85%B3spatial-auto-correlation-sa%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">空间自相关（Spatial Auto-correlation, SA）的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%A9%BA%E9%97%B4%E8%87%AA%E7%9B%B8%E5%85%B3"><span class="toc-number"></span> <span class="toc-text">1. 什么是空间自相关？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-local-getis-and-ords-g_i-%E7%BB%9F%E8%AE%A1%E9%87%8F"><span class="toc-number"></span> <span class="toc-text">2. Local Getis and Ord’s GiG_iGi​ 统计量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-sa-%E5%9C%A8-ensdd-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">3. SA 在 EnSDD 中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">4. 具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%E8%AE%A1%E7%AE%97%E5%B1%80%E9%83%A8%E7%A9%BA%E9%97%B4%E8%87%AA%E7%9B%B8%E5%85%B3"><span class="toc-number">1.</span> <span class="toc-text">步骤 1：计算局部空间自相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2wilcoxon-%E6%A3%80%E9%AA%8C"><span class="toc-number">2.</span> <span class="toc-text">步骤 2：Wilcoxon 检验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3%E5%8F%AF%E8%A7%86%E5%8C%96%E5%92%8C%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">步骤 3：可视化和分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">5. 实例解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1%E4%BA%BA%E7%B1%BB%E5%89%8D%E9%A2%9D%E5%8F%B6%E7%9A%AE%E5%B1%82dlpfc"><span class="toc-number">1.</span> <span class="toc-text">案例 1：人类前额叶皮层（DLPFC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2%E4%B9%B3%E8%85%BA%E7%99%8C%E8%82%BF%E7%98%A4%E5%8C%BA%E5%9F%9F"><span class="toc-number">2.</span> <span class="toc-text">案例 2：乳腺癌肿瘤区域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">6. 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rctdrobust-cell-type-decomposition"><span class="toc-number">1.</span> <span class="toc-text">RCTD（Robust Cell Type Decomposition）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-rctd"><span class="toc-number"></span> <span class="toc-text">1. 什么是 RCTD？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-rctd-%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">2. RCTD 计算过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E7%BB%86%E8%83%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.</span> <span class="toc-text">(1) 计算细胞类型的 “特征”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%A1%E7%AE%97-srt-%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%AF%8F%E4%B8%AA-spot-%E7%9A%84%E5%9F%BA%E5%9B%A0%E8%A1%A8%E8%BE%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">(2) 计算 SRT 数据中每个 spot 的基因表达模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E8%BF%87%E6%9D%83%E9%87%8D%E4%BC%98%E5%8C%96%E5%88%86%E8%A7%A3%E7%BB%86%E8%83%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">(3) 通过权重优化分解细胞类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BD%92%E4%B8%80%E5%8C%96-%E8%AE%A1%E7%AE%97%E7%BB%86%E8%83%9E%E7%B1%BB%E5%9E%8B%E5%88%86%E5%B8%83"><span class="toc-number">4.</span> <span class="toc-text">(4) 归一化 &amp; 计算细胞类型分布</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-rctd-%E5%9C%A8-ensdd-%E7%A0%94%E7%A9%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">3. RCTD 在 EnSDD 研究中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9C%A8%E4%B9%B3%E8%85%BA%E7%99%8C%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">(1) 在乳腺癌数据中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9C%A8%E5%89%8D%E5%88%97%E8%85%BA%E7%99%8C%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">(2) 在前列腺癌数据中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%A8%E5%8D%B5%E5%B7%A2%E7%99%8C%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">(3) 在卵巢癌数据中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-rctd-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number"></span> <span class="toc-text">4. RCTD 与其他方法的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BB%93%E8%AE%BA"><span class="toc-number"></span> <span class="toc-text">5. 结论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#puritypur%E7%BA%AF%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">Purity（Pur，纯度）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-purity-%E5%85%AC%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">1. Purity 公式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-purity-%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B"><span class="toc-number"></span> <span class="toc-text">2. Purity 计算示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">1.</span> <span class="toc-text">(1) 示例数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%A1%E7%AE%97%E6%AF%8F%E4%B8%AA%E8%81%9A%E7%B1%BB%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B1%BB%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">(2) 计算每个聚类的最大类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%A1%E7%AE%97-purity"><span class="toc-number">3.</span> <span class="toc-text">(3) 计算 Purity</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-purity-%E5%9C%A8-ensdd-%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">3. Purity 在 EnSDD 论文中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.</span> <span class="toc-text">实验结果示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-purity-%E4%B8%8E-adjusted-rand-indexari%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">4. Purity 与 Adjusted Rand Index（ARI）的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BB%93%E8%AE%BA-2"><span class="toc-number"></span> <span class="toc-text">5. 结论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#run_individual_clustering"><span class="toc-number"></span> <span class="toc-text">run_individual_clustering</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%92%8C%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">🧠 函数定义和参数说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%E4%BB%8E-seurat-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%8F%90%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">2.</span> <span class="toc-text">📦 步骤一：从 Seurat 对象中提取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%E6%9E%84%E9%80%A0-singlecellexperiment-%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">📦 步骤二：构造 SingleCellExperiment 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%89%E5%AF%BB%E6%89%BE%E9%AB%98%E5%8F%98%E5%9F%BA%E5%9B%A0%E5%B9%B6-pca"><span class="toc-number">4.</span> <span class="toc-text">📈 步骤三：寻找高变基因并 PCA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E5%9B%9B%E9%A2%84%E5%A4%84%E7%90%86%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF"><span class="toc-number">5.</span> <span class="toc-text">🧼 步骤四：预处理空间信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%B8%8F-%E6%AD%A5%E9%AA%A4%E4%BA%94%E8%AE%BE%E7%BD%AE-gamma-%E8%B6%85%E5%8F%82%E6%95%B0%E5%B9%B3%E5%8F%B0%E7%89%B9%E5%BC%82"><span class="toc-number">6.</span> <span class="toc-text">🎚️ 步骤五：设置 gamma 超参数（平台特异）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E5%85%AD%E6%89%A7%E8%A1%8C-bayesspace-%E8%81%9A%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">🔁 步骤六：执行 BayesSpace 聚类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%83%E6%8F%90%E5%8F%96%E8%81%9A%E7%B1%BB%E7%BB%93%E6%9E%9C"><span class="toc-number">8.</span> <span class="toc-text">📊 步骤七：提取聚类结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E6%8E%89%E7%9A%84%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E5%AF%BB%E6%89%BE%E6%9C%80%E4%BD%B3%E8%81%9A%E7%B1%BB%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">🔁（注释掉的代码）自动寻找最佳聚类数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-number">10.</span> <span class="toc-text">🔚 返回结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D"><span class="toc-number">11.</span> <span class="toc-text">✅ 总结一句话：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">12.</span> <span class="toc-text">🧠 函数定义及参数说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8F%90%E5%8F%96%E5%9B%BE%E5%83%8F%E8%B7%AF%E5%BE%84"><span class="toc-number">13.</span> <span class="toc-text">📦 1. 提取图像路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%A0%E8%BD%BD-python-%E8%84%9A%E6%9C%AC"><span class="toc-number">14.</span> <span class="toc-text">🐍 2. 加载 Python 脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B0%83%E7%94%A8-python-%E7%9A%84-run_spagcn-%E5%87%BD%E6%95%B0"><span class="toc-number">15.</span> <span class="toc-text">🚀 3. 调用 Python 的 run_spaGCN 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8A%A0%E8%BD%BD%E7%BB%93%E6%9E%9C%E5%B9%B6%E5%A4%84%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">📁 4. 加载结果并处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-spagcn-%E8%81%9A%E7%B1%BB%E7%BB%93%E6%9E%9C%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%90%AB%E6%9C%89-0-%E7%B1%BB-%E8%B0%83%E6%95%B4%E4%B8%BA%E4%BB%8E1%E5%BC%80%E5%A7%8B"><span class="toc-number">17.</span> <span class="toc-text">🔢 5. SpaGCN 聚类结果中可能含有 &quot;0&quot; 类 → 调整为从 1 开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%A0%B9%E6%8D%AE-seurat-%E7%9A%84%E5%88%97%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E8%81%9A%E7%B1%BB%E7%BB%93%E6%9E%9C%E5%B9%B6%E6%B8%85%E7%90%86%E4%B8%AD%E9%97%B4%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">18.</span> <span class="toc-text">✅ 6. 根据 Seurat 的列顺序排列聚类结果，并清理中间文件夹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D-2"><span class="toc-number">19.</span> <span class="toc-text">🎉 总结一句话：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%89%A7%E8%A1%8C-stagate-%E8%81%9A%E7%B1%BB"><span class="toc-number">20.</span> <span class="toc-text">✅ 1. 判断是否执行 STAGATE 聚类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B0%83%E7%94%A8-apply_stagate-%E5%87%BD%E6%95%B0%E5%B9%B6%E8%AE%A1%E6%97%B6"><span class="toc-number">21.</span> <span class="toc-text">🧪 2. 调用 apply_STAGATE() 函数并计时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BF%9D%E5%AD%98-stagate-%E8%81%9A%E7%B1%BB%E7%BB%93%E6%9E%9C%E5%88%B0%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1%E4%B8%AD"><span class="toc-number">22.</span> <span class="toc-text">📝 3. 保存 STAGATE 聚类结果到列表对象中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%9C%89%E5%8C%85%E5%90%AB-na-%E7%9A%84%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95%E6%B8%85%E7%90%86%E6%97%A0%E6%95%88%E7%BB%93%E6%9E%9C"><span class="toc-number">23.</span> <span class="toc-text">🧼 4. 检查是否有包含 NA 的聚类方法，清理无效结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%A0%E9%99%A4%E5%90%AB-na-%E7%9A%84%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">24.</span> <span class="toc-text">🧽 5. 删除含 NA 的聚类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%81%9A%E7%B1%BB%E5%90%91%E9%87%8F%E8%BD%AC%E4%B8%BA%E7%9F%A9%E9%98%B5%E5%90%8E%E7%BB%AD%E5%8F%AF%E7%94%A8%E4%BA%8E-ensemble"><span class="toc-number">25.</span> <span class="toc-text">📐 6. 聚类向量转为矩阵（后续可用于 ensemble）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%89%93%E5%8C%85%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C%E4%B8%BA%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">26.</span> <span class="toc-text">📦 7. 打包最终结果为列表对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%8F%AF%E9%80%89%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%9C%E5%88%B0-rdata"><span class="toc-number">27.</span> <span class="toc-text">💾 8. 可选保存结果到 .RData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%BF%94%E5%9B%9E%E6%9C%80%E7%BB%88%E8%81%9A%E7%B1%BB%E7%BB%93%E6%9E%9C%E5%AF%B9%E8%B1%A1"><span class="toc-number">28.</span> <span class="toc-text">🔚 9. 返回最终聚类结果对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number"></span> <span class="toc-text">🔁 总结一下这段代码做了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spatial-domain-detection"><span class="toc-number"></span> <span class="toc-text">Spatial domain detection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="toc-number"></span> <span class="toc-text">🔧 准备阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%A4%9A%E4%B8%AA%E8%81%9A%E7%B1%BB%E6%95%B0%E8%AE%BE%E5%AE%9A"><span class="toc-number"></span> <span class="toc-text">🔁 遍历多个聚类数设定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%B7%B2%E6%9C%89%E7%9A%84%E8%81%9A%E7%B1%BB%E7%BB%93%E6%9E%9C-rdata"><span class="toc-number"></span> <span class="toc-text">📦 加载已有的聚类结果 .RData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B1%BB%E7%BB%93%E6%9E%9C%E8%9E%8D%E5%90%88ensemble"><span class="toc-number"></span> <span class="toc-text">🧠 聚类结果融合（Ensemble）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#louvain-%E8%81%9A%E7%B1%BB%E5%9F%BA%E4%BA%8E%E9%9B%86%E6%88%90%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%BD%91%E7%BB%9C"><span class="toc-number"></span> <span class="toc-text">📊 Louvain 聚类（基于集成的相似度网络）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B1%BB%E7%BB%93%E6%9E%9C%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B9%B6%E4%BF%9D%E5%AD%98"><span class="toc-number"></span> <span class="toc-text">📝 聚类结果格式化并保存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E5%B9%B6%E5%8A%A0%E5%85%A5%E6%80%BB%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">🗂 结果写入文件并加入总表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-python-%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">🖼 调用 Python 进行聚类可视化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E7%90%86%E6%B3%A8%E9%87%8A%E6%8E%89"><span class="toc-number"></span> <span class="toc-text">🧹 清理（注释掉）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D-3"><span class="toc-number"></span> <span class="toc-text">✅ 总结一句话：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#solve_ensemble-%E5%85%B3%E9%94%AE"><span class="toc-number"></span> <span class="toc-text">solve_ensemble 关键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E7%AE%80%E8%BF%B0"><span class="toc-number"></span> <span class="toc-text">🧠 目标简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number"></span> <span class="toc-text">📥 输入参数说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="toc-number"></span> <span class="toc-text">🔧 算法结构详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">1. 参数初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9D%83%E9%87%8D%E5%92%8C%E5%85%B1%E8%AF%86%E7%9F%A9%E9%98%B5"><span class="toc-number">2.</span> <span class="toc-text">2. 初始化权重和共识矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%A1%E7%AE%97%E5%88%9D%E5%A7%8B-loss-%E5%92%8C-lambda%E5%A6%82%E6%9C%AA%E6%8C%87%E5%AE%9A"><span class="toc-number">3.</span> <span class="toc-text">3. 计算初始 loss 和 lambda（如未指定）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BB%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3%E4%BC%98%E5%8C%96%E6%9D%83%E9%87%8D%E5%92%8C%E5%85%B1%E8%AF%86%E7%9F%A9%E9%98%B5"><span class="toc-number">4.</span> <span class="toc-text">4. 主循环：迭代优化权重和共识矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A41%E6%9B%B4%E6%96%B0%E6%9D%83%E9%87%8D"><span class="toc-number">4.1.</span> <span class="toc-text">🌀 步骤 1：更新权重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A42%E6%9B%B4%E6%96%B0%E5%85%B1%E8%AF%86%E7%9F%A9%E9%98%B5"><span class="toc-number">4.2.</span> <span class="toc-text">🌀 步骤 2：更新共识矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A43%E8%AE%A1%E7%AE%97%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">🌀 步骤 3：计算损失函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%94%B6%E6%95%9B%E5%88%A4%E6%96%AD%E4%B8%8E%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.</span> <span class="toc-text">5. 收敛判断与跳出循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-number">6.</span> <span class="toc-text">6. 返回结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E8%BE%93%E5%87%BA%E8%A7%A3%E9%87%8A"><span class="toc-number"></span> <span class="toc-text">✅ 最终输出解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E5%BC%A0%E5%9B%BE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">📌 总结一张图（逻辑结构）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#utils"><span class="toc-number"></span> <span class="toc-text">utils</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#data_process"><span class="toc-number">1.</span> <span class="toc-text">data_process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text">🔧 函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%A1%A8%E8%BE%BE%E7%9F%A9%E9%98%B5"><span class="toc-number">3.</span> <span class="toc-text">📂 读取表达矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%9D%90%E6%A0%87%E4%BF%A1%E6%81%AF"><span class="toc-number">4.</span> <span class="toc-text">📍 读取坐标信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90-counts-%E5%92%8C%E5%9D%90%E6%A0%87"><span class="toc-number">5.</span> <span class="toc-text">🧬 对齐 counts 和坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-seurat-%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">🔬 创建 Seurat 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">📊 标准化处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%8F%98%E5%BC%82%E5%9F%BA%E5%9B%A0%E9%80%89%E6%8B%A9"><span class="toc-number">8.</span> <span class="toc-text">📈 高变异基因选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pca%E9%99%8D%E7%BB%B4"><span class="toc-number">9.</span> <span class="toc-text">📐 PCA 降维</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%B8%8F-%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E4%BF%A1%E6%81%AF%E6%9C%AA%E4%BD%BF%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">🖼️ 处理图片信息（未使用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C-2"><span class="toc-number">11.</span> <span class="toc-text">🔁 返回结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">12.</span> <span class="toc-text">✅ 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clust2mat"><span class="toc-number">13.</span> <span class="toc-text">clust2Mat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-2"><span class="toc-number">14.</span> <span class="toc-text">🔧 函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%A0%B7%E6%9C%AC%E6%95%B0%E9%87%8F"><span class="toc-number">15.</span> <span class="toc-text">📏 获取样本数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%85%B1%E8%81%9A%E7%B1%BB%E7%9F%A9%E9%98%B5"><span class="toc-number">16.</span> <span class="toc-text">📐 构造共聚类矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#outermemb-memb-fun"><span class="toc-number">16.1.</span> <span class="toc-text">✅ outer(memb, memb, FUN &#x3D; &quot;&#x3D;&#x3D;&quot;)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asnumeric"><span class="toc-number">16.2.</span> <span class="toc-text">✅ as.numeric(...)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#outer1n-1n"><span class="toc-number">16.3.</span> <span class="toc-text">✅ outer(1:N, 1:N, &quot;&#x3D;&#x3D;&quot;)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E7%9B%B8%E5%87%8F"><span class="toc-number">16.4.</span> <span class="toc-text">✅ 两者相减：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">16.5.</span> <span class="toc-text">✅ 举个例子：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%B8%8F-%E8%AE%BE%E7%BD%AE%E8%A1%8C%E5%88%97%E5%90%8D"><span class="toc-number">17.</span> <span class="toc-text">🏷️ 设置行列名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%9F%A9%E9%98%B5"><span class="toc-number">18.</span> <span class="toc-text">🔁 返回矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">19.</span> <span class="toc-text">✅ 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">20.</span> <span class="toc-text">👀 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solve_ensemble"><span class="toc-number">21.</span> <span class="toc-text">solve_ensemble</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E7%9B%AE%E6%A0%87%E6%A6%82%E8%BF%B0"><span class="toc-number"></span> <span class="toc-text">🧩 1. 函数目标概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%B8%8F-2-%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number"></span> <span class="toc-text">⚙️ 2. 输入参数说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E8%BF%AD%E4%BB%A3%E9%83%A8%E5%88%86%E8%A7%A3%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">🔁 3. 核心迭代部分解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">✅ 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%9B%B4%E6%96%B0"><span class="toc-number">2.</span> <span class="toc-text">🔄 迭代更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9B%B4%E6%96%B0%E6%AF%8F%E4%B8%AA%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A6%BB%E6%95%A3%E5%BA%A6"><span class="toc-number">2.1.</span> <span class="toc-text">① 更新每个相似度矩阵的 “离散度”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E5%8A%A8%E8%AE%BE%E7%BD%AE-lambda%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%BE%E7%BD%AE%E4%B8%BA-null"><span class="toc-number">2.2.</span> <span class="toc-text">② 自动设置 lambda（如果第一次设置为 NULL）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%9D%83%E9%87%8D-w"><span class="toc-number">3.</span> <span class="toc-text">✅ 更新权重 w</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%AE%A1%E7%AE%97-h"><span class="toc-number">4.</span> <span class="toc-text">✅ 重新计算 H</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">✅ 计算损失函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E8%BE%93%E5%87%BA"><span class="toc-number"></span> <span class="toc-text">✅ 最终输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D-4"><span class="toc-number"></span> <span class="toc-text">🎯 总结一句话：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number"></span> <span class="toc-text">🚀 应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#weighted_average"><span class="toc-number">1.</span> <span class="toc-text">weighted_average</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%E5%88%86%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">✅ 函数功能分解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8F%90%E5%8F%96%E9%9D%9E%E9%9B%B6%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">1. 提取非零位置：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84%E9%9D%9E%E9%9B%B6%E5%80%BC%E5%92%8C%E6%9D%83%E9%87%8D"><span class="toc-number">4.</span> <span class="toc-text">2. 获取对应的非零值和权重：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%A0%E6%9D%83%E6%B1%82%E5%92%8C"><span class="toc-number">5.</span> <span class="toc-text">3. 加权求和：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">6.</span> <span class="toc-text">4. 返回值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90-2"><span class="toc-number">7.</span> <span class="toc-text">✅ 举个例子：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">8.</span> <span class="toc-text">🧠 总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patch_deal"><span class="toc-number">9.</span> <span class="toc-text">patch_deal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%92%8C%E5%8F%82%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">🔧 函数定义和参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">参数说明：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%E6%AD%A5%E9%AA%A4"><span class="toc-number"></span> <span class="toc-text">🧩 代码解析步骤：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A3%80%E6%9F%A5%E8%81%9A%E7%B1%BB%E5%88%97%E5%90%8D"><span class="toc-number">1.</span> <span class="toc-text">1. 检查聚类列名：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%87%86%E5%A4%87%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">2. 初始化和准备变量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8C%89%E7%85%A7%E5%B7%B2%E6%9C%89%E9%A1%BA%E5%BA%8F%E5%AF%B9-clustering_df-%E8%BF%9B%E8%A1%8C%E9%87%8D%E6%8E%92"><span class="toc-number">3.</span> <span class="toc-text">3. 按照已有顺序对 clustering_df 进行重排：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BB%E5%BE%AA%E7%8E%AF%E5%B0%86%E7%94%A8%E6%88%B7%E7%9A%84%E8%81%9A%E7%B1%BB%E6%A0%87%E7%AD%BE%E8%BD%AC%E4%B8%BA-similarity-matrix"><span class="toc-number">4.</span> <span class="toc-text">4. 主循环：将用户的聚类标签转为 similarity matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E9%87%8C%E8%B0%83%E7%94%A8%E4%BA%86%E4%BD%A0%E4%B9%8B%E5%89%8D%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">🚩这里调用了你之前的函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95%E5%90%8D"><span class="toc-number">6.</span> <span class="toc-text">5. 更新方法名：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">7.</span> <span class="toc-text">✅ 返回值：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%9B%BE%E7%A4%BA"><span class="toc-number"></span> <span class="toc-text">🔁 总结图示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plot_sankey"><span class="toc-number"></span> <span class="toc-text">plot_Sankey</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-create_df_sankey-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">🔧 1. create_df_Sankey 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">参数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-number">3.</span> <span class="toc-text">返回值：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-plot_sankey_fun-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">📊 2. plot_sankey_fun 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">输入：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.</span> <span class="toc-text">关键步骤：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-plot_sankey-%E5%87%BD%E6%95%B0%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">🌉 3. plot_sankey 函数（主函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-2"><span class="toc-number">1.</span> <span class="toc-text">参数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">过程详解：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#step-1%E4%B8%A4%E4%B8%A4%E5%88%97%E4%B9%8B%E9%97%B4%E8%B0%83%E7%94%A8-create_df_sankey"><span class="toc-number">2.1.</span> <span class="toc-text">Step 1：两两列之间调用 create_df_Sankey ：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-2%E4%B8%BA%E4%BA%86%E9%81%BF%E5%85%8D%E8%8A%82%E7%82%B9%E5%90%8D%E5%86%B2%E7%AA%81%E4%B8%BA%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E5%8A%A0%E4%B8%8A%E5%89%8D%E7%BC%80"><span class="toc-number">2.2.</span> <span class="toc-text">Step 2：为了避免节点名冲突，为每个节点加上前缀：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-3%E4%BD%BF%E7%94%A8-reshape2melt-%E6%8A%8A%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2%E6%88%90%E9%95%BF%E6%A0%BC%E5%BC%8F%E5%B9%B6%E8%BF%87%E6%BB%A4"><span class="toc-number">2.3.</span> <span class="toc-text">Step 3：使用 reshape2::melt 把矩阵转换成长格式，并过滤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-4%E6%B1%87%E6%80%BB%E6%89%80%E6%9C%89%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF%E5%88%B0-links"><span class="toc-number">2.4.</span> <span class="toc-text">Step 4：汇总所有连接信息到 links ：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-5%E8%B0%83%E7%94%A8-plot_sankey_fun-%E7%BB%98%E5%9B%BE"><span class="toc-number">2.5.</span> <span class="toc-text">Step 5：调用 plot_sankey_fun() 绘图。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number"></span> <span class="toc-text">📌 总结</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/article/scRNA%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" rel="bookmark" title="scRNA论文笔记">scRNA论文笔记</a></li><li><a href="/article/What-is-A-Cell-Type/" rel="bookmark" title="What_is_A_Cell_Type">What_is_A_Cell_Type</a></li><li><a href="/article/Cell-Review-What-is-a-cell-type-and-how-to-define-it/" rel="bookmark" title="Cell_Review_What_is_a_cell_type_and_how_to_define_it">Cell_Review_What_is_a_cell_type_and_how_to_define_it</a></li><li><a href="/article/Benchmarking-spatial-claustering-methods-with-spatially-resolved-transcriptomic-data/" rel="bookmark" title="Benchmarking-spatial-claustering-methods-with-spatially-resolved-transcriptomic-data">Benchmarking-spatial-claustering-methods-with-spatially-resolved-transcriptomic-data</a></li><li><a href="/article/%E8%AE%BA%E6%96%87ppt1/" rel="bookmark" title="论文ppt1">论文ppt1</a></li><li><a href="/article/Matching-Anything-by-Segmenting-Anything/" rel="bookmark" title="Matching_Anything_by_Segmenting_Anything">Matching_Anything_by_Segmenting_Anything</a></li><li><a href="/article/SpaGCN/" rel="bookmark" title="SpaGCN">SpaGCN</a></li><li><a href="/article/STAGATE/" rel="bookmark" title="STAGATE">STAGATE</a></li><li><a href="/article/MENDER/" rel="bookmark" title="MENDER">MENDER</a></li><li><a href="/article/scanpy%E6%95%B0%E6%8D%AE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/" rel="bookmark" title="scanpy数据使用笔记">scanpy数据使用笔记</a></li><li><a href="/article/BayesSpace/" rel="bookmark" title="BayesSpace">BayesSpace</a></li><li><a href="/article/%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AE%B0%E5%BD%95/" rel="bookmark" title="数据集记录">数据集记录</a></li><li><a href="/article/DeepST/" rel="bookmark" title="DeepST">DeepST</a></li><li class="active"><a href="/article/EnSDD/" rel="bookmark" title="EnSDD">EnSDD</a></li><li><a href="/article/domain%E5%86%85%E5%AE%B9%E7%9A%84%E6%80%BB%E7%BB%93/" rel="bookmark" title="对spatial domain内容的总结">对spatial domain内容的总结</a></li><li><a href="/article/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%B1%87%E6%80%BB/" rel="bookmark" title="毕业设计文档汇总">毕业设计文档汇总</a></li><li><a href="/article/scPerturb/" rel="bookmark" title="scPerturb">scPerturb</a></li><li><a href="/article/GEARS/" rel="bookmark" title="GEARS">GEARS</a></li><li><a href="/article/CellOT/" rel="bookmark" title="CellOT">CellOT</a></li><li><a href="/article/Transport/" rel="bookmark" title="Optimal Transport">Optimal Transport</a></li><li><a href="/article/Simple-Perform-better/" rel="bookmark" title="Simple_Perform_better">Simple_Perform_better</a></li><li><a href="/article/Systema/" rel="bookmark" title="Systema">Systema</a></li><li><a href="/article/Virtual-Challenge/" rel="bookmark" title="Virtual_Challenge">Virtual_Challenge</a></li><li><a href="/article/scGPT/" rel="bookmark" title="scGPT">scGPT</a></li><li><a href="/article/scFoundation/" rel="bookmark" title="scFoundation">scFoundation</a></li><li><a href="/article/GeneFormer/" rel="bookmark" title="GeneFormer">GeneFormer</a></li><li><a href="/article/CellFM/" rel="bookmark" title="CellFM">CellFM</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Lemon Sour" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Lemon Sour</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">103</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">26</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">64</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FtZW50aXJheg==" title="https:&#x2F;&#x2F;github.com&#x2F;Amentiraz"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9kc2ZseS04" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;dsfly-8"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE1MTc2ODUzMzM=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1517685333"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnZpb2xlbW9uQDE2My5jb20=" title="mailto:violemon@163.com"><i class="ic i-envelope"></i></span> <span class="exturl item bangumi" data-url="aHR0cHM6Ly9iYW5ndW1pLnR2L2FuaW1lL2xpc3QvNjY4MDE2" title="https:&#x2F;&#x2F;bangumi.tv&#x2F;anime&#x2F;list&#x2F;668016"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-magic"></i>关于</a><ul class="submenu"><li class="item"><a href="/author/" rel="section"><i class="ic i-user"></i>本人</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-cloud"></i>其它</a><ul class="submenu"><li class="item"><a href="/music/" rel="section"><i class="ic i-music"></i>音乐区</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>朋友</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/article/DeepST/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/music/%E5%B8%B8%E8%A7%81%E5%92%8C%E5%BC%A6/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/code/" title="分类于 代码">代码</a> <i class="ic i-angle-right"></i> <a href="/categories/code/python/" title="分类于 python">python</a></div><span><a href="/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python4/" title="系统学习python（四）对于Scanpy的整理">系统学习python（四）对于Scanpy的整理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/code/" title="分类于 代码">代码</a> <i class="ic i-angle-right"></i> <a href="/categories/code/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" title="分类于 编程语言">编程语言</a></div><span><a href="/code/%E7%BB%93%E6%9E%84/" title="结构">结构</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/article/" title="分类于 论文">论文</a></div><span><a href="/article/Transport/" title="Optimal Transport">Optimal Transport</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/article/" title="分类于 论文">论文</a></div><span><a href="/article/Simple-Perform-better/" title="Simple_Perform_better">Simple_Perform_better</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/code/" title="分类于 代码">代码</a> <i class="ic i-angle-right"></i> <a href="/categories/code/OI/" title="分类于 OI">OI</a></div><span><a href="/code/Tarjan/" title="Tarjan">Tarjan</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/article/" title="分类于 论文">论文</a></div><span><a href="/article/CellFM/" title="CellFM">CellFM</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/life/" title="分类于 生活">生活</a></div><span><a href="/2025%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" title="2025年终总结">2025年终总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/code/" title="分类于 代码">代码</a> <i class="ic i-angle-right"></i> <a href="/categories/code/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/" title="分类于 数学建模">数学建模</a></div><span><a href="/code/%E5%88%86%E5%B8%83%E5%BC%8FMOM%E4%BD%9C%E4%B8%9A/" title="分布式MOM作业">分布式MOM作业</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/life/" title="分类于 生活">生活</a> <i class="ic i-angle-right"></i> <a href="/categories/life/%E6%80%9D%E8%80%83/" title="分类于 思考">思考</a></div><span><a href="/life/%E5%AF%B9%E7%95%8F%E9%9A%BE%E6%83%85%E7%BB%AA%E7%9A%84%E5%88%86%E6%9E%90/" title="对畏难情绪的分析">对畏难情绪的分析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/article/" title="分类于 论文">论文</a></div><span><a href="/article/GeneFormer/" title="GeneFormer">GeneFormer</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Lemon Sour @ Amentiraz</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"article/EnSDD/",favicon:{show:"⁽⁽ଘ( ˊᵕˋ )ଓ⁾⁾",hide:"(つд⊂)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->