{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amentiraz • All posts by \"topsis\" tag",
    "description": "",
    "home_page_url": "http://Amentiraz.github.io",
    "items": [
        {
            "id": "http://amentiraz.github.io/2021/09/22/TOPSIS-MATLAB/",
            "url": "http://amentiraz.github.io/2021/09/22/TOPSIS-MATLAB/",
            "title": "TOPSIS-MATLAB",
            "date_published": "2021-09-22T10:35:13.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-fBtQUjgF\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"1401456829\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>代码如下</p>\n<span id=\"more\"></span>\n<h3 id=\"主函数代码\"><a class=\"markdownIt-Anchor\" href=\"#主函数代码\">#</a> 主函数代码</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;clc</span><br><span class=\"line\">load data_water_quality.mat</span><br><span class=\"line\">//正向化</span><br><span class=\"line\">[n,m] = size ( X ) ;</span><br><span class=\"line\">disp ( [&#x27;共有&#x27;num2str ( n ) &#x27;个评价对象,&#x27;num2str ( m ) &#x27;个评价指标] ) </span><br><span class=\"line\">Judge = input ([&#x27;这&#x27;num2str(m)&#x27;个指标是否需要经过正向化处理，需要输入1，不需要输入0:&#x27;]);</span><br><span class=\"line\">if Judge == 1 </span><br><span class=\"line\">    Position = input (&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]:&#x27;) ; </span><br><span class=\"line\">    disp ( &#x27;请输入需要处理的这些列的指标类型（1:极小型，2:中间型，3:区间型）&#x27;) </span><br><span class=\"line\">    Type = input (&#x27;例如2极小，3区间，6中间就输入[1,3,2]:&#x27; ) ;</span><br><span class=\"line\">    for i = 1 : size ( Position , 2 ) </span><br><span class=\"line\">    X ( : , Position ( i ) ) = Positivization ( X ( : , Position ( i )  ) , Type ( i ) , Position ( i ) ) ;</span><br><span class=\"line\">    //Positization是我们定义的函数</span><br><span class=\"line\">    end</span><br><span class=\"line\">    disp (&#x27;正向化后的举证X=&#x27; ) </span><br><span class=\"line\">    disp ( X ) </span><br><span class=\"line\">end</span><br><span class=\"line\">//对正向化对举证进行标准化</span><br><span class=\"line\">Z = X ./ repmat ( sum ( X .* X ) .^ 0.5 , n , 1 ) ;</span><br><span class=\"line\">disp ( &#x27;标准化矩阵Z=&#x27; ） </span><br><span class=\"line\">disp (Z) </span><br><span class=\"line\">//计算最大值与最小值的距离，并算出得分</span><br><span class=\"line\">D_P = sum ( [Z - repmat ( max ( Z ) , n , 1 ) .^ 2 ] , 2 ) .^ 0.5 ; </span><br><span class=\"line\">D_N = sum ( [Z - repmat ( min ( Z ) , n , 1 ) .^ 2 ] , 2 ) .^ 0.5 ;   </span><br><span class=\"line\">S = D_N ./ ( D_P + D_N ) ; </span><br><span class=\"line\">disp ( &#x27;最后的得分为：&#x27; ) </span><br><span class=\"line\">stand_S = S / sum ( S ) </span><br><span class=\"line\">[sorted_S , index] = sort ( stand_S , &#x27;descend&#x27; ) </span><br></pre></td></tr></table></figure>\n<h3 id=\"positivization函数\"><a class=\"markdownIt-Anchor\" href=\"#positivization函数\">#</a> Positivization 函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ posit_x ] = Positivization ( x , type , i ) </span><br><span class=\"line\">    if type == 1 </span><br><span class=\"line\">    disp([&#x27;第&#x27;num2str ( i ) &#x27;列是极小型，正在正向化&#x27;]) </span><br><span class=\"line\">    posit_x = Min2Max ( x ) ; </span><br><span class=\"line\">    disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成])</span><br><span class=\"line\">    disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;)</span><br><span class=\"line\">    else if type == 2 </span><br><span class=\"line\">    dis ( [&#x27;第&#x27;num2str ( i ) &#x27;列是中间型&#x27;])</span><br><span class=\"line\">    best = input (&#x27;请输入最佳的那一个值:&#x27;) ; </span><br><span class=\"line\">    posit_x = Mid2Max ( x , best ) ; </span><br><span class=\"line\">    disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成]) ;</span><br><span class=\"line\">    disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;)</span><br><span class=\"line\">    else if type == 3                                          </span><br><span class=\"line\">    dis ( [&#x27;第&#x27;num2str ( i ) &#x27;列是区间型&#x27;])                    </span><br><span class=\"line\">    a = input (&#x27;请输入区间的下界&#x27;) ;                   </span><br><span class=\"line\">    b = input (&#x27;请输入区间的上界&#x27;) ;         </span><br><span class=\"line\">    posit_x = Inter2Max ( x , a , b ) ;                           </span><br><span class=\"line\">    disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成]) ;              </span><br><span class=\"line\">    disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;)</span><br><span class=\"line\">    else </span><br><span class=\"line\">    disp (&#x27;没有这种类型的指标请检查Type向量中是否有除了1、2、3以外的其他值&#x27;) </span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"min2maxx函数\"><a class=\"markdownIt-Anchor\" href=\"#min2maxx函数\">#</a> Min2Max (x) 函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ posit_x ] = Min2Max ( x ) </span><br><span class=\"line\">    posit_x = max ( x ) - x ; </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"mid2maxxbest函数\"><a class=\"markdownIt-Anchor\" href=\"#mid2maxxbest函数\">#</a> Mid2Max (x,best) 函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ posit_x ] = Mid2Max ( x , best )  </span><br><span class=\"line\">    M = max ( abs ( x - best ) ) ; </span><br><span class=\"line\">    posit_x = 1 - abs ( x - best ) / M ; </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"inter2maxxab函数\"><a class=\"markdownIt-Anchor\" href=\"#inter2maxxab函数\">#</a> Inter2Max (x,a,b) 函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ posit_x ] = Inter2Max ( x , a , b ) ; </span><br><span class=\"line\">    M = max ([ a - min ( x ) , max ( x ) - b ] ) ; </span><br><span class=\"line\">    r_x = size ( x , 1 ) ; </span><br><span class=\"line\">    posit_x = zeros ( r_x , 1 ) ; </span><br><span class=\"line\">    for i = 1 : r_x</span><br><span class=\"line\">        if x(i) &lt; a </span><br><span class=\"line\">            posit_x(i) = 1 - ( a - x(i) ) / M ;</span><br><span class=\"line\">        else if x(i) &gt; b </span><br><span class=\"line\">            posit_x(i) = 1 - ( x(i) - b ) / M ; </span><br><span class=\"line\">        else posit_x(i) = 1 ; </span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"原始矩阵正向化\"><a class=\"markdownIt-Anchor\" href=\"#原始矩阵正向化\">#</a> 原始矩阵正向化</h3>\n<p>将 Excel 内的数据直接粘贴进 matlab 里，赋值给变量<br>\n将此变量另存为至与代码相同的目录下<br>\n调用直接用 load xxx.mat</p>\n<h3 id=\"sort函数\"><a class=\"markdownIt-Anchor\" href=\"#sort函数\">#</a> sort 函数</h3>\n<p>sort (A) 若 A 是向量不管是列还是行向量，默认都是对 A 进行升序排序，sort (A) 是默认的升序，而 sort (A,‘descend’) 是降序<br>\n若 A 是矩阵，默认对 A 的割裂进行升序排列<br>\n sort (A , dim) ;<br>\ndim = 1 时 等效于 sort (A) ;<br>\ndim = 2 时 表示对 A 的各列进行升序排列<br>\n若欲爆裂排列前的索引，则可用 [sA,index] = sort ( A , ‘decend’ ) ;<br>\nA = [ 2 , 1 , 3 , 8 ]<br>\nsA = [ 8 , 3 , 2 , 1 ]<br>\nindex = [ 4 , 3 , 1 , 2 ]</p>\n<h3 id=\"定义函数\"><a class=\"markdownIt-Anchor\" href=\"#定义函数\">#</a> 定义函数</h3>\n<p>function [输出变量] = 函数名称（输入变量）<br>\n函数的中间部分都是函数体<br>\n函数的最后要用 end 结尾<br>\n输出变量和输入变量可以有多个，用逗号隔开<br>\n例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ a , b , c ] = test ( d , e , f ) </span><br><span class=\"line\">a = d + e ;</span><br><span class=\"line\">b = e + f ; </span><br><span class=\"line\">c = f + d ; </span><br><span class=\"line\">end </span><br></pre></td></tr></table></figure>\n<h3 id=\"zeros-ones函数\"><a class=\"markdownIt-Anchor\" href=\"#zeros-ones函数\">#</a> zeros, ones 函数</h3>\n<p>zeros ( 3 ) ;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans = </span><br><span class=\"line\">0 0 0 </span><br><span class=\"line\">0 0 0 </span><br><span class=\"line\">0 0 0 </span><br></pre></td></tr></table></figure>\n<p>zeros ( 3 , 1 ) ;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans = </span><br><span class=\"line\">0 </span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p>ones 同理</p>\n",
            "tags": [
                "数学建模",
                "TOPSIS",
                "Matlab"
            ]
        },
        {
            "id": "http://amentiraz.github.io/2021/09/22/TOPSIS%E6%B3%95/",
            "url": "http://amentiraz.github.io/2021/09/22/TOPSIS%E6%B3%95/",
            "title": "TOPSIS法",
            "date_published": "2021-09-22T06:32:59.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-RlvmxlGi\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"537854742\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>TOPSIS 法 (Technique for Order Preference by Similarity to Ideal Solution)<br>\n 可翻译为逼近理想解排序法，也称优劣解距离法<br>\n TOPSIS 法是一种常用的综合评价方法，其能充分利用原始数据的信息，其结果能精确的反映各评价方案之间的差距</p>\n<span id=\"more\"></span>\n<h3 id=\"层次分析法的局限性\"><a class=\"markdownIt-Anchor\" href=\"#层次分析法的局限性\">#</a> 层次分析法的局限性</h3>\n<p>1） 决策层不能太多，太多 n 会很大，潘多矩阵和一致矩阵差距大<br>\n 2）对于已知的指标数据，我们如何利用数据使之更加准确</p>\n<h3 id=\"一个例子\"><a class=\"markdownIt-Anchor\" href=\"#一个例子\">#</a> 一个例子</h3>\n<p>对于如下表格</p>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th>成绩</th>\n<th>排名</th>\n<th>修正后的排名</th>\n<th>评分</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>小明</td>\n<td>89</td>\n<td>2</td>\n<td>3</td>\n<td>3/10=0.3</td>\n</tr>\n<tr>\n<td>小王</td>\n<td>60</td>\n<td>4</td>\n<td>1</td>\n<td>1/10=0.1</td>\n</tr>\n<tr>\n<td>小张</td>\n<td>74</td>\n<td>3</td>\n<td>2</td>\n<td>2/10=0.2</td>\n</tr>\n<tr>\n<td>我</td>\n<td>99</td>\n<td>1</td>\n<td>4</td>\n<td>4/10=0.4</td>\n</tr>\n</tbody>\n</table>\n<p>对于这种评价系统我们可以发现，只要保证排名不变，那么评分就不会改变</p>\n<h4 id=\"优化的想法\"><a class=\"markdownIt-Anchor\" href=\"#优化的想法\">#</a> 优化的想法</h4>\n<p>我们可以取最高的成绩 max = 99<br>\n 最低的成绩 min = 60<br>\n 构造计算评分的公式: (x - min) / ( max - min )<br>\n 然后对于每一个数据进行归一化处理即可<br>\n但同时最高分与最低分的评价是一定的，1&amp;0</p>\n<h4 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\">#</a> 说明</h4>\n<p>为什么不直接将各自的分数除以 100 再进行归一化处理，这样对于数据的关联性还更强<br>\n原因有三点</p>\n<ol>\n<li>比较对象一般远大于两个</li>\n<li>比较的指标往往不是一个方面的</li>\n<li>有很多指标不存在理论上的最大值和最小值，例如衡量经济增长水平的指标：GDP 增速<br>\n故我们最好使用上述优化的想法</li>\n</ol>\n<h4 id=\"拓展问题增加指标个数\"><a class=\"markdownIt-Anchor\" href=\"#拓展问题增加指标个数\">#</a> 拓展问题：增加指标个数</h4>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th>成绩</th>\n<th>与他人争吵的次数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>小明</td>\n<td>89</td>\n<td>2</td>\n</tr>\n<tr>\n<td>小王</td>\n<td>60</td>\n<td>0</td>\n</tr>\n<tr>\n<td>小张</td>\n<td>74</td>\n<td>1</td>\n</tr>\n<tr>\n<td>清风</td>\n<td>99</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>成绩是越大越好，这样的指标称为极大型指标（效益型指标）<br>\n与他人争吵的次数越少越好，这样的指标称为极小型指标（成本型指标）</p>\n<p>如果我们直接将这些数据加以利用显然是不合适的，因为指标类型不一样<br>\n所以我们应当统一指标类型<br>\n一般我们将所有的指标转化为极大型称为指标正向化（最常用）</p>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th>成绩</th>\n<th>与他人争吵的次数</th>\n<th>正向化后的争吵次数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>小明</td>\n<td>89</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>小王</td>\n<td>60</td>\n<td>0</td>\n<td>3</td>\n</tr>\n<tr>\n<td>小张</td>\n<td>74</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>清风</td>\n<td>99</td>\n<td>3</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>极小型指标转换为极大型指标的公式：max - x</p>\n<h4 id=\"标准化处理\"><a class=\"markdownIt-Anchor\" href=\"#标准化处理\">#</a> 标准化处理</h4>\n<p>显然成绩的大小与争吵次数的大小不是一个量级上的比较<br>\n为了消去不同指标量纲的影响，需要对已经正向化的矩阵进行标准化处理<br>\n图像链接：<br>\n我们得到了标准化处理后的指标，那么我们怎么去联系这些值呢</p>\n<h4 id=\"如何计算得分\"><a class=\"markdownIt-Anchor\" href=\"#如何计算得分\">#</a> 如何计算得分</h4>\n<p>我们对于最开始的式子：(x - min) / ( max - min )<br>\n 我们可以将其变形 = (x - min) / [ ( max - x ) + ( x - min ) ]<br>\n 可以看作是：x 与最小值的距离 /  (x 与最大值的距离 + x 与最小值的距离)<br>\n 类比可以得出：<br>\n图像链接：</p>\n<p>上面的一大串公式可以这样理解，我们对于只有一个指标时，我们将这一列的数据找出它的最大值和最小值，对于多个指标，同理，我们先将每一列的最大值和最小值找出来。<br>\n对于每一个评价对象，我们要找出它与最小值的距离可以看成一个平面直角坐标系，它的值所对应的点距离原点（最小值）的距离长度，也就是他的我们所要找的值<br>\n对于最大值的寻找也同理</p>\n<p>计算出未归一化的得分后我们将其进行归一化处理，就可得到他们的排名了</p>\n<p>这下子再回到 TOPSIS 算法，我们就不难理解它为什么是优劣解距离法了吧</p>\n<h3 id=\"梳理\"><a class=\"markdownIt-Anchor\" href=\"#梳理\">#</a> 梳理</h3>\n<h4 id=\"第一步将原始矩阵正向化\"><a class=\"markdownIt-Anchor\" href=\"#第一步将原始矩阵正向化\">#</a> 第一步将原始矩阵正向化</h4>\n<p>最常见的四种指标</p>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>名称</th>\n<th>指标特点</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>极大型（效益型）</td>\n<td>指标越大越好</td>\n<td>成绩、GDP 增速、企业利润</td>\n</tr>\n<tr>\n<td>极小型（成本型）</td>\n<td>指标越小越好</td>\n<td>费用、坏品率、污染程度</td>\n</tr>\n<tr>\n<td>中间型指标</td>\n<td>越接近某个值越好</td>\n<td>水质量评估 ph 值</td>\n</tr>\n<tr>\n<td>区间型指标</td>\n<td>落在某个区间最好</td>\n<td>体温、水中植物性营养物量</td>\n</tr>\n</tbody>\n</table>\n<p>正向化就是将所有指标类型转化为极大型指标</p>\n<p>我们介绍了极小型转化为极大型，那么另外两种指标该如何转换呢</p>\n<h5 id=\"中间型指标\"><a class=\"markdownIt-Anchor\" href=\"#中间型指标\">#</a> 中间型指标</h5>\n<p>{xi} 是一组中间型指标序列，且最佳的数值为 xbest，那么正向化的公式如下<br>\n M = max {| xi - xbest |} , xi’ = 1 - | xi - xbest | / M<br>\n 我们可以画图去理解这个公式，也是利用距离去计算，思想大致与极小型相同</p>\n<h5 id=\"区间型指标\"><a class=\"markdownIt-Anchor\" href=\"#区间型指标\">#</a> 区间型指标</h5>\n<p>我们设最佳区间为 [a,b]<br>\nM = max { a - min { xi } , max { xi } - b }<br>\nxi = 1 - ( a - x ) / M , x &lt; a<br>\n1                 , a &lt;= x &lt;= b<br>\n1 - ( x - b ) / M , x &gt; b<br>\n 思路与中间型指标也是差不多的，画图也可以理解</p>\n<h4 id=\"第二步正向化矩阵标准化\"><a class=\"markdownIt-Anchor\" href=\"#第二步正向化矩阵标准化\">#</a> 第二步：正向化矩阵标准化</h4>\n<h4 id=\"第三步归一化处理并排名\"><a class=\"markdownIt-Anchor\" href=\"#第三步归一化处理并排名\">#</a> 第三步：归一化处理并排名</h4>\n<h3 id=\"带权重的topsis\"><a class=\"markdownIt-Anchor\" href=\"#带权重的topsis\">#</a> 带权重的 TOPSIS</h3>\n<p>对于之前我们所用到的 TOPSIS 我们默认了指标之间的权重为 1 ，然而实际情况可能更为复杂<br>\n有 n 个要评价的对象，m 个评价指标的标准化矩阵<br>\n可以利用层次分析法给这 m 个评价指标确定权重，每个指标的权重加起来显然是为 1 的。<br>\n我们在计算评价对象与最大值之间的距离是可以直接针对每个 j（即每个指标）乘以响应的权重 wj 再进行开方<br>\n可能有人就要问了，那你这样加起来的距离显然是要小于之前的距离呀，会对得出正确的结论有影响吗<br>\n其实是没有影响的<br>\n我们可以理解为对于我们建立的直角坐标系对于某个轴进行了压缩，压缩后虽然大小改变了，但是并不影响我们得出正确的结论</p>\n<p>关于 TOPSIS 的代码见下一篇博客</p>\n",
            "tags": [
                "数学建模",
                "TOPSIS"
            ]
        }
    ]
}