{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amentiraz • All posts by \"指针\" tag",
    "description": "",
    "home_page_url": "http://Amentiraz.github.io",
    "items": [
        {
            "id": "http://amentiraz.github.io/2021/11/04/%E6%8C%87%E9%92%88/",
            "url": "http://amentiraz.github.io/2021/11/04/%E6%8C%87%E9%92%88/",
            "title": "指针",
            "date_published": "2021-11-04T00:48:35.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-YMkJXQJc\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"447578836\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>指针是一种保存变量地址的变量。在存储时，内存被分为一块一块的。每一块都有一个特有的编号。而这个编号可以暂时理解为指针，就像酒店的门牌号一样。</p>\n<span id=\"more\"></span>\n<h3 id=\"指针与地址\"><a class=\"markdownIt-Anchor\" href=\"#指针与地址\">#</a> 指针与地址</h3>\n<p>一元运算符 &amp; 可用于取一个对象的地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = &amp; c ; </span><br></pre></td></tr></table></figure>\n<p>将把 c 的地址赋值给变量 p，我们称 p 为 “指向” c 的指针。地址运算符 &amp; 只能应用于内存中 的对象，即变量与数组元素。它不能作用于表达式、常量或 register 类型的变量。<br>\n一元运算符 * 是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对象。下列程序介绍了 &amp; 与 * 的使用方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int x = 1 , y = 2 , z[10] ; </span><br><span class=\"line\">ip = &amp; x ; //表明表达式*ip 的结果是 int 类型。</span><br><span class=\"line\">y = * ip ; </span><br><span class=\"line\">* ip = 0 ; </span><br><span class=\"line\">ip = &amp; z[0] ; </span><br></pre></td></tr></table></figure>\n<p>对函数的声明也可以采用这种方式。<br>\n例如，声明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double *dp，atof(char *); </span><br></pre></td></tr></table></figure>\n<p>表明，在表达式中，*dp 和 atof (s) 的值都是 double 类型，且 atof 的参数是一个指向 char 类型的指针。<br>\n指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型。（一个例外情况是指向 void 类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身。)<br>\n 如果指针 ip 指向整型变量，那么在 x 可以出现的任何上下文中都可以使用 * ip，因此， 语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*ip = *ip + 10; </span><br></pre></td></tr></table></figure>\n<p>将把<em> ip 的值增加 10。 一元运算符</em>和 &amp; 的优先级比算术运算符的优先级高，因此，赋值语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = *ip + 1 </span><br></pre></td></tr></table></figure>\n<p>将把 * ip 指向的对象的值取出并加 1，然后再将结果赋值给 y，而下列赋值语句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*ip += 1 </span><br></pre></td></tr></table></figure>\n<p>则将 ip 指向的对象的值加 1，它等同于</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">++*ip </span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*ip)++ </span><br></pre></td></tr></table></figure>\n<p>语句的执行结果。语句 (* ip)<ins> 中的圆括号是必需的，否则，该表达式将对 ip 进行加 1 运算，<br>\n而不是对 ip 指向的对象进行加 1 运算，这是因为，类似于 * 和</ins>这样的一元运算符遵循从右 至左的结合顺序。<br>\n最后说明一点，由于指针也是变量，所以在程序中可以直接使用，而不必通过间接引用<br>\n的方法使用。例如，如果 iq 是另一个指向整型的指针，那么语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iq = ip </span><br></pre></td></tr></table></figure>\n<p>将把 ip 中的值拷贝到 iq 中，这样，指针 iq 也将指向 ip 指向的对象。</p>\n<h3 id=\"指针与指针参数\"><a class=\"markdownIt-Anchor\" href=\"#指针与指针参数\">#</a> 指针与指针参数</h3>\n<p>为了使被调用函数直接修改主调函数中的变量值，我们可以使主调程序将指向所要交换的变量的指针传递给被调用函数，即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swap ( &amp; a , &amp; b ) ; </span><br></pre></td></tr></table></figure>\n<p>由于一元运算符 &amp; 用来取变量的地址，这样 &amp; a 就是一个指向变量 a 的指针。swap 函数的所有参数都声明为指针，并且通过这些指针来间接访问它们所指向的操作数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void swap ( int * px , int * py ) &#123;</span><br><span class=\"line\">    int temp ; </span><br><span class=\"line\">    temp = * px ; </span><br><span class=\"line\">    * px = * py ; </span><br><span class=\"line\">    * py = temp ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>指针参数使得被调用函数能够访问和修改主调函数中对象的值。<br>\n我们来看一个可以接受自由格式输入，并执行转换，并同时返回得到的整数和文件结束标志（EOF）的函数。<br>\n如果你觉得你已经了解了可以不用看下面的代码，直接进入下一节。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int getch ( void ) &#123; return ( bufp &gt; 0 ) ? buf[--bufp] : getchar ( ) ; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void ungetch ( int c ) &#123; </span><br><span class=\"line\">    if ( bufp &gt;= BUFSIZE ) printf ( &quot;ungetch:too many characters\\n&quot; ) ; </span><br><span class=\"line\">    else buf[bufp++] = c ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int getint ( int * pn ) &#123;</span><br><span class=\"line\">    int c , sign ; </span><br><span class=\"line\">    while ( isspace ( c = getch ( ) ) ) ;</span><br><span class=\"line\">    if ( ! isdigit ( c ) &amp;&amp; c != EOF &amp;&amp; c != &#x27;+&#x27; &amp;&amp; c != &#x27;-&#x27; ) &#123;</span><br><span class=\"line\">        ungetch ( c ) ; return 0 ;     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sign = ( c == &#x27;-&#x27; ) ? -1 : 1 ; </span><br><span class=\"line\">    if ( c == &#x27;+&#x27; || c == &#x27;-&#x27; ) c = getch ( ) ; </span><br><span class=\"line\">    for ( * pn = 0 ; isdigit ( c ) ; c = getch ( ) ) </span><br><span class=\"line\">        * pn = 10 * * pn + c - &#x27;0&#x27; ; </span><br><span class=\"line\">    * pn *= sign ; </span><br><span class=\"line\">    if ( c != EOF ) ungetch ( c ) ; </span><br><span class=\"line\">    return c ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 getint 函数中，*pn 始终作为一个普通的整形变量使用。</p>\n<h3 id=\"指针与数组\"><a class=\"markdownIt-Anchor\" href=\"#指针与数组\">#</a> 指针与数组</h3>\n<p>一般来说，用指针编写的程序比用数组下标编写的程序执行速度快，但另一方面，用指针实现的程序理解 起来稍微困难一些。<br>\n声明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a[10]; </span><br></pre></td></tr></table></figure>\n<p>定义了一个长度为 10 的数组 a。换句话说，它定义了一个由 10 个对象组成的集合，这 10 个<br>\n对象存储在相邻的内存区域中，名字分别为 a [0]、a [1]、…、a [9]<br>\n 如果 pa 指向数组中的某个特定元素，那么，根据指针运算的定义，pa+1 将指向下一个元素，pa+i 将指向 pa 所指向数组元素之后的第 i 个元素，而 pa-i 将指向 pa 所指向数组元素之前的第 i 个元素。因此，如果指针 pa 指向 a [0]，那么 * (pa+1) 引用的是数组元素 a [1] 的内容，pa+i 是数组元素 a [i] 的地址，* (pa+i) 引用的是数组元素 a [i] 的内容<br>\n无论数组 a 中元素的类型或数组长度是什么，上面的结论都成立。“指针加 1” 就意味着，pa+1 指向 pa 所指向的对象的<strong>下一个对象</strong>。相应地，pa+i 指向 pa 所指向的对象之后的第 i 个对象。<br>\n对数组元素 a [i] 的引用也可以写成 *(a+i) 这种形式。对第一次接触这种写法的人来说， 可能会觉得很奇怪。在计算数组元素 a [i] 的值时，C 语言实际上先将其转换为 *(a+i) 的形<br>\n式，然后再进行求值，因此在程序中这两种形式是等价的。如果对这两种等价的表示形式分 别施加地址运算符 &amp;，便可以得出这样的结论：&amp;a [i] 和 a+i 的含义也是相同的。a+i 是 a<br>\n 之后第 i 个元素的地址。相应地，如果 pa 是个指针，那么，在表达式中也可以在它的后面加 下标。pa [i] 与 *(pa+i) 是等价的。简而言之，一个通过数组和下标实现的表达式可等价地 通过指针和偏移量实现。<br>\n但是，我们必须记住，数组名和指针之间有一个不同之处，指针是一个变量，因此，在 C 语言中，语句 pa=a 和 pa<ins> 都是合法的。但数组名不是变量，因此，类似于 a=pa 和 a</ins> 形式的语句是非法的。<br>\n当把数组名传递给一个函数时，实际上传递的是该数组第一个元索的地址。在被调用函数中，该参数是一个局部变量，因此，数组名参数必须是一个指针，也就是一个存储地址值 的变量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*return length of s */</span><br><span class=\"line\">int strlen ( char * s ) &#123;</span><br><span class=\"line\">    int n ; </span><br><span class=\"line\">    for ( n = 0 ; * s != &#x27;\\0&#x27; ; s ++ ) n ++ ; </span><br><span class=\"line\">    return n ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行 s++ 运算不会影响到 strlen 函数的调用者中的字符串，它仅对该指针在 strlen 函数中的私有副本进行自增运算。<br>\n以下的函数调用均正确：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strlen ( &quot;hello world&quot; ) ;</span><br><span class=\"line\">char array[100] ; </span><br><span class=\"line\">strlen ( array ) ; </span><br><span class=\"line\">char * ptr ; </span><br><span class=\"line\">strlen ( ptr ) ; </span><br></pre></td></tr></table></figure>\n<p>在函数定义中，形式参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char s[]; </span><br></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *s; </span><br></pre></td></tr></table></figure>\n<p>是等价的。我们通常更习惯于使用后一种形式，因为它比前者更直观地表明了该参数是一个指针。如果将数组名传递给函数，函数可以根据情况判定是按照数组处理还是按照指针处理，随后根据相应的方式操作该参数。为了直观且恰当地描述函数，在函数中甚至可以同时使用数组和指针这两种表示方法。<br>\n也可以将指向子数组起始位置的指针传递给函数，这样，就将数组的一部分传递给了函<br>\n数。例如，如果 a 是一个数组，那么下面两个函数调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(&amp;a[2]) </span><br></pre></td></tr></table></figure>\n<p>与</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(a+2) </span><br></pre></td></tr></table></figure>\n<p>都将把起始于 a [2] 的子数组的地址传递给函数 f。在函数 f 中，参数的声明形式可以为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(int arr[]) &#123; ... &#125; </span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(int *arr) &#123; ... &#125; </span><br></pre></td></tr></table></figure>\n<p>对于函数 f 来说，它并不关心所引用的是否只是一个更大数组的部分元素。 如果确信相应的元素存在，也可以通过下标访问数组第一个元素之前的元素。类似于<br>\n p [-1]、p [-2] 这样的表达式在语法上都是合法的，它们分别引用位于 p [0] 之前的两个元素。<br>\n当然，引用数组边界之外的对象是非法的。</p>\n<h3 id=\"地址算术运算\"><a class=\"markdownIt-Anchor\" href=\"#地址算术运算\">#</a> 地址算术运算</h3>\n<p>下面我们将给出函数 alloc 和 afree，他们分别对标 malloc.h 头文件中的 malloc 函数和 free 函数，只是功能相对于 malloc 和 free 更菜而已。这里就先直接贴代码，看不懂也没关系，继续往下看就行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char * alloc ( int n ) &#123;</span><br><span class=\"line\">    if ( ( allocbuf + ALLOCSIZE - allocp &gt;= n ) ) &#123;</span><br><span class=\"line\">        allocp += n ;</span><br><span class=\"line\">        return allocp - n ; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else return 0 ; </span><br><span class=\"line\">    //C语言保证，0永远不是有效的数据地址，因此返回值0可用来表示发生了异常事件</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void afree ( char * p ) &#123;</span><br><span class=\"line\">    if ( p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE ) allocp = p ;</span><br><span class=\"line\">    //对指针进行比较</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，在某些情况下对指针可以进 行比较运算。例如，如果指针 p 和 q 指向同一个数组的成员，那么它们之间就可以进行类似 于 ==、!=、&lt;、&gt;= 的关系比较运算。如果 p 指向的数组元素的位置在 q 指向的数组元素位置 之前，那么关系表达式<br>\n p &lt; q<br>\n 的值为真。任何指针与 0 进行相等或不等的比较运算都有意义。但是，指向不同数组的元素的指针之间的算术或比较运算没有定义。（这里有一个特例：指针的算术运算中可使用数组最 后一个元素的下一个元素的地址。）<br>\n其次。我们从前面可以看到，指针可以和整数进行相加或相减运算。例如，结构<br>\n p + n<br>\n 表示指针 p 当前指向的对象之后第 n 个对象的地址。无论指针 p 指向的对象是何种类型，上述结论都成立。在计算 p+n 时，n 将根据 p 指向的对象的长度按比例缩放，而 p 指向的对象的长度则取决于 p 的声明。例如，如果 int 类型占 4 个字节的存储空间，那么在 int 类型的计算中，对应的 n 将按 4 的倍数来计算。指针的减法运算也是有意义的：如果 p 和 q 指向相同数组中的元索，且 p&lt;q，那么 q-p+1 就是位于 p 和 q 指向的元索之间的元素的数目。我们由此可以编写出函数 strlen 的另一个<br>\n版本，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int strlen ( char * s ) &#123;</span><br><span class=\"line\">    char * p = s ; </span><br><span class=\"line\">    while ( * p != &#x27;\\0&#x27; ) p ++ ; </span><br><span class=\"line\">    return p - s ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符指针与函数\"><a class=\"markdownIt-Anchor\" href=\"#字符指针与函数\">#</a> 字符指针与函数</h3>\n<p>字符串常量是一个字符数组，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;I am a string&quot; </span><br></pre></td></tr></table></figure>\n<p>在字符串的内部表示中，字符数组以空字符’\\0’结尾，所以，程序可以通过检查空字符找到 字符数组的结尾。字符串常量占据的存储单元数也因此比双引号内的字符数大 1。<br>\n字符串常量最常见的用法也许是作为函数参数，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">princf(&quot;hello, world\\n&quot;&#125;; </span><br></pre></td></tr></table></figure>\n<p>当类似于这样的一个字符串出现在程序中时，实际上是通过字符指针访问该字符串的。在上<br>\n述语句中，printf 接受的是一个指向字符数组第一个字符的指针。也就是说，字符串常量可 通过一个指向其第一个元素的指针访问。<br>\n除了作为函数参数以外，字符串常量还有其它的用法。例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *pmessage ; </span><br><span class=\"line\">pmessage = &quot;now is the time&quot; ; </span><br></pre></td></tr></table></figure>\n<p>此操作把一个指向该字符数组的指针赋值给 pmessage。该过程并没有进行字符串的复制，而只 是涉及到指针的操作。C 语言没有提供将整个字符串作为一个整体进行处理的运算符。<br>\n下面两个定义之间有很大的差别：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char amessage[] = &quot;nw is the time&quot;; /* 定义一个数组 */ </span><br><span class=\"line\">char *pmessage = &quot;now is the time&quot;; /* 定义一个指针 */ </span><br></pre></td></tr></table></figure>\n<p>上述声明中，amessage 是一个仅仅足以存放初始化字符串以及空字符’\\0’的一维数组。数组中的单个字符可以进行修改，但 amessage 始终指向同一个存储位置。另一方面，pmessage 是一个指针，其初值指向一个字符串常量，之后它可以被修改以指向其它地址，但如果试图 修改字符串的内容，结果是没有定义的<br>\n掌握了上面的知识，我们现在可以理解下面的程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void strcpy ( char * s , char * t ) while ( * s ++ = * t ++ ) ; </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int strcmp ( char * s , char * t ) &#123;</span><br><span class=\"line\">    for ( ; * s == * t ; s ++ , t ++ ) if ( * s == &#x27;\\0&#x27; ) return 0 ; </span><br><span class=\"line\">    return * s - * t ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组指针与指向指针的指针\"><a class=\"markdownIt-Anchor\" href=\"#数组指针与指向指针的指针\">#</a> 数组指针与指向指针的指针</h3>\n<p>下面是一个运用快速排序来实现字符串排序的程序，qsort 部分可自行使用快排实现，我自己想了想也可以用普通的 sort + 结构体实现，或许会更好点，这里就不展开了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt; </span><br><span class=\"line\">#include &lt;string.h&gt; </span><br><span class=\"line\">#define MAXLINES 5000 /* max #lines to be sorted */ </span><br><span class=\"line\">char *lineptr[MAXLINES]; /* pointers to text lines */ </span><br><span class=\"line\">int readlines(char *lineptr[], int nlines); </span><br><span class=\"line\">void writelines(char *lineptr[], int nlines); </span><br><span class=\"line\">void qsort(char *lineptr[], int left, int right); </span><br><span class=\"line\">/* sort input lines */ </span><br><span class=\"line\">main() </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    int nlines; /* number of input lines read */ </span><br><span class=\"line\">    if ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) &#123; </span><br><span class=\"line\">        qsort(lineptr, 0, nlines-1); </span><br><span class=\"line\">        writelines(lineptr, nlines); </span><br><span class=\"line\">        return 0; </span><br><span class=\"line\">    &#125; else &#123; </span><br><span class=\"line\">        printf(&quot;error: input too big to sort\\n&quot;); </span><br><span class=\"line\">        return 1; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">    #define MAXLEN 1000 /* max length of any input line */ </span><br><span class=\"line\">    int getline(char *, int); </span><br><span class=\"line\">    char *alloc(int); </span><br><span class=\"line\">/* readlines: read input lines */ </span><br><span class=\"line\">int readlines(char *lineptr[], int maxlines) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    int len, nlines; </span><br><span class=\"line\">    char *p, line[MAXLEN]; </span><br><span class=\"line\">    nlines = 0; </span><br><span class=\"line\">    while ((len = getline(line, MAXLEN)) &gt; 0) </span><br><span class=\"line\">        if (nlines &gt;= maxlines || p = alloc(len) == NULL) </span><br><span class=\"line\">            return -1; </span><br><span class=\"line\">        else &#123; </span><br><span class=\"line\">            line[len-1] = &#x27;\\0&#x27;; /* delete newline */ </span><br><span class=\"line\">            strcpy(p, line); </span><br><span class=\"line\">            lineptr[nlines++] = p; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    return nlines; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">/* writelines: write output lines */ </span><br><span class=\"line\">void writelines(char *lineptr[], int nlines) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    int i; </span><br><span class=\"line\">    for (i = 0; i &lt; nlines; i++) </span><br><span class=\"line\">        printf(&quot;%s\\n&quot;, lineptr[i]); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void qsort(char *v[], int left, int right) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    int i, last; </span><br><span class=\"line\">    void swap(char *v[], int i, int j); </span><br><span class=\"line\">    if (left &gt;= right) /* do nothing if array contains */ </span><br><span class=\"line\">        return; /* fewer than two elements */ </span><br><span class=\"line\">    swap(v, left, (left + right)/2); </span><br><span class=\"line\">    last = left; </span><br><span class=\"line\">    for (i = left+1; i &lt;= right; i++) </span><br><span class=\"line\">        if (strcmp(v[i], v[left]) &lt; 0) </span><br><span class=\"line\">            swap(v, ++last, i); </span><br><span class=\"line\">        swap(v, left, last); </span><br><span class=\"line\">        qsort(v, left, last-1); </span><br><span class=\"line\">        qsort(v, last+1, right); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* swap: interchange v[i] and v[j] */ </span><br><span class=\"line\">void swap(char *v[], int i, int j) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    char *temp; </span><br><span class=\"line\">    temp = v[i]; </span><br><span class=\"line\">    v[i] = v[j]; </span><br><span class=\"line\">    v[j] = temp; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在该例子中，指针数组 lineptr 的声明是新出现的重要概念：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *lineptr[MAXLINES]; </span><br></pre></td></tr></table></figure>\n<p>它表示 lineptr 是一个具有 MAXLINES 个元素的一维数组，其中数组的每个元素是一个指向字符类型对象的指针。也就是说，lineptr [i] 是一个字符指针，而 * lineptr [i] 是该指针指向的第 i 个文本行的首字符。 由于 lineptr 本身是一个数组名，因此，可按照前面例子中相同的方法将其作为指针使用，这样，writelines 函数可以改写为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* writelines: write output lines */ </span><br><span class=\"line\">void writelines(char *lineptr[], int nlines) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    while (nlines-- &gt; 0) </span><br><span class=\"line\">        printf(&quot;%s\\n&quot;, *lineptr++); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（注意这里的数组变量 lineptr 可以改变值）<br>\n循环开始执行时，*lineptr 指向第一行，每执行一次自增运算都使得 lineptr 指向下 一行，同时对 nlines 进行自减运算。</p>\n<h3 id=\"多维数组\"><a class=\"markdownIt-Anchor\" href=\"#多维数组\">#</a> 多维数组</h3>\n<p>如果将二维数组作为参数传递给函数，那么在函数的参数声明中必须指明数组的列数。<br>\n数组的行数没有太大关系，因为前面已经讲过，函数调用时传递的是一个指针，它指向由行 向量构成的一维数组，其中每个行向量是具有 13 个整型元素的一维数组。在该例子中，传递 给函数的是一个指向很多对象的指针，其中每个对象是由 13 个整型元素构成的一维数组。因 此，如果将数组 daytab 作为参数传递给函数 f，那么 f 的声明应该写成下列形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(int daytab[2][13]) &#123; ... &#125; </span><br></pre></td></tr></table></figure>\n<p>也可以写成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(int daytab[][13]) &#123; ... &#125; </span><br></pre></td></tr></table></figure>\n<p>因为数组的行数无关紧要，所以，该声明还可以写成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(int (*daytab)[13]) &#123; ... &#125; </span><br></pre></td></tr></table></figure>\n<p>这种声明形式表明参数是一个指针，它指向具有 13 个整型元素的一维数组。因为方括号 [] 的<br>\n优先级高于 * 的优先级，所以上述声明中必须使用圆括号。如果去掉括号，则声明变成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int *daytab[13] </span><br></pre></td></tr></table></figure>\n<p>这相当于声明了一个数组，该数组有 13 个元素，其中每个元素都是一个指向整型对象的指针。<br>\n一般来说，除数组的第一维（下标）可以不指定大小外，其余各维都必须明确指定大小。</p>\n<h3 id=\"指针数组的初始化\"><a class=\"markdownIt-Anchor\" href=\"#指针数组的初始化\">#</a> 指针数组的初始化</h3>\n<p>考虑这样一个问题：编写一个函数 month_name (n)，它返回一个指向第 n 个月名字的 字符串的指针。这是内部 static 类型数组的一种理想的应用。month_name 函数中包含一 个私有的字符串数组，当它被调用时，返回一个指向正确元素的指针。本节将说明如何初始<br>\n化该名字数组。<br>\n指针数组的初始化语法和前面所讲的其它类型对象的初始化语法类似：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* month_name: return name of n-th month */ </span><br><span class=\"line\">char *month_name(int n) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    static char *name[] = &#123; </span><br><span class=\"line\">        &quot;Illegal month&quot;, </span><br><span class=\"line\">        &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, </span><br><span class=\"line\">        &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, </span><br><span class=\"line\">        &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, </span><br><span class=\"line\">        &quot;October&quot;, &quot;November&quot;, &quot;December&quot; </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return name ; </span><br></pre></td></tr></table></figure>\n<p>其中，name 的声明与排序例子中 lineptr 的声明相同，是一个一维数组，数组的元素为字 符指针。name 数组的初始化通过一个字符串列表实现，列表中的每个字符串赋值给数组相应 位置的元素。第 i 个字符串的所有字符存储在存储器中的某个位置，指向它的指针存储在 name [i] 中。由于上述声明中没有指明 name 的长度，因此，编译器编译时将对初值个数进 行统计，并将这一准确数字填入数组的长度。</p>\n<h3 id=\"指针与多维数组\"><a class=\"markdownIt-Anchor\" href=\"#指针与多维数组\">#</a> 指针与多维数组</h3>\n<p>对于 C 语言的初学者来说，很容易混淆二维数组与指针数组之间的区别，比如上面例子 中的 name。假如有下面两个定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a[10][20]; </span><br><span class=\"line\">int \\*b[10]; </span><br></pre></td></tr></table></figure>\n<p>那么，从语法角度讲，a [3][4] 和 b [3][4] 都是对一个 int 对象的合法引用。但 a 是一个真正的二维数组，它分配了 200 个 int 类型长度的存储空间，并且通过常规的矩阵下标计算公式 20×row+col（其中，row 表示行，col 表示列）计算得到元素 a [row][col] 的位置。但是，对 b 来说，该定义仅仅分配了 10 个指针，并且没有对它们初始化，它们的初始化必须以显式的方式进行，比如静态初始化或通过代码初始化。假定 b 的每个元素 (其实只取决于最大的）都指向一个具有 20 个元 素的数组，那么编译器就要为它分配 200 个 int 类型长度的存储空间以及 10 个指针的存储空间。指针数组的一个重要优点在于，数组的每一行长度可以不同，也就是说，b 的每个元素不 必都指向一个具有 20 个元素的向量，某些元素可以指向具有 2 个元素的向量，某些元素可以指向具有 50 个元素的向量，而某些元素可以不指向任何向量。</p>\n<h3 id=\"命令行参数\"><a class=\"markdownIt-Anchor\" href=\"#命令行参数\">#</a> 命令行参数</h3>\n<p>编程实际场景中感觉是不常用的，我自己也没看懂，日后补<br>\n略</p>\n<h3 id=\"指向函数的指针\"><a class=\"markdownIt-Anchor\" href=\"#指向函数的指针\">#</a> 指向函数的指针</h3>\n<p>在系统学习完指向含糊的指针后，我发现这玩意就是个纸老虎，只是听起来挺高大上的，其实非常简单。<br>\n在实际运用中就差不多减少一点代码行数而已，感觉替代性挺强的。（也可能是因为我太菜了）<br>\n那就开始吧<br>\n在 C 语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。我们接下来将修改排序函数，在给定可选参数 - n 的情况下，该函数将按树枝大小而非字典顺序对输入行进行排序。<br>\n排序程序通常包括 3 部分：判断任何两个对象之间次序的比较操作、颠倒对象次序的交 换操作、一个用于比较和交换对象直到所有对象都按正确次序排列的排序算法。<br>\n由于排序算法与比较、交换操作无关，因此，通过在排序算法中调用不同的比较和交换函数，便可以实 现按照不同的标准排序。这就是我们的新版本排序函数所采用的方法。<br>\n函数 strcmp 按字典顺序比较两个输入行。在这里，我们还需要一个以数值为基础来比较两个输入行，并返回与 strcmp 同样的比较结果的函数 numcmp。这些函 数在 main 之前声明，并且，指向恰当函数的指针将被传递给 qsort 函数。在这里，参数的出错处理并不是问题的重点，我们将主要考虑指向函数的指针问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#define MAXLINES 5000 /* max #lines to be sorted */</span><br><span class=\"line\">char *lineptr[MAXLINES]; /* pointers to text lines */</span><br><span class=\"line\">int readlines(char *lineptr[], int nlines);</span><br><span class=\"line\">void writelines(char *lineptr[], int nlines);</span><br><span class=\"line\">void qsort(void *lineptr[], int left, int right,</span><br><span class=\"line\">int (*comp)(void *, void *));</span><br><span class=\"line\">int numcmp(char *, char *);</span><br><span class=\"line\">/* sort input lines */</span><br><span class=\"line\">int main(int argc, char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int nlines; /* number of input lines read */</span><br><span class=\"line\">    int numeric = 0; /* 1 if numeric sort */</span><br><span class=\"line\">    if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &quot;-n&quot;) == 0)</span><br><span class=\"line\">        numeric = 1;</span><br><span class=\"line\">    if ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) &#123;</span><br><span class=\"line\">        qsort((void**) lineptr, 0, nlines-1,</span><br><span class=\"line\">            (int (*)(void*,void*))(numeric ? numcmp : strcmp));</span><br><span class=\"line\">        writelines(lineptr, nlines);</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        printf(&quot;input too big to sort\\n&quot;);</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* qsort: sort v[left]...v[right] into increasing order */</span><br><span class=\"line\">void qsort(void *v[], int left, int right,</span><br><span class=\"line\">int (*comp)(void *, void *))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i, last;</span><br><span class=\"line\">    void swap(void *v[], int, int);</span><br><span class=\"line\">    if (left &gt;= right) /* do nothing if array contains */</span><br><span class=\"line\">        return; /* fewer than two elements */</span><br><span class=\"line\">    swap(v, left, (left + right)/2);</span><br><span class=\"line\">    last = left;</span><br><span class=\"line\">    for (i = left+1; i &lt;= right; i++)</span><br><span class=\"line\">        if ((*comp)(v[i], v[left]) &lt; 0)</span><br><span class=\"line\">            swap(v, ++last, i);</span><br><span class=\"line\">    swap(v, left, last);</span><br><span class=\"line\">    qsort(v, left, last-1, comp);</span><br><span class=\"line\">    qsort(v, last+1, right, comp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在调用函数 qsort 的语句中，strcmp 和 numcmp 是函数的地址，因为它们是函数，所以前面不需要加上取地址运算符 &amp;，同样的原因，数组名前面也不需要 &amp; 运算符。<br>\n改写后的 qsort 函数能够处理任何数据类型，而不仅仅限于字符串。从函数 qsort 的 原型可以看出，它的参数表包括一个指针数组、两个整数和一个有两个指针参数的函数。其中，指针数组参数的类型为通用指针类型 void <em>。由于任何类型的指针都可以转换为 void</em> 类型，并且在将它转换回原来的类型时不会丢失信息，所以，调用 qsort 函数时可以将参数强制转换为 void * 类型。比较函数的参数也要执行这种类型的转换。这种转换通常不会影响到数据的实际表示，但要确保编译器不会报错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ( * comp ) ( void * , void * ) </span><br></pre></td></tr></table></figure>\n<p>它表明 comp 是一个指向函数的指针，该函数具有两个 void * 类型的参数，其返回值为 int。<br>\n值得注意的是圆括号是必须的，这样才能保证其中的各个部分正确结合，如果没有括号，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int * comp ( void * , void * ) </span><br></pre></td></tr></table></figure>\n<p>则表明 comp 是一个函数，该函数返回一个指向 int 类型的指针<br>\n我们在前面讲过函数 strcmp，占用于比较两个字符串。这里介绍的函数 numcmp 也是比 较两个字符串，但它通过调用 atof 计算字符串对应的数值，然后在此基础上进行比较：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">/* numcmp: compare s1 and s2 numerically */</span><br><span class=\"line\">int numcmp(char *s1, char *s2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    double v1, v2;</span><br><span class=\"line\">    v1 = atof(s1);</span><br><span class=\"line\">    v2 = atof(s2);</span><br><span class=\"line\">    if (v1 &lt; v2)</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    else if (v1 &gt; v2)</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>交换两个指引的 swap 函数和本章前面所述的 swap 函数相同，但它的参数声明为 void *<br>\n 类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void swap(void * v[], int i, int j;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void *temp;</span><br><span class=\"line\">    temp = v[i];</span><br><span class=\"line\">    v[i] = v[j];</span><br><span class=\"line\">    v[j] = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"链表\"><a class=\"markdownIt-Anchor\" href=\"#链表\">#</a> 链表</h3>\n<p>关于 malloc：</p>\n<h4 id=\"函数原型\"><a class=\"markdownIt-Anchor\" href=\"#函数原型\">#</a> 函数原型：</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern void \\*malloc(unsigned int num\\_bytes);</span><br></pre></td></tr></table></figure>\n<h4 id=\"malloc函数返回值\"><a class=\"markdownIt-Anchor\" href=\"#malloc函数返回值\">#</a> malloc 函数返回值</h4>\n<p>如果分配成功则返回指向被分配内存的指针，否则返回空指针 NULL。</p>\n<h4 id=\"malloc函数使用注意事项\"><a class=\"markdownIt-Anchor\" href=\"#malloc函数使用注意事项\">#</a> malloc 函数使用注意事项</h4>\n<p>malloc 函数的返回的是无类型指针，在使用时一定要强制转换为所需要的类型。<br>\n在使用 malloc 开辟空间时，使用完成一定要释放空间，如果不释放会造内存泄漏。<br>\n在使用 malloc 函数开辟的空间中，不要进行指针的移动，因为一旦移动之后可能出现申请的空间和释放空间大小的不匹配</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;malloc.h&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std ; </span><br><span class=\"line\"></span><br><span class=\"line\">struct node &#123;</span><br><span class=\"line\">    int value ; </span><br><span class=\"line\">    struct node * next ; </span><br><span class=\"line\">&#125; ; </span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct node Node ; </span><br><span class=\"line\">//创造节点</span><br><span class=\"line\">Node * create_node ( Node * head , int value ) &#123;</span><br><span class=\"line\">    Node * t_node = ( Node * ) malloc ( sizeof ( Node ) ) ; //千万不可自己去计算数据填入!!!</span><br><span class=\"line\">    if ( ! t_node ) &#123; printf ( &quot;failed&quot; ) ; exit ( -1 ) ; &#125;</span><br><span class=\"line\">    t_node -&gt; value = value ; // ( * t_node ).value ; </span><br><span class=\"line\">    t_node -&gt; next = head ; //</span><br><span class=\"line\">    return t_node ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//搜索目标节点</span><br><span class=\"line\">Node * search_node ( int val , Node * head ) &#123;</span><br><span class=\"line\">    for ( Node * p = head ; p ; p = p -&gt; next ) &#123;</span><br><span class=\"line\">        if ( p -&gt; value == val ) return p ; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0 ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//删除节点，直接越过目标节点进行连接</span><br><span class=\"line\">Node * delete_node ( Node * head , int n ) &#123;</span><br><span class=\"line\">    Node * pre , * cur ;</span><br><span class=\"line\">    for ( pre = 0 , cur = head ; cur &amp;&amp; cur -&gt; value != n ; pre = cur , cur = cur -&gt; next ) ; </span><br><span class=\"line\">    if ( ! cur ) return head ; </span><br><span class=\"line\">    if ( ! pre ) head = head -&gt; next ; </span><br><span class=\"line\">    else pre -&gt; next = cur -&gt; next ; </span><br><span class=\"line\">    free ( cur ) ; cur = NULL ; //指向NULL养成好习惯</span><br><span class=\"line\">    return head ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main ( ) &#123;</span><br><span class=\"line\">    Node * head = 0 ;  </span><br><span class=\"line\">    while ( 1 ) &#123;</span><br><span class=\"line\">        int val ; scanf ( &quot;%d&quot; , &amp; val ) ; </span><br><span class=\"line\">        if ( val == -1 ) break ; </span><br><span class=\"line\">        head = create_node ( head , val ) ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int find_val ; scanf ( &quot;%d&quot; , &amp; find_val ) ; </span><br><span class=\"line\">    Node * goal = search_node ( find_val , head ) ; </span><br><span class=\"line\">    return 0 ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "指针",
                "c语言"
            ]
        }
    ]
}