{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amentiraz • All posts by \"matlab\" tag",
    "description": "",
    "home_page_url": "http://Amentiraz.github.io",
    "items": [
        {
            "id": "http://amentiraz.github.io/2021/09/22/TOPSIS-MATLAB/",
            "url": "http://amentiraz.github.io/2021/09/22/TOPSIS-MATLAB/",
            "title": "TOPSIS-MATLAB",
            "date_published": "2021-09-22T10:35:13.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-fBtQUjgF\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"1401456829\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>代码如下</p>\n<span id=\"more\"></span>\n<h3 id=\"主函数代码\"><a class=\"markdownIt-Anchor\" href=\"#主函数代码\">#</a> 主函数代码</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;clc</span><br><span class=\"line\">load data_water_quality.mat</span><br><span class=\"line\">//正向化</span><br><span class=\"line\">[n,m] = size ( X ) ;</span><br><span class=\"line\">disp ( [&#x27;共有&#x27;num2str ( n ) &#x27;个评价对象,&#x27;num2str ( m ) &#x27;个评价指标] ) </span><br><span class=\"line\">Judge = input ([&#x27;这&#x27;num2str(m)&#x27;个指标是否需要经过正向化处理，需要输入1，不需要输入0:&#x27;]);</span><br><span class=\"line\">if Judge == 1 </span><br><span class=\"line\">    Position = input (&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]:&#x27;) ; </span><br><span class=\"line\">    disp ( &#x27;请输入需要处理的这些列的指标类型（1:极小型，2:中间型，3:区间型）&#x27;) </span><br><span class=\"line\">    Type = input (&#x27;例如2极小，3区间，6中间就输入[1,3,2]:&#x27; ) ;</span><br><span class=\"line\">    for i = 1 : size ( Position , 2 ) </span><br><span class=\"line\">    X ( : , Position ( i ) ) = Positivization ( X ( : , Position ( i )  ) , Type ( i ) , Position ( i ) ) ;</span><br><span class=\"line\">    //Positization是我们定义的函数</span><br><span class=\"line\">    end</span><br><span class=\"line\">    disp (&#x27;正向化后的举证X=&#x27; ) </span><br><span class=\"line\">    disp ( X ) </span><br><span class=\"line\">end</span><br><span class=\"line\">//对正向化对举证进行标准化</span><br><span class=\"line\">Z = X ./ repmat ( sum ( X .* X ) .^ 0.5 , n , 1 ) ;</span><br><span class=\"line\">disp ( &#x27;标准化矩阵Z=&#x27; ） </span><br><span class=\"line\">disp (Z) </span><br><span class=\"line\">//计算最大值与最小值的距离，并算出得分</span><br><span class=\"line\">D_P = sum ( [Z - repmat ( max ( Z ) , n , 1 ) .^ 2 ] , 2 ) .^ 0.5 ; </span><br><span class=\"line\">D_N = sum ( [Z - repmat ( min ( Z ) , n , 1 ) .^ 2 ] , 2 ) .^ 0.5 ;   </span><br><span class=\"line\">S = D_N ./ ( D_P + D_N ) ; </span><br><span class=\"line\">disp ( &#x27;最后的得分为：&#x27; ) </span><br><span class=\"line\">stand_S = S / sum ( S ) </span><br><span class=\"line\">[sorted_S , index] = sort ( stand_S , &#x27;descend&#x27; ) </span><br></pre></td></tr></table></figure>\n<h3 id=\"positivization函数\"><a class=\"markdownIt-Anchor\" href=\"#positivization函数\">#</a> Positivization 函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ posit_x ] = Positivization ( x , type , i ) </span><br><span class=\"line\">    if type == 1 </span><br><span class=\"line\">    disp([&#x27;第&#x27;num2str ( i ) &#x27;列是极小型，正在正向化&#x27;]) </span><br><span class=\"line\">    posit_x = Min2Max ( x ) ; </span><br><span class=\"line\">    disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成])</span><br><span class=\"line\">    disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;)</span><br><span class=\"line\">    else if type == 2 </span><br><span class=\"line\">    dis ( [&#x27;第&#x27;num2str ( i ) &#x27;列是中间型&#x27;])</span><br><span class=\"line\">    best = input (&#x27;请输入最佳的那一个值:&#x27;) ; </span><br><span class=\"line\">    posit_x = Mid2Max ( x , best ) ; </span><br><span class=\"line\">    disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成]) ;</span><br><span class=\"line\">    disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;)</span><br><span class=\"line\">    else if type == 3                                          </span><br><span class=\"line\">    dis ( [&#x27;第&#x27;num2str ( i ) &#x27;列是区间型&#x27;])                    </span><br><span class=\"line\">    a = input (&#x27;请输入区间的下界&#x27;) ;                   </span><br><span class=\"line\">    b = input (&#x27;请输入区间的上界&#x27;) ;         </span><br><span class=\"line\">    posit_x = Inter2Max ( x , a , b ) ;                           </span><br><span class=\"line\">    disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成]) ;              </span><br><span class=\"line\">    disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;)</span><br><span class=\"line\">    else </span><br><span class=\"line\">    disp (&#x27;没有这种类型的指标请检查Type向量中是否有除了1、2、3以外的其他值&#x27;) </span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"min2maxx函数\"><a class=\"markdownIt-Anchor\" href=\"#min2maxx函数\">#</a> Min2Max (x) 函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ posit_x ] = Min2Max ( x ) </span><br><span class=\"line\">    posit_x = max ( x ) - x ; </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"mid2maxxbest函数\"><a class=\"markdownIt-Anchor\" href=\"#mid2maxxbest函数\">#</a> Mid2Max (x,best) 函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ posit_x ] = Mid2Max ( x , best )  </span><br><span class=\"line\">    M = max ( abs ( x - best ) ) ; </span><br><span class=\"line\">    posit_x = 1 - abs ( x - best ) / M ; </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"inter2maxxab函数\"><a class=\"markdownIt-Anchor\" href=\"#inter2maxxab函数\">#</a> Inter2Max (x,a,b) 函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ posit_x ] = Inter2Max ( x , a , b ) ; </span><br><span class=\"line\">    M = max ([ a - min ( x ) , max ( x ) - b ] ) ; </span><br><span class=\"line\">    r_x = size ( x , 1 ) ; </span><br><span class=\"line\">    posit_x = zeros ( r_x , 1 ) ; </span><br><span class=\"line\">    for i = 1 : r_x</span><br><span class=\"line\">        if x(i) &lt; a </span><br><span class=\"line\">            posit_x(i) = 1 - ( a - x(i) ) / M ;</span><br><span class=\"line\">        else if x(i) &gt; b </span><br><span class=\"line\">            posit_x(i) = 1 - ( x(i) - b ) / M ; </span><br><span class=\"line\">        else posit_x(i) = 1 ; </span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"原始矩阵正向化\"><a class=\"markdownIt-Anchor\" href=\"#原始矩阵正向化\">#</a> 原始矩阵正向化</h3>\n<p>将 Excel 内的数据直接粘贴进 matlab 里，赋值给变量<br>\n将此变量另存为至与代码相同的目录下<br>\n调用直接用 load xxx.mat</p>\n<h3 id=\"sort函数\"><a class=\"markdownIt-Anchor\" href=\"#sort函数\">#</a> sort 函数</h3>\n<p>sort (A) 若 A 是向量不管是列还是行向量，默认都是对 A 进行升序排序，sort (A) 是默认的升序，而 sort (A,‘descend’) 是降序<br>\n若 A 是矩阵，默认对 A 的割裂进行升序排列<br>\n sort (A , dim) ;<br>\ndim = 1 时 等效于 sort (A) ;<br>\ndim = 2 时 表示对 A 的各列进行升序排列<br>\n若欲爆裂排列前的索引，则可用 [sA,index] = sort ( A , ‘decend’ ) ;<br>\nA = [ 2 , 1 , 3 , 8 ]<br>\nsA = [ 8 , 3 , 2 , 1 ]<br>\nindex = [ 4 , 3 , 1 , 2 ]</p>\n<h3 id=\"定义函数\"><a class=\"markdownIt-Anchor\" href=\"#定义函数\">#</a> 定义函数</h3>\n<p>function [输出变量] = 函数名称（输入变量）<br>\n函数的中间部分都是函数体<br>\n函数的最后要用 end 结尾<br>\n输出变量和输入变量可以有多个，用逗号隔开<br>\n例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ a , b , c ] = test ( d , e , f ) </span><br><span class=\"line\">a = d + e ;</span><br><span class=\"line\">b = e + f ; </span><br><span class=\"line\">c = f + d ; </span><br><span class=\"line\">end </span><br></pre></td></tr></table></figure>\n<h3 id=\"zeros-ones函数\"><a class=\"markdownIt-Anchor\" href=\"#zeros-ones函数\">#</a> zeros, ones 函数</h3>\n<p>zeros ( 3 ) ;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans = </span><br><span class=\"line\">0 0 0 </span><br><span class=\"line\">0 0 0 </span><br><span class=\"line\">0 0 0 </span><br></pre></td></tr></table></figure>\n<p>zeros ( 3 , 1 ) ;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans = </span><br><span class=\"line\">0 </span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p>ones 同理</p>\n",
            "tags": [
                "数学建模",
                "TOPSIS",
                "Matlab"
            ]
        }
    ]
}