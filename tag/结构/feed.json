{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amentiraz • All posts by \"结构\" tag",
    "description": "",
    "home_page_url": "http://Amentiraz.github.io",
    "items": [
        {
            "id": "http://amentiraz.github.io/2021/11/22/%E7%BB%93%E6%9E%84/",
            "url": "http://amentiraz.github.io/2021/11/22/%E7%BB%93%E6%9E%84/",
            "title": "结构",
            "date_published": "2021-11-22T13:02:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-TxVuxMvi\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"29393038\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<h3 id=\"结构的基本知识\"><a class=\"markdownIt-Anchor\" href=\"#结构的基本知识\">#</a> 结构的基本知识</h3>\n<p>结构是一个或者多个变量的几何，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。<br>\n结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值，在 ANSI 标准中，自动结构和数组现在也可以进行初始化。</p>\n<span id=\"more\"></span>\n<p>我们首先来看一个关于平面坐标的结构体</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct point &#123;</span><br><span class=\"line\">    int x , y ; </span><br><span class=\"line\">&#125; ; </span><br></pre></td></tr></table></figure>\n<p>关键字 struct 引入结构声明。结构声明由包含在花括号内的一系列声明组成。关键字 struct 后面的名字是可选的，称为<em>结构标记</em>（这里是 point）。<br>\n结构标记用于为结构命名，在定义之后，结构标记就代表花括号内的声明，可以用它作为该声明的简写形式。<br>\n结构中定义的变量称为<em>成员</em>。结构成员，结构标记和普通变量（即非成员）可以采用相同的名字，它们之间不会冲突，因为通过上下文分析总可以对它们进行区分。不同结构中的成员也可以使用相同的名字。<br>\nstruct 声明定义了一种数据类型，在标志结构成员表结束的右花括号之后可以跟一个变量表，这与其它基本类型的变量声明是相同的。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct &#123; ... &#125; x , y , z ; </span><br></pre></td></tr></table></figure>\n<p>从语法角度来说，这种声明与声明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int x , y , z ; </span><br></pre></td></tr></table></figure>\n<p>具有类似的意义。如果结构声明的后面不带变量表，则不需要为它分配存储空间，它仅仅描述了一个结构的模版。但是，如果结构声明中带有标记，那么在以后定义结构实例时便可以使用该标记定义。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct point maxpt = &#123; 320 , 200 &#125; ; </span><br></pre></td></tr></table></figure>\n<p>定义了一个 struct point 类型的变量 pt。结构的初始化可以在定义的后面使用初值表进行，除指标中同每个成员对应的处置必须是常量表达式。<br>\n自动结构也可以通过赋值初始化，还可以通过调用返回相应类型结构中的成员。<br>\n在表达式中可以通过下列形式引用某哥特定结构中的成员：<br>\n结构名。成员<br>\n结构可以嵌套，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct rect &#123; </span><br><span class=\"line\">    struct point pt1 ; </span><br><span class=\"line\">    struct point pt2 ; </span><br><span class=\"line\">&#125; ;</span><br><span class=\"line\">struct rec screen ; </span><br></pre></td></tr></table></figure>\n<p>我们可以使用语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">screen.pt1.x ; </span><br></pre></td></tr></table></figure>\n<h3 id=\"结构与函数\"><a class=\"markdownIt-Anchor\" href=\"#结构与函数\">#</a> 结构与函数</h3>\n<p>结构的合法操作只有：</p>\n<ol>\n<li>作为一个整体赋值</li>\n<li>通过 &amp; 运算符取地址，访问其成员。</li>\n</ol>\n<p>其中复制和复制包括向函数传递参数以及从函数返回值。结构之间不可以进行比较。<br>\n可以用一个常量成员值列表初始化结构，自动结构也可以通过赋值进行初始化。<br>\n我们可以通过至少 3 种方法传递结构：</p>\n<ol>\n<li>分别传递各个结构成员</li>\n<li>传递整个结构</li>\n<li>传递指向结构的指针</li>\n</ol>\n<p>例如以下函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct point makepoint ( int x , int y ) &#123;</span><br><span class=\"line\">    struct point temp ; </span><br><span class=\"line\">    temp.x = x ; temp.y = y ; </span><br><span class=\"line\">    return temp ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">struct rect screen ; </span><br><span class=\"line\">struct point middle ; </span><br><span class=\"line\">struct point makepoint ( int , int ) ; </span><br><span class=\"line\">screen.pt1 = makepoint ( 0 , 0 ) ; </span><br><span class=\"line\">screen.pt2 = makepoint ( XMAX , YMAX ) ; </span><br><span class=\"line\">middle = makepoint ( ( screen.pt1.x + screen.pt2.x ) &gt;&gt; 1 , ( screen.pt1.y + screen.pt2.y ) &gt;&gt; 1 ) ; </span><br><span class=\"line\"></span><br><span class=\"line\">struct point addpoint ( struct point p1 , struct point p2 ) &#123; </span><br><span class=\"line\">    p1.x += p2.x ; </span><br><span class=\"line\">    p1.y += p2.y ; </span><br><span class=\"line\">    return p1 ; </span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n<p>addpoint 函数的参数和返回值都是结构类型，结构类型的参数和其它参数是一样的都是通过值传递的。</p>\n<p>如果传递给函数的结构很大，使用指针方式的效率通常比赋值整个结构的效率更高，结构指针类似于普通变量指针。声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct point * pp ; </span><br></pre></td></tr></table></figure>\n<p>如果 pp 指向一个 point 结构，那么 * pp 即为该结构，而（ * pp ).x 和 (* pp).y 则是结构成员。其中 ( * pp ).x 的圆括号是必须的，因为结构成员运算符 &quot;.“的优先级比”*&quot; 的优先级高。表达式 * pp.x 的含义等价于 *(pp.x)，因为 x 不是指针，所以该表达式是非法的。<br>\n结构指针的使用频率非常高，为了使用方便，C 语言提供了另一种简写方式。嘉定 p 是一个指向结构的指针，可以用<br>\n p-&gt; 结构成员<br>\n这种形式来引用相应的结构成员。<br>\n运算符。和 -&gt; 都是从左至右结合的，所以以下声明都是等价的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct rec r , * rp = &amp; r ; </span><br><span class=\"line\"></span><br><span class=\"line\">r.pt1.x </span><br><span class=\"line\">rp-&gt;pt1.x </span><br><span class=\"line\">(r.pt1).x </span><br><span class=\"line\">(rp-&gt;pt1).x</span><br></pre></td></tr></table></figure>\n<p>在所有运算符中，下面 4 个运算符的优先级最高：结构运算符 “.” 和 “-&gt;”、用于函数<br>\n调用的 “()” 以及用于下标的 “[]”，因此，它们同操作数之间的结合也最紧密。例如，对于<br>\n结构声明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct &#123; </span><br><span class=\"line\">    int len; </span><br><span class=\"line\">    char *str; </span><br><span class=\"line\">&#125; *p ;</span><br></pre></td></tr></table></figure>\n<p>表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">++p-&gt;len</span><br></pre></td></tr></table></figure>\n<p>将增加 len 的值，而不是增加 p 的值，这是田为，其中的隐含括号关系是 ++(p-&gt;len)。可 以使用括号改变结合次序。例如：(<ins>p)-&gt;len 将先执行 p 的加 1 操作，再对 len 执行操作； 而 (p</ins>)-&gt;len 则先对 len 执行操作，然后再将 p 加 1（该表达式中的括号可以省略）。 同样的道理，*p-&gt;str 读取的是指针 str 所指向的对象的值；*p-&gt;str<ins> 先读取指针 str 指向的对象的值，然后再将 str 加 1（与 * s</ins> 相同）；(*p-&gt;str）<ins>将指针 str 指向 的对象的值加 1；*p</ins>-&gt;str 先读取指针 str 指向的对象的值，然后再将 p 加 1。</p>\n<h3 id=\"结构数组\"><a class=\"markdownIt-Anchor\" href=\"#结构数组\">#</a> 结构数组</h3>\n<p>考虑编写一个程序，用来统计输入中各个 C 语言关键字出现的次数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct key &#123;</span><br><span class=\"line\">    char *word;</span><br><span class=\"line\">    int count;</span><br><span class=\"line\">&#125; keytab[] = &#123;</span><br><span class=\"line\">    &quot;auto&quot;, 0,</span><br><span class=\"line\">    &quot;break&quot;, 0,</span><br><span class=\"line\">    &quot;case&quot;, 0,</span><br><span class=\"line\">    &quot;char&quot;, 0,</span><br><span class=\"line\">    &quot;const&quot;, 0,</span><br><span class=\"line\">    &quot;continue&quot;, 0,</span><br><span class=\"line\">    &quot;default&quot;, 0,</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">    &quot;unsigned&quot;, 0,</span><br><span class=\"line\">    &quot;void&quot;, 0,</span><br><span class=\"line\">    &quot;volatile&quot;, 0,</span><br><span class=\"line\">    &quot;while&quot;, 0</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>与结构成员相对应，初值也要按照成对的方式列出。更精确的做法是，将每一行（即每个结<br>\n构）的初值都括在花括号内，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;auto&quot;, 0 &#125;, </span><br><span class=\"line\">&#123; &quot;break&quot;, 0 &#125;, </span><br><span class=\"line\">&#123; &quot;case&quot;, 0 &#125;, </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>但是，如果初值是简单变量或字符串，并且其中的任何值都不为空，则内层的花括号可以省 略。通常情况下，如果初值存在并且方括号 [ ] 中没有数值，编译程序将计算数组 keytab 中 的项数。<br>\n在统计关键字出现次数的程序中，我们首先定义了 keytab。主程序反复调用函数 getword 读取输入，每次读取一个单词。每个单词将通过折半查找函数在 keytab 中进行查找。注意，关键字列表必须按升序存储在 keytab 中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;ctype.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#define MAXWORD 100</span><br><span class=\"line\">int getword(char *, int);</span><br><span class=\"line\">int binsearch(char *, struct key *, int);</span><br><span class=\"line\">/* count C keywords */</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    char word[MAXWORD];</span><br><span class=\"line\">    while (getword(word, MAXWORD) != EOF)</span><br><span class=\"line\">        if (isalpha(word[0]))</span><br><span class=\"line\">              if ((n = binsearch(word, keytab, NKEYS)) &gt;= 0)</span><br><span class=\"line\">                    keytab[n].count++;</span><br><span class=\"line\">    for (n = 0; n &lt; NKEYS; n++)</span><br><span class=\"line\">        if (keytab[n].count &gt; 0)</span><br><span class=\"line\">            printf(&quot;%4d %s\\n&quot;,</span><br><span class=\"line\">                keytab[n].count, keytab[n].word);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* binsearch: find word in tab[0]...tab[n-1] */</span><br><span class=\"line\">int binsearch(char *word, struct key tab[], int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int cond;</span><br><span class=\"line\">    int low, high, mid;</span><br><span class=\"line\">    low = 0;</span><br><span class=\"line\">    high = n - 1;</span><br><span class=\"line\">    while (low &lt;= high) &#123;</span><br><span class=\"line\">        mid = (low+high) / 2;</span><br><span class=\"line\">        if ((cond = strcmp(word, tab[mid].word)) &lt; 0)</span><br><span class=\"line\">            high = mid - 1;</span><br><span class=\"line\">        else if (cond &gt; 0)</span><br><span class=\"line\">            low = mid + 1;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            return mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int getword ( char * word , int lim ) &#123;</span><br><span class=\"line\">    int c , getch ( void ) ; </span><br><span class=\"line\">    void ungetch ( int ) ; </span><br><span class=\"line\">    char * w = word ; </span><br><span class=\"line\">    while ( isspace ( c = getch ( ) ) ) ; </span><br><span class=\"line\">    if ( c != EOF ) * w ++ ; </span><br><span class=\"line\">    if ( ! isalpha ( c ) ) &#123; * w = &#x27;\\0&#x27; ; return c ; &#125; </span><br><span class=\"line\">    for ( ; -- lim &gt; 0 ; w ++ ) </span><br><span class=\"line\">        if ( ! isnum ( * w = getch ( ) ) ) &#123;</span><br><span class=\"line\">            ungetch ( * w ) ; break ; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    * w = &#x27;\\0&#x27; ; </span><br><span class=\"line\">    return word[0] ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*我们可以通过如下方法计算NKEYS的值*/</span><br><span class=\"line\">#define NKEYS ( sizeof keytab / sizeof ( struct key ) ) </span><br><span class=\"line\">#define NKEYS ( sizeof keytab / sizeof keytab[0] ) </span><br></pre></td></tr></table></figure>\n<p>getchar 函数的返回值也是 int 类型的</p>\n<h3 id=\"指向结构的指针\"><a class=\"markdownIt-Anchor\" href=\"#指向结构的指针\">#</a> 指向结构的指针</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt; </span><br><span class=\"line\">#include &lt;ctype.h&gt; </span><br><span class=\"line\">#include &lt;string.h&gt; </span><br><span class=\"line\">#define MAXWORD 100 </span><br><span class=\"line\">int getword(char *, int); </span><br><span class=\"line\">struct key *binsearch(char *, struct key *, int); </span><br><span class=\"line\">/* count C keywords; pointer version */ </span><br><span class=\"line\">int main() </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    char word[MAXWORD]; </span><br><span class=\"line\">    struct key *p; </span><br><span class=\"line\">    while (getword(word, MAXWORD) != EOF) </span><br><span class=\"line\">        if (isalpha(word[0])) </span><br><span class=\"line\">            if ((p=binsearch(word, keytab, NKEYS)) != NULL) </span><br><span class=\"line\">                p-&gt;count++; </span><br><span class=\"line\">    for (p = keytab; p &lt; keytab + NKEYS; p++) </span><br><span class=\"line\">        if (p-&gt;count &gt; 0) </span><br><span class=\"line\">            printf(&quot;%4d %s\\n&quot;, p-&gt;count, p-&gt;word); </span><br><span class=\"line\">    return 0; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">/* binsearch: find word in tab[0]...tab[n-1] */ </span><br><span class=\"line\">struct key *binsearch(char *word, struck key *tab, int n) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    int cond; </span><br><span class=\"line\">    struct key *low = &amp;tab[0]; </span><br><span class=\"line\">    struct key *high = &amp;tab[n]; </span><br><span class=\"line\">    struct key *mid; </span><br><span class=\"line\">    while (low &lt; high) &#123; </span><br><span class=\"line\">        mid = low + (high-low) / 2; </span><br><span class=\"line\">        if ((cond = strcmp(word, mid-&gt;word)) &lt; 0) </span><br><span class=\"line\">            high = mid; </span><br><span class=\"line\">        else if (cond &gt; 0) </span><br><span class=\"line\">            low = mid + 1; </span><br><span class=\"line\">        else </span><br><span class=\"line\">            return mid; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    return NULL; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一个部分比较简单，就不细写了，上面的程序等于是改写了一下。搜索函数里面的 while 循环是为了防止死循环写的，当 high==low 的时候，如果没有 low&lt;high 这个条件会一直死循环下去。<br>\n特别需要注意的是千万不要认为结构的长度等于各成员长度的和。因为不同的对象有不同的对齐要 求，所以，结构中可能会出现未命名的 “空穴 “（hole）。例如，假设 char 类型占用一个字节，int 类型占用 4 个字节，则下列结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct &#123; </span><br><span class=\"line\">    char c; </span><br><span class=\"line\">    int i; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<p>可能需要 8 个字节的存储空间，而不是 5 个字节。使用 sizeof 运算符可以返回正确的对象<br>\n长度。</p>\n<h3 id=\"自引用结构\"><a class=\"markdownIt-Anchor\" href=\"#自引用结构\">#</a> 自引用结构</h3>\n<p>假定我们需要处理一个更一般化的问题：统计输入中所有单词的出现次数。因为预先不 知道出现的单词列表，所以无法方便地排序，并使用折半查找；也不能分别对输入中的每个单词都执行一次线性查找，看它在前面是否已经出现，这样做，程序的执行将花费太长的时 间。（更准确地说，程序的执行时间是与输入单词数目的二次方成比例的。）我们该如何组织这些数据，才能够有效地处理一系列任意的单词呢？<br>\n一种解决方法是，在读取输入中任意单词的同时，就将它放置到正确的位置，从而始终 保证所有单词是按顺序排列的。虽然这可以不用通过在线性数组中移动单词来实现，但它仍 然会导致程序执行的时间过长。我们可以使用一种称为二叉树的数据结构来取而代之。 每个不同的单词在树中都是一个节点，每个节点包含：</p>\n<ol>\n<li>一个指向该单词内容的指针</li>\n<li>一个统计出现次数的计数值・一个指向左子树的指针</li>\n<li>一个指向右子树的指针<br>\n任何节点最多拥有两个子树，也可能只有一个子树或一个都没有。 对节点的所有操作要保证，任何节点的左子树只包含按字典序小于该节点中单词的那些单词，右子树只包含按字典序大于该节点中单词的那些单词。要查找一个新单词是否已经在树中，可以从根节点开始，比较新单词与该节点中的单词。若 匹配，则得到肯定的答案。若新单词小于该节点中的单词，则在左子树中继续查找，否则在 右子树中查找。如在搜寻方向上无子树，则说明新单词不在树中，并且，当前的空位置就是 存放新加入单词的正确位置。因为从任意节点出发的查找都要按照同样的方式查找它的一个子树，所以该过程是递归的。相应地，在插入和打印操作中使用递归过程也是很自然的事情。<br>\n对节点的递归的：</li>\n</ol>\n",
            "tags": [
                "C语言",
                "结构"
            ]
        }
    ]
}