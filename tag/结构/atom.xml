<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://Amentiraz.github.io</id>
    <title>Amentiraz • Posts by &#34;结构&#34; tag</title>
    <link href="http://Amentiraz.github.io" />
    <updated>2021-11-22T13:02:31.000Z</updated>
    <category term="DP" />
    <category term="算法" />
    <category term="Dijkstra" />
    <category term="书评" />
    <category term="LCA" />
    <category term="数学建模" />
    <category term="TOPSIS" />
    <category term="Matlab" />
    <category term="代码" />
    <category term="分布式" />
    <category term="Tarjan" />
    <category term="学习笔记" />
    <category term="C语言" />
    <category term="复习资料" />
    <category term="python" />
    <category term="读书笔记" />
    <category term="生活" />
    <category term="杂" />
    <category term="层次分析法" />
    <category term="诗" />
    <category term="指针" />
    <category term="c语言" />
    <category term="论文" />
    <category term="笔记" />
    <category term="插值算法" />
    <category term="线段树" />
    <category term="结构" />
    <category term="题解" />
    <entry>
        <id>http://amentiraz.github.io/2021/11/22/%E7%BB%93%E6%9E%84/</id>
        <title>结构</title>
        <link rel="alternate" href="http://amentiraz.github.io/2021/11/22/%E7%BB%93%E6%9E%84/"/>
        <content type="html">&lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;script class=&#34;meting-secondary-script-marker&#34; src=&#34;\assets\js\Meting.min.js&#34;&gt;&lt;/script&gt;
    &lt;div id=&#34;aplayer-TxVuxMvi&#34; class=&#34;aplayer aplayer-tag-marker meting-tag-marker&#34;
         data-id=&#34;29393038&#34; data-server=&#34;netease&#34; data-type=&#34;song&#34; data-mode=&#34;circulation&#34; data-autoplay=&#34;true&#34; data-mutex=&#34;true&#34; data-listmaxheight=&#34;340px&#34; data-preload=&#34;none&#34; data-theme=&#34;#ad7a86&#34;
    &gt;&lt;/div&gt;
&lt;h3 id=&#34;结构的基本知识&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#结构的基本知识&#34;&gt;#&lt;/a&gt; 结构的基本知识&lt;/h3&gt;
&lt;p&gt;结构是一个或者多个变量的几何，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。&lt;br&gt;
结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值，在 ANSI 标准中，自动结构和数组现在也可以进行初始化。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;我们首先来看一个关于平面坐标的结构体&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;struct point &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    int x , y ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; ; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关键字 struct 引入结构声明。结构声明由包含在花括号内的一系列声明组成。关键字 struct 后面的名字是可选的，称为&lt;em&gt;结构标记&lt;/em&gt;（这里是 point）。&lt;br&gt;
结构标记用于为结构命名，在定义之后，结构标记就代表花括号内的声明，可以用它作为该声明的简写形式。&lt;br&gt;
结构中定义的变量称为&lt;em&gt;成员&lt;/em&gt;。结构成员，结构标记和普通变量（即非成员）可以采用相同的名字，它们之间不会冲突，因为通过上下文分析总可以对它们进行区分。不同结构中的成员也可以使用相同的名字。&lt;br&gt;
struct 声明定义了一种数据类型，在标志结构成员表结束的右花括号之后可以跟一个变量表，这与其它基本类型的变量声明是相同的。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;struct &amp;#123; ... &amp;#125; x , y , z ; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从语法角度来说，这种声明与声明&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;int x , y , z ; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;具有类似的意义。如果结构声明的后面不带变量表，则不需要为它分配存储空间，它仅仅描述了一个结构的模版。但是，如果结构声明中带有标记，那么在以后定义结构实例时便可以使用该标记定义。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;struct point maxpt = &amp;#123; 320 , 200 &amp;#125; ; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;定义了一个 struct point 类型的变量 pt。结构的初始化可以在定义的后面使用初值表进行，除指标中同每个成员对应的处置必须是常量表达式。&lt;br&gt;
自动结构也可以通过赋值初始化，还可以通过调用返回相应类型结构中的成员。&lt;br&gt;
在表达式中可以通过下列形式引用某哥特定结构中的成员：&lt;br&gt;
结构名。成员&lt;br&gt;
结构可以嵌套，例如&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;struct rect &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    struct point pt1 ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    struct point pt2 ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;struct rec screen ; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以使用语句&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;screen.pt1.x ; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;结构与函数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#结构与函数&#34;&gt;#&lt;/a&gt; 结构与函数&lt;/h3&gt;
&lt;p&gt;结构的合法操作只有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为一个整体赋值&lt;/li&gt;
&lt;li&gt;通过 &amp;amp; 运算符取地址，访问其成员。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中复制和复制包括向函数传递参数以及从函数返回值。结构之间不可以进行比较。&lt;br&gt;
可以用一个常量成员值列表初始化结构，自动结构也可以通过赋值进行初始化。&lt;br&gt;
我们可以通过至少 3 种方法传递结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分别传递各个结构成员&lt;/li&gt;
&lt;li&gt;传递整个结构&lt;/li&gt;
&lt;li&gt;传递指向结构的指针&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如以下函数&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;struct point makepoint ( int x , int y ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    struct point temp ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    temp.x = x ; temp.y = y ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    return temp ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;struct rect screen ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;struct point middle ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;struct point makepoint ( int , int ) ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;screen.pt1 = makepoint ( 0 , 0 ) ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;screen.pt2 = makepoint ( XMAX , YMAX ) ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;middle = makepoint ( ( screen.pt1.x + screen.pt2.x ) &amp;gt;&amp;gt; 1 , ( screen.pt1.y + screen.pt2.y ) &amp;gt;&amp;gt; 1 ) ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;struct point addpoint ( struct point p1 , struct point p2 ) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    p1.x += p2.x ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    p1.y += p2.y ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    return p1 ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;   &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;addpoint 函数的参数和返回值都是结构类型，结构类型的参数和其它参数是一样的都是通过值传递的。&lt;/p&gt;
&lt;p&gt;如果传递给函数的结构很大，使用指针方式的效率通常比赋值整个结构的效率更高，结构指针类似于普通变量指针。声明：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;struct point * pp ; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果 pp 指向一个 point 结构，那么 * pp 即为该结构，而（ * pp ).x 和 (* pp).y 则是结构成员。其中 ( * pp ).x 的圆括号是必须的，因为结构成员运算符 &amp;quot;.“的优先级比”*&amp;quot; 的优先级高。表达式 * pp.x 的含义等价于 *(pp.x)，因为 x 不是指针，所以该表达式是非法的。&lt;br&gt;
结构指针的使用频率非常高，为了使用方便，C 语言提供了另一种简写方式。嘉定 p 是一个指向结构的指针，可以用&lt;br&gt;
 p-&amp;gt; 结构成员&lt;br&gt;
这种形式来引用相应的结构成员。&lt;br&gt;
运算符。和 -&amp;gt; 都是从左至右结合的，所以以下声明都是等价的：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;struct rec r , * rp = &amp;amp; r ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;r.pt1.x &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;rp-&amp;gt;pt1.x &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(r.pt1).x &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(rp-&amp;gt;pt1).x&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在所有运算符中，下面 4 个运算符的优先级最高：结构运算符 “.” 和 “-&amp;gt;”、用于函数&lt;br&gt;
调用的 “()” 以及用于下标的 “[]”，因此，它们同操作数之间的结合也最紧密。例如，对于&lt;br&gt;
结构声明&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;struct &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    int len; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    char *str; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; *p ;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;表达式&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;++p-&amp;gt;len&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将增加 len 的值，而不是增加 p 的值，这是田为，其中的隐含括号关系是 ++(p-&amp;gt;len)。可 以使用括号改变结合次序。例如：(&lt;ins&gt;p)-&amp;gt;len 将先执行 p 的加 1 操作，再对 len 执行操作； 而 (p&lt;/ins&gt;)-&amp;gt;len 则先对 len 执行操作，然后再将 p 加 1（该表达式中的括号可以省略）。 同样的道理，*p-&amp;gt;str 读取的是指针 str 所指向的对象的值；*p-&amp;gt;str&lt;ins&gt; 先读取指针 str 指向的对象的值，然后再将 str 加 1（与 * s&lt;/ins&gt; 相同）；(*p-&amp;gt;str）&lt;ins&gt;将指针 str 指向 的对象的值加 1；*p&lt;/ins&gt;-&amp;gt;str 先读取指针 str 指向的对象的值，然后再将 p 加 1。&lt;/p&gt;
&lt;h3 id=&#34;结构数组&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#结构数组&#34;&gt;#&lt;/a&gt; 结构数组&lt;/h3&gt;
&lt;p&gt;考虑编写一个程序，用来统计输入中各个 C 语言关键字出现的次数。&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;struct key &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    char *word;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    int count;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; keytab[] = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;auto&amp;quot;, 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;break&amp;quot;, 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;case&amp;quot;, 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;char&amp;quot;, 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;const&amp;quot;, 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;continue&amp;quot;, 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;default&amp;quot;, 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    /* ... */&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;unsigned&amp;quot;, 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;void&amp;quot;, 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;volatile&amp;quot;, 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;while&amp;quot;, 0&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;与结构成员相对应，初值也要按照成对的方式列出。更精确的做法是，将每一行（即每个结&lt;br&gt;
构）的初值都括在花括号内，如下所示：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &amp;quot;auto&amp;quot;, 0 &amp;#125;, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &amp;quot;break&amp;quot;, 0 &amp;#125;, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &amp;quot;case&amp;quot;, 0 &amp;#125;, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，如果初值是简单变量或字符串，并且其中的任何值都不为空，则内层的花括号可以省 略。通常情况下，如果初值存在并且方括号 [ ] 中没有数值，编译程序将计算数组 keytab 中 的项数。&lt;br&gt;
在统计关键字出现次数的程序中，我们首先定义了 keytab。主程序反复调用函数 getword 读取输入，每次读取一个单词。每个单词将通过折半查找函数在 keytab 中进行查找。注意，关键字列表必须按升序存储在 keytab 中。&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;56&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;lt;ctype.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#define MAXWORD 100&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;int getword(char *, int);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;int binsearch(char *, struct key *, int);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;/* count C keywords */&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    int n;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    char word[MAXWORD];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    while (getword(word, MAXWORD) != EOF)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        if (isalpha(word[0]))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;              if ((n = binsearch(word, keytab, NKEYS)) &amp;gt;= 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    keytab[n].count++;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    for (n = 0; n &amp;lt; NKEYS; n++)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        if (keytab[n].count &amp;gt; 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            printf(&amp;quot;%4d %s\n&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                keytab[n].count, keytab[n].word);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;/* binsearch: find word in tab[0]...tab[n-1] */&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;int binsearch(char *word, struct key tab[], int n)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    int cond;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    int low, high, mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    low = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    high = n - 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    while (low &amp;lt;= high) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        mid = (low+high) / 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        if ((cond = strcmp(word, tab[mid].word)) &amp;lt; 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            high = mid - 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        else if (cond &amp;gt; 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            low = mid + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        else&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            return mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    return -1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;int getword ( char * word , int lim ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    int c , getch ( void ) ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    void ungetch ( int ) ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    char * w = word ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    while ( isspace ( c = getch ( ) ) ) ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if ( c != EOF ) * w ++ ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if ( ! isalpha ( c ) ) &amp;#123; * w = &amp;#x27;\0&amp;#x27; ; return c ; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    for ( ; -- lim &amp;gt; 0 ; w ++ ) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        if ( ! isnum ( * w = getch ( ) ) ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            ungetch ( * w ) ; break ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    * w = &amp;#x27;\0&amp;#x27; ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    return word[0] ; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;/*我们可以通过如下方法计算NKEYS的值*/&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#define NKEYS ( sizeof keytab / sizeof ( struct key ) ) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#define NKEYS ( sizeof keytab / sizeof keytab[0] ) &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;getchar 函数的返回值也是 int 类型的&lt;/p&gt;
&lt;h3 id=&#34;指向结构的指针&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#指向结构的指针&#34;&gt;#&lt;/a&gt; 指向结构的指针&lt;/h3&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;lt;stdio.h&amp;gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;lt;ctype.h&amp;gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;lt;string.h&amp;gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#define MAXWORD 100 &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;int getword(char *, int); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;struct key *binsearch(char *, struct key *, int); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;/* count C keywords; pointer version */ &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;int main() &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    char word[MAXWORD]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    struct key *p; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    while (getword(word, MAXWORD) != EOF) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        if (isalpha(word[0])) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            if ((p=binsearch(word, keytab, NKEYS)) != NULL) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                p-&amp;gt;count++; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    for (p = keytab; p &amp;lt; keytab + NKEYS; p++) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        if (p-&amp;gt;count &amp;gt; 0) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            printf(&amp;quot;%4d %s\n&amp;quot;, p-&amp;gt;count, p-&amp;gt;word); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    return 0; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;/* binsearch: find word in tab[0]...tab[n-1] */ &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;struct key *binsearch(char *word, struck key *tab, int n) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    int cond; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    struct key *low = &amp;amp;tab[0]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    struct key *high = &amp;amp;tab[n]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    struct key *mid; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    while (low &amp;lt; high) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        mid = low + (high-low) / 2; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        if ((cond = strcmp(word, mid-&amp;gt;word)) &amp;lt; 0) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            high = mid; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        else if (cond &amp;gt; 0) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            low = mid + 1; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        else &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            return mid; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    return NULL; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这一个部分比较简单，就不细写了，上面的程序等于是改写了一下。搜索函数里面的 while 循环是为了防止死循环写的，当 high==low 的时候，如果没有 low&amp;lt;high 这个条件会一直死循环下去。&lt;br&gt;
特别需要注意的是千万不要认为结构的长度等于各成员长度的和。因为不同的对象有不同的对齐要 求，所以，结构中可能会出现未命名的 “空穴 “（hole）。例如，假设 char 类型占用一个字节，int 类型占用 4 个字节，则下列结构：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;struct &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    char c; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    int i; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可能需要 8 个字节的存储空间，而不是 5 个字节。使用 sizeof 运算符可以返回正确的对象&lt;br&gt;
长度。&lt;/p&gt;
&lt;h3 id=&#34;自引用结构&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#自引用结构&#34;&gt;#&lt;/a&gt; 自引用结构&lt;/h3&gt;
&lt;p&gt;假定我们需要处理一个更一般化的问题：统计输入中所有单词的出现次数。因为预先不 知道出现的单词列表，所以无法方便地排序，并使用折半查找；也不能分别对输入中的每个单词都执行一次线性查找，看它在前面是否已经出现，这样做，程序的执行将花费太长的时 间。（更准确地说，程序的执行时间是与输入单词数目的二次方成比例的。）我们该如何组织这些数据，才能够有效地处理一系列任意的单词呢？&lt;br&gt;
一种解决方法是，在读取输入中任意单词的同时，就将它放置到正确的位置，从而始终 保证所有单词是按顺序排列的。虽然这可以不用通过在线性数组中移动单词来实现，但它仍 然会导致程序执行的时间过长。我们可以使用一种称为二叉树的数据结构来取而代之。 每个不同的单词在树中都是一个节点，每个节点包含：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个指向该单词内容的指针&lt;/li&gt;
&lt;li&gt;一个统计出现次数的计数值・一个指向左子树的指针&lt;/li&gt;
&lt;li&gt;一个指向右子树的指针&lt;br&gt;
任何节点最多拥有两个子树，也可能只有一个子树或一个都没有。 对节点的所有操作要保证，任何节点的左子树只包含按字典序小于该节点中单词的那些单词，右子树只包含按字典序大于该节点中单词的那些单词。要查找一个新单词是否已经在树中，可以从根节点开始，比较新单词与该节点中的单词。若 匹配，则得到肯定的答案。若新单词小于该节点中的单词，则在左子树中继续查找，否则在 右子树中查找。如在搜寻方向上无子树，则说明新单词不在树中，并且，当前的空位置就是 存放新加入单词的正确位置。因为从任意节点出发的查找都要按照同样的方式查找它的一个子树，所以该过程是递归的。相应地，在插入和打印操作中使用递归过程也是很自然的事情。&lt;br&gt;
对节点的递归的：&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="C语言" />
        <category term="结构" />
        <updated>2021-11-22T13:02:31.000Z</updated>
    </entry>
</feed>
