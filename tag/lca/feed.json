{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amentiraz • All posts by \"lca\" tag",
    "description": "",
    "home_page_url": "http://Amentiraz.github.io",
    "items": [
        {
            "id": "http://amentiraz.github.io/2021/11/29/LCA/",
            "url": "http://amentiraz.github.io/2021/11/29/LCA/",
            "title": "LCA",
            "date_published": "2021-11-29T03:20:10.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-RdztVWRC\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"29850611\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<blockquote>\n<p>LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点 u 和 v 最近的公共祖先。 ——— 来自百度百科</p>\n</blockquote>\n<p>对于一棵树来说，我们为了求它的最近公共祖先其实思路和快速幂是差不多的，我们不能直接一个个的向上查找，这样会使时间复杂度爆表，我们应当以 2^k 的速率往上找，这样可以使其时间复杂度降为 log 级别。<br>\n不得不说 luogu 上的题解实在是晦涩难懂，我能明白他们在寻找相同深度的点的时候使用 log 可以更快的找到，但是其实可以一层层的向上跳，可能时间复杂度常数上乘个 5 左右的数，但影响不大。（还是自己的代码好懂）<br>\n听说树链剖分也可以做，但这玩意写起来太麻烦了，我高中最快时写一遍也要半个小时（毕竟 100 多行）<br>\n总之，我们求 LCA 时首先找每个节点 2^i 的父亲，然后先将它们跳到相同的深度然后再同时向上跳，注意特判其中一个节点就是 LCA。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std ;</span><br><span class=\"line\"></span><br><span class=\"line\">const int maxn = 1000005 ;</span><br><span class=\"line\">int n , m , s ;</span><br><span class=\"line\">int head[maxn] , to[maxn] , nex[maxn] , cnt = 0 ;</span><br><span class=\"line\">int father[maxn][20] , dep[maxn] ;</span><br><span class=\"line\"></span><br><span class=\"line\">void add ( int x , int y ) &#123; nex[++cnt] = head[x] ; head[x] = cnt ; to[cnt] = y ; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void dfs ( int x , int fa , int depth ) &#123;</span><br><span class=\"line\">    father[x][0] = fa ; dep[x] = depth ;</span><br><span class=\"line\">    for ( int i = 1 ; i &lt;= 19 ; i ++ ) &#123;</span><br><span class=\"line\">        father[x][i] = father[father[x][i-1]][i-1] ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for ( int i = head[x] ; i ; i = nex[i] ) &#123;</span><br><span class=\"line\">        if ( to[i] == fa ) continue ;</span><br><span class=\"line\">        dfs ( to[i] , x , depth + 1 ) ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int LCA ( int x , int y ) &#123;</span><br><span class=\"line\">    if ( dep[x] &lt; dep[y] ) swap ( x , y ) ;</span><br><span class=\"line\">    for ( int i = 19 ; i &gt;= 0 ; i -- ) &#123;</span><br><span class=\"line\">        if ( dep[father[x][i]] &gt;= dep[y] ) &#123;</span><br><span class=\"line\">            x = father[x][i] ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( x == y ) return x ;</span><br><span class=\"line\">    for ( int i = 19 ; i &gt;= 0 ; i -- ) &#123;</span><br><span class=\"line\">        if ( father[x][i] != father[y][i] ) &#123;</span><br><span class=\"line\">            x = father[x][i] , y = father[y][i] ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return father[x][0] ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main ( ) &#123;</span><br><span class=\"line\">    scanf ( &quot;%d%d%d&quot; , &amp; n , &amp; m , &amp; s ) ;</span><br><span class=\"line\">    for ( int i = 1 ; i &lt; n ; i ++ ) &#123;</span><br><span class=\"line\">        int x , y ; scanf ( &quot;%d%d&quot; , &amp; x , &amp; y ) ;</span><br><span class=\"line\">        add ( x , y ) ; add ( y , x ) ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs ( s , 0 , 1 ) ;</span><br><span class=\"line\">    while ( m -- ) &#123;</span><br><span class=\"line\">        int x , y ; scanf ( &quot;%d%d&quot; , &amp; x , &amp; y ) ;</span><br><span class=\"line\">        printf ( &quot;%d\\n&quot; , LCA ( x , y ) ) ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法",
                "LCA"
            ]
        }
    ]
}