{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amentiraz • All posts by \"学习笔记\" tag",
    "description": "",
    "home_page_url": "http://Amentiraz.github.io",
    "items": [
        {
            "id": "http://amentiraz.github.io/2024/09/19/%E4%BF%9D%E7%A0%94%E5%A4%8D%E8%AF%95%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%8B%AC/",
            "url": "http://amentiraz.github.io/2024/09/19/%E4%BF%9D%E7%A0%94%E5%A4%8D%E8%AF%95%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%8B%AC/",
            "title": "保研复试复习总括",
            "date_published": "2024-09-19T02:26:45.000Z",
            "content_html": "<p>本文针对保研复试进行总复习，对目前的自己针对机器学习、计算机组织，包括数学建模、ACM 等等学科进行自己的理解和概括，以总述为主，内容复习为辅。<br>\n目的是为了在复试时更好的吹牛 qwq。</p>\n<span id=\"more\"></span>\n<h1 id=\"机器学习\"><a class=\"markdownIt-Anchor\" href=\"#机器学习\">#</a> 机器学习</h1>\n<h2 id=\"内容复习\"><a class=\"markdownIt-Anchor\" href=\"#内容复习\">#</a> 内容复习</h2>\n<h3 id=\"绪论\"><a class=\"markdownIt-Anchor\" href=\"#绪论\">#</a> 绪论</h3>\n<p>无论学习算法 A 多聪明，学习算法 B 多笨拙，期望性能是完全相同的。（NFL 定理）<br>\n脱离实际问题，空泛的谈论算法优劣没有意义。<br>\n机器学习为交叉学习提供技术支撑，本质上机器学习就是利用大数据<br>\n数据库为数据挖掘提供数据管理技术，机器学习和统计学提供数据分析技术。</p>\n<h3 id=\"模型评估与选择\"><a class=\"markdownIt-Anchor\" href=\"#模型评估与选择\">#</a> 模型评估与选择</h3>\n<p>过拟合无法彻底避免，我们能做的只有缓解<br>\n调参和算法选择没有什么本质区别<br>\n泛化误差可分解为偏差、方差和噪声之和。</p>\n<h3 id=\"线性模型\"><a class=\"markdownIt-Anchor\" href=\"#线性模型\">#</a> 线性模型</h3>\n<p>形式简单、易于建模。<br>\n线性回归：均方误差最小化<br>\n线性判别分析：将样本投到一条直线上（更低维的空间）。<br>\n多分类问题：一对一、一对多、多对多。</p>\n<h3 id=\"决策树\"><a class=\"markdownIt-Anchor\" href=\"#决策树\">#</a> 决策树</h3>\n<p>信息增益、希望决策树的样本划分尽可能属于同一类别，数据挖掘里面讲到过。还有剪枝的内容，泛化能力更强。</p>\n<h3 id=\"神经网络\"><a class=\"markdownIt-Anchor\" href=\"#神经网络\">#</a> 神经网络</h3>\n<p>感知机（Perception）<br>\nBP 算法（误差逆传播）（error BackPropagation)</p>\n<h3 id=\"支持向量机\"><a class=\"markdownIt-Anchor\" href=\"#支持向量机\">#</a> 支持向量机</h3>\n<p>划分的超平面对于训练样本的局部扰动的 “容忍” 性最好<br>\n软间隔、正则化（一种罚函数）</p>\n<h3 id=\"贝叶斯分类器\"><a class=\"markdownIt-Anchor\" href=\"#贝叶斯分类器\">#</a> 贝叶斯分类器</h3>\n<p>基于后验概率</p>\n<h3 id=\"集成学习\"><a class=\"markdownIt-Anchor\" href=\"#集成学习\">#</a> 集成学习</h3>\n<p>构建并结合多个学习器来完成学习任务，也被称为多分类器系统。<br>\nBoosting：弱学习器提升为强学习器<br>\n bagging：自助法啥的</p>\n<h3 id=\"聚类\"><a class=\"markdownIt-Anchor\" href=\"#聚类\">#</a> 聚类</h3>\n<p>无监督。。。</p>\n<h2 id=\"理念概括\"><a class=\"markdownIt-Anchor\" href=\"#理念概括\">#</a> 理念概括</h2>\n<p>利用数据对未来情况进行预测，模型构建的过程中算法从数据提取特征和规律，构建数学模型来表示复杂的关系，希望具有泛化的能力和持续改进的功能。<br>\n数据质量，特征提取，模型选择，过拟合欠拟合找到平衡，选用适当的评估指标，模型的可解释性，数据的划分，运行的成本</p>\n<h1 id=\"数据挖掘\"><a class=\"markdownIt-Anchor\" href=\"#数据挖掘\">#</a> 数据挖掘</h1>\n<h2 id=\"内容\"><a class=\"markdownIt-Anchor\" href=\"#内容\">#</a> 内容</h2>\n<h3 id=\"绪论-2\"><a class=\"markdownIt-Anchor\" href=\"#绪论-2\">#</a> 绪论</h3>\n<p>数据挖掘是在大型数据存储库中，自动的发现有用信息的过程。数据挖掘技术用来探查大型数据库，发现先前未知的有用模式。<br>\n数据预处理是将未加工的输入数据转换成适合分析的形式<br>\n任务：预测任务，描述任务，预测建模</p>\n<h3 id=\"数据\"><a class=\"markdownIt-Anchor\" href=\"#数据\">#</a> 数据</h3>\n<p>数据类型、数据质量、预处理步骤，数据之间的联系。<br>\n<img data-src=\"1.jpg\" alt=\"\"><br>\n数据预处理：聚类、抽样、维归约、特征子集选择、特征创建、离散化和二元化、变量变换</p>\n<h3 id=\"探索数据\"><a class=\"markdownIt-Anchor\" href=\"#探索数据\">#</a> 探索数据</h3>\n<p>对于有序数据，考虑值的百分位数更有意义。第 <code>p</code>  个百分位数 <code>xp</code>  是一个 <code>x</code>  值，使得 <code>x</code>  的 <code>p%</code>  的观测值小于 <code>xp</code> <br>\n 可视化：直方图、盒状图、饼图、散布图</p>\n<h3 id=\"分类\"><a class=\"markdownIt-Anchor\" href=\"#分类\">#</a> 分类</h3>\n<p>略</p>\n<h2 id=\"理念概括-2\"><a class=\"markdownIt-Anchor\" href=\"#理念概括-2\">#</a> 理念概括</h2>\n<p>没什么好概括的<br>\n实际和机器学习概括的差不多</p>\n<hr>\n<p>一坨屎，妈的，我已经足够了解这个方面的知识了，明天问啥答啥，爱要不要。</p>\n<hr>\n<p>结果复习一天的内容屁都没用上，面试就是即兴英语口语 + 竞赛经历讲解 + tree new bee。老师问啥我答啥，照这些老师喜欢的方向去回答，最后目测这些老师都挺满意的，应该问题不大（希望不是 flag）。这玩意还是得硬实力够啊，我看前面的都挺折磨，估计是项目经历不真实导致的吧。</p>\n<p>就我个人观察而言，面试技巧已经没啥特别加分的作用了，大家都会，老师也都知道，反套路搞你几句你也寄。实际上，在大家都不会面试技巧时，考察的是情商；然而，在大家都会面试技巧时，考察的照样是情商。走捷径是没有用的。</p>\n",
            "tags": [
                "学习笔记"
            ]
        },
        {
            "id": "http://amentiraz.github.io/2022/01/12/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/",
            "url": "http://amentiraz.github.io/2022/01/12/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/",
            "title": "python学习笔记1",
            "date_published": "2022-01-12T11:55:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-FVVRxfLT\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"1458550\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>除开函数外的 python 基础知识总汇，用于复习及查看，写的会很简略</p>\n<span id=\"more\"></span>\n<h3 id=\"基础知识\"><a class=\"markdownIt-Anchor\" href=\"#基础知识\">#</a> 基础知识</h3>\n<p>普通的除法：1/2  0.5<br>\n 整除: 1//2 0<br>\n 取模：%<br>\n 乘方：2<strong>3 (-3</strong>2 等同于 -(3**2))</p>\n<p>十六进制：0xAF<br>\n 八进制：010</p>\n<p>变量无需声明即可使用</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">3</span> </span><br><span class=\"line\">x * <span class=\"number\">2</span> </span><br><span class=\"line\">output : <span class=\"number\">6</span> </span><br></pre></td></tr></table></figure>\n<p>变量名命名同 C 语言</p>\n<p>print 在 python2 是语句，在 python3 中是函数，所以应当加上（）</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">input</span> ( <span class=\"string\">&quot;The meaning of life: &quot;</span> )</span><br><span class=\"line\">The meaning of life <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = <span class=\"built_in\">input</span> ( <span class=\"string\">&quot;x: &quot;</span> ) </span><br><span class=\"line\">x: <span class=\"number\">34</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = <span class=\"built_in\">input</span> ( <span class=\"string\">&quot;y: &quot;</span> ) </span><br><span class=\"line\">y : <span class=\"number\">42</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> ( x * y ) </span><br><span class=\"line\"><span class=\"number\">1428</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">pow</span> ( <span class=\"number\">2</span> , <span class=\"number\">3</span> ) </span><br><span class=\"line\"><span class=\"number\">8</span> </span><br></pre></td></tr></table></figure>\n<p>round 函数会把浮点数四舍五入为最接近的整数值 （ py2 与 py3 对于 0.5 的取值有所不同）<br>\nabs 绝对值函数</p>\n<p>可以用变量来引用函数</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math </span><br><span class=\"line\">math.floor( <span class=\"number\">32.9</span> ) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> floor</span><br><span class=\"line\">floor</span><br><span class=\"line\"></span><br><span class=\"line\">foo = math.sqrt </span><br><span class=\"line\">foo ( <span class=\"number\">4</span> ) </span><br></pre></td></tr></table></figure>\n<p>math 中的 sqrt 不支持复数运算而 cmath 中支持</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> cmath</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>cmath.sqrt ( -<span class=\"number\">1</span> ) </span><br><span class=\"line\"><span class=\"number\">1j</span></span><br><span class=\"line\"><span class=\"comment\"># 没有使用from 。。。import 。。。是因为一旦使用了这个语句那么就无法使用普通的sqrt了</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>(<span class=\"number\">1</span>+<span class=\"number\">3j</span>) * (<span class=\"number\">9</span>+<span class=\"number\">4j</span>) </span><br><span class=\"line\">(-<span class=\"number\">3</span>+<span class=\"number\">31j</span>) </span><br></pre></td></tr></table></figure>\n<p>字符串是值，就像数字一样，单引号和双引号没有本质区别<br>\n \\ 与 C 语言中一样使用<br>\n字符串之间可以拼接</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;hello,&quot;</span> + <span class=\"string\">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>\n<p>转换成字符串有两种方式<br>\n str 将对象转换成用户看的，repr 转换成 python 表达式</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span> ( <span class=\"built_in\">repr</span> ( <span class=\"string\">&quot;hello world&quot;</span> ) )</span><br><span class=\"line\"><span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> ( <span class=\"built_in\">str</span> ( <span class=\"string\">&quot;hello world &quot;</span> ) )</span><br><span class=\"line\">hello world </span><br></pre></td></tr></table></figure>\n<p>长字符串：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span> ( <span class=\"string\">&quot;&quot;&quot; This is a very long string</span></span><br><span class=\"line\"><span class=\"string\">It continues here </span></span><br><span class=\"line\"><span class=\"string\">And it&#x27;s not over yet</span></span><br><span class=\"line\"><span class=\"string\">Still here &quot;&quot;&quot;</span> )</span><br><span class=\"line\"><span class=\"comment\"># 换行符可以被转义</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> ( <span class=\"string\">&quot;&quot;&quot; hello \\ </span></span><br><span class=\"line\"><span class=\"string\">world &quot;&quot;&quot;</span> ) </span><br></pre></td></tr></table></figure>\n<p>原始字符串</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path = <span class=\"string\">&#x27;c:\\\\program\\\\fnord&#x27;</span></span><br><span class=\"line\">path = <span class=\"string\">r&#x27;c:\\ll&quot;</span></span><br><span class=\"line\"><span class=\"string\"># r紧贴&#x27;</span>且字符串末尾不是\\</span><br></pre></td></tr></table></figure>\n<h3 id=\"序列\"><a class=\"markdownIt-Anchor\" href=\"#序列\">#</a> 序列</h3>\n<p>列表和元组的区别在于列表可以修改而元组不可以</p>\n<p>通用的序列操作：索引，分片，加，乘<br>\n索引同数组，数组最后一个元素的位置标号为 - 1 如：greeting [-1]<br>\n print 的返回值是一个序列，所以我们可以如此调用</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fourth = <span class=\"built_in\">input</span> ( <span class=\"string\">&quot;Year: &quot;</span> )[<span class=\"number\">3</span>] </span><br></pre></td></tr></table></figure>\n<p>列表可以相加与相乘，例如</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">endings = [<span class=\"string\">&#x27;st&#x27;</span>,<span class=\"string\">&#x27;nd&#x27;</span>,<span class=\"string\">&#x27;rd&#x27;</span>]+<span class=\"number\">17</span> * [<span class=\"string\">&#x27;th&#x27;</span>,] \\ </span><br><span class=\"line\">+    [<span class=\"string\">&#x27;st&#x27;</span>,<span class=\"string\">&#x27;nd&#x27;</span>,<span class=\"string\">&#x27;rd&#x27;</span>]+ <span class=\"number\">7</span> * [<span class=\"string\">&#x27;th&#x27;</span>,]  \\</span><br><span class=\"line\">+ [<span class=\"string\">&#x27;st]</span></span><br><span class=\"line\"><span class=\"string\">[1,2,3] + [4,5,6]</span></span><br><span class=\"line\"><span class=\"string\">= [1,2,3,4,5,6]</span></span><br><span class=\"line\"><span class=\"string\"># 初始化一个长度为10 的列表</span></span><br><span class=\"line\"><span class=\"string\">sequence = [None] * 10 </span></span><br></pre></td></tr></table></figure>\n<p>分片<br>\n numbers [-3:-1]<br>\nnumbers[-3:]<br>\nnumbers[0::2]<br>\nnumbers[-1:0:-2]</p>\n<p>成员资格：in 函数</p>\n<p>长度：len<br>\n 最大值：max<br>\n 最小值：min</p>\n<h4 id=\"列表\"><a class=\"markdownIt-Anchor\" href=\"#列表\">#</a> 列表</h4>\n<p>list 函数 对立： ‘’.join (somelist)<br>\n 删除元素 del names [2]<br>\n 分片赋值：可以使用与原序列不等长的序列将分片替换（可以用来删除某一段）</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numbers[<span class=\"number\">1</span>:<span class=\"number\">1</span>] = [<span class=\"number\">2</span>, <span class=\"number\">3</span> ,<span class=\"number\">4</span> ]</span><br><span class=\"line\">numbers[<span class=\"number\">1</span>:<span class=\"number\">5</span>] = [] </span><br></pre></td></tr></table></figure>\n<p>.append( )<br>\n.count ( )<br>\n.extend ( ) 追加一个序列<br>\n.index ( ) 找出第一个匹配项索引位置<br>\n.insert (i , value) 插入<br>\n.pop ( ) 移除最后一个值并返回值<br>\n.remove ( ) 移除第一个匹配项<br>\n.reserve ( ) 反向存放<br>\n.sort ( ) 会该表原来的列表修改，也就是说修改副本不会影响原本，反之不然<br>\n<strong> sort 里面可以有参数如 cmp，key=len，reserve=True</strong><br>\nsorted ( ) 返回已排序的列表副本</p>\n<h4 id=\"元组\"><a class=\"markdownIt-Anchor\" href=\"#元组\">#</a> 元组</h4>\n<p>如果你用逗号分隔了一些值，那么你就自动创建了元组<br>\n tuple ( ) 类比于 list</p>\n<h3 id=\"字符串\"><a class=\"markdownIt-Anchor\" href=\"#字符串\">#</a> 字符串</h3>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">format</span> = <span class=\"string\">&quot;hello , %s , %s enough for ya!&quot;</span> </span><br><span class=\"line\">values = ( <span class=\"string\">&#x27;world&#x27;</span> , <span class=\"string\">&#x27;Hot&#x27;</span> ) </span><br><span class=\"line\"><span class=\"built_in\">print</span> ( <span class=\"built_in\">format</span> % values ) </span><br></pre></td></tr></table></figure>\n<p>模板字符串：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> string <span class=\"keyword\">import</span> Template</span><br><span class=\"line\">s = Template ( <span class=\"string\">&#x27;$x , glorious $x &#x27;</span> ) </span><br><span class=\"line\">s.substitute ( x = <span class=\"string\">&#x27;slum&#x27;</span> ) </span><br><span class=\"line\"></span><br><span class=\"line\">s = Template ( <span class=\"string\">&quot;It&#x27;s $&#123;x&#125;tatic&quot;</span> ) </span><br><span class=\"line\">s.substitute ( x = <span class=\"string\">&#x27;slum&#x27;</span> ) </span><br><span class=\"line\"></span><br><span class=\"line\">s = Template ( <span class=\"string\">&#x27;A $thing must never $action&#x27;</span> ) </span><br><span class=\"line\">d = &#123; &#125; </span><br><span class=\"line\">d[<span class=\"string\">&#x27;thing&#x27;</span>] = <span class=\"string\">&#x27;gentleman&#x27;</span> </span><br><span class=\"line\">d[<span class=\"string\">&#x27;action&#x27;</span>] = <span class=\"string\">&#x27;show his socks&#x27;</span> </span><br><span class=\"line\">s.substitute ( d ) </span><br></pre></td></tr></table></figure>\n<p>转换符包括（注意顺序）</p>\n<ol>\n<li>%</li>\n<li>转换标志 ，- : 左对齐，+ : 正负号，&quot;&quot; 正数前保留空格，0：位数不够用零来凑</li>\n<li>最小值宽（若为 * 则从元组读入）例如’%. * s’ % (5 , ‘dada’)</li>\n<li>. 后跟精确度</li>\n</ol>\n<p>字符串方法：<br>\n.find (“target” ,start ,end ) 查找字串 (start end 可忽略)<br>\nsth.join ( )<br>\n.lower ( ) 转换成小写<br>\n.title ()  //.capwords () 标题<br>\n.replace (A , B) 查找并替换<br>\n.split ( ) join 的逆运算<br>\n.strip () 去除两侧空格，可自己添加例如.strip ( ’ * !’)<br>\n.translate ( ) &amp;&amp; .maketrans python3 有所区别，运用时自己网上查</p>\n<h3 id=\"字典\"><a class=\"markdownIt-Anchor\" href=\"#字典\">#</a> 字典</h3>\n<p>创建： phonebook = {‘A’ : 1 , ‘B’ : 2 …}<br>\n dict (序列)<br>\nlen ( )<br>\nd[k]<br>\nd[k] = v<br>\ndel d[k]<br>\n k in d 检查 d 中是否有含有键为 k 的项<br>\n字典可以嵌套，类比于多维数组</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template = <span class=\"string\">&quot;%(title)s , %(ooo)d &quot;</span> </span><br><span class=\"line\">data = &#123; <span class=\"string\">&#x27;title&#x27;</span> : <span class=\"string\">&#x27;fff&#x27;</span> , <span class=\"string\">&#x27;ooo&#x27;</span> : <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span> ( template % data )  </span><br></pre></td></tr></table></figure>\n<p>.clear ( ) 原本操作<br>\n.copy ( ) 替换值不变原本，修改值会变<br>\n.deepcopy (copy 函数库中) 复制其包含的所有值<br>\n.fromkeys ([] , ‘default’ ) or dict.fromkeys ( [ ] , ‘default’ ) 给给定的键建立新的字典<br>\n.get (‘value’) 访问不存在的项返回 None<br>\n.has_key (‘value’) 查询是否有此键，py3 中被__contains__(key) 替代<br>\n.items () 把所有项以列表形式返回，且每一项返回 (键，值) 的形式<br>\n.iteritems ( ) 返回迭代器<br>\n.keys ( ) 返回键 ， 同上<br>\n.itereys ( ) 同上<br>\n.values ( ) 同上<br>\n.itervalues ( ) 同上<br>\n.pop (‘键’) 删除对应的键值对<br>\n.popitem ( ) 随机弹出项<br>\n.setdefault (键，‘default’)<br>\n.update (x) 有则不变，无则加之</p>\n<h3 id=\"条件-循环和其它语句\"><a class=\"markdownIt-Anchor\" href=\"#条件-循环和其它语句\">#</a> 条件、循环和其它语句</h3>\n<p>print: , 即空格，print 即换行（除非在最后加，)<br>\nimport somemodule<br>\nfrom sm import sf<br>\nfrom sm import sf as (可避免重名)</p>\n<p>解包时可在最后用 * rest 把剩下的值都存入 rest</p>\n<p>+=</p>\n<ul>\n<li>=</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ... : </span><br><span class=\"line\">    代码块</span><br><span class=\"line\">    代码块</span><br><span class=\"line\"><span class=\"keyword\">elif</span> ... : </span><br><span class=\"line\">    代码块</span><br><span class=\"line\">    代码块</span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">    代码块</span><br><span class=\"line\">    代码块</span><br></pre></td></tr></table></figure>\n<p>x is y x 和 y 是同一对象<br>\n x is not y …<br>\nx in y<br>\nx not in y<br>\n 可以使用 x&lt;y&lt;z</p>\n<p>断言：assert 判断条件<br>\n如果不满足直接程序崩溃</p>\n<p>while 判断 :<br>\n 代码块<br>\n代码块</p>\n<p>for i in sequence :<br>\n…<br>\n…</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>range ( 3 )<br>\n[ 0 , 1 , 2 , 3 ]</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>xrange ( 3 )<br>\n 同 range 只不过是一个一个给出的，更为高效</p>\n</blockquote>\n</blockquote>\n</blockquote>\n",
            "tags": [
                "学习笔记",
                "python"
            ]
        },
        {
            "id": "http://amentiraz.github.io/2021/12/28/%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "http://amentiraz.github.io/2021/12/28/%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "文件学习笔记",
            "date_published": "2021-12-28T01:46:28.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-MtvMxXMJ\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"1486106274\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<h3 id=\"文件是什么\"><a class=\"markdownIt-Anchor\" href=\"#文件是什么\">#</a> 文件是什么</h3>\n<p>文件是指一组相关数据的有序集合，这个数据集有一个名称叫做文件名。文件可以是自己编制的，也可以是系统已有的。事实上我们已经多次使用了文件，例如源程序文件，目标文件、可执行文件、库文件等。<br>\n为了将结果保存起来，就需要使用文件。将数据以文件的形式存放在光盘、磁盘等外存储器上，可以达到重复利用、永久保存数据的目的。文件可分为普通文件和设备文件两种。通常吧显示器定义为标准输出文件，一般情况下在屏幕上显示有关信息就是向标准输出文件输出。如前面经常使用的 printf、putchar 函数就是这类输出。键盘通常被指定标准的输入文件，从键盘上输入意味着以标准输入文件输入数据。scanf、getchar 函数就属于这类输入。</p>\n<h3 id=\"文件类型\"><a class=\"markdownIt-Anchor\" href=\"#文件类型\">#</a> 文件类型</h3>\n<p>文件可分为 ASCII 码文件和二进制文件两种。ASCII 文件也成为文本文件，这种文件在磁盘中存放时每个字符对应一个字节，用于存放对应的 ASCII 码。<br>\n例如数 6843 的存储形式为：<br>\nASCII 码：00110110 00111000 00110100 00110011<br>\n 十进制码：  6         8        4        3<br>\n 共占用四个字节。<br>\nASCII 码文件可在屏幕上按字符显示，例如源程序文件就是 ASCII 文件，用 DOS 命令 TYPE 可显示文件的内容。<br>\n二进制文件是按二进制编码的方式来存放文件的。例如，数 6843 的存储形式为：00011010 10111011<br>\n 只占两个字节。二进制文件也可以在屏幕中显示，但内容无法读懂。<br>\n输入输出字符流的开始和结束只由程序控制而不受物理符号（如回车符）的控制。因此也把这种文件称作流式文件。</p>\n<h3 id=\"文件指针\"><a class=\"markdownIt-Anchor\" href=\"#文件指针\">#</a> 文件指针</h3>\n<p>在 C 语言中用一个指针变量指向一个文件，这个指针被称为文件指针，通过文件指针可以对它所指的文件进行各种操作。存放文件的有关信息被保存在一个结构体变量中，它是由系统定义的，取名为 FILE。在编写源程序时不必关心 FILE 结构的细节。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE * 指针变量标识符</span><br></pre></td></tr></table></figure>\n<p>其中 FILE 必须为大写，该结构中含有文件名、文件状态和文件当前位置等信息。<br>\n注意：在操作系统中，文件被作为重要的系统资源来看待。因此，当程序需要访问文件时，程序员必须显式地打开某个文件，并在使用后关闭它。程序中所有对文件的操作都通过文件指针来实现。</p>\n<h3 id=\"文件打开操作\"><a class=\"markdownIt-Anchor\" href=\"#文件打开操作\">#</a> 文件打开操作</h3>\n<p>C 语言没有输入输出语句，对文件的读写都是用看库函数来实现的。<br>\n对文件进行操作时应遵循一下步骤：</p>\n<ol>\n<li>打开文件。打开文件是指请求系统为指定文件分配内存缓冲区，建立文件的各种有关信息，文件使用前必须先打开。</li>\n<li>读写文件。包括文件的读、写、定位等操作。</li>\n<li>关闭文件。确保数据完整写入文件并释放内存缓冲区。</li>\n</ol>\n<p>打开文件，实际上是建立文件的各种有关信息，并使文件指针指向该文件。关闭文件则是断开指针与文件之间的联系，也就是禁止再对该文件操作。<br>\nfopen 函数用来打开一个文件，其调用的一般形式为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件指针名 = <span class=\"built_in\">fopen</span> ( 文件名 , 使用文件方式 ) ; </span><br></pre></td></tr></table></figure>\n<p>文件指针名必须是被说明为 FILE 类型的指针变量；文件名使被打开文件的文件名，可以是字符串常量或字符串数组；使用文件方式是指文件类型和操作要求。<br>\n例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE * fp ; </span><br><span class=\"line\">fp = ( <span class=\"string\">&quot;file a&quot;</span> , <span class=\"string\">&quot;r&quot;</span> ) ; </span><br></pre></td></tr></table></figure>\n<p>其意义使在当前目录下打开文件 file a，只允许进行读入操作，并使 fp 指向该文件。<br>\n又如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE * fp ; </span><br><span class=\"line\">fp = ( <span class=\"string\">&quot;c:\\\\test&quot;</span> , <span class=\"string\">&quot;rb&quot;</span> ) ; </span><br></pre></td></tr></table></figure>\n<p>其意义是打开 C 驱动磁盘的根目录下的文件 test，这是一个二进制文件，只允许按二进制的方式进行读操作。两个反斜杠 &quot;\\&quot; 第一个表示转义字符，第二个表示根目录。<br>\n或者使用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">FILE * <span class=\"title\">fopen</span> <span class=\"params\">( <span class=\"type\">const</span> <span class=\"type\">char</span> * filename , <span class=\"type\">const</span> <span class=\"type\">char</span> * mode )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>返回失败时返回空指针 NULL<br>\n 使用文件的方式共有 12 种，下表给出其符号以及意义。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">文件使用方式</th>\n<th style=\"text-align:center\">意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">r</td>\n<td style=\"text-align:center\">打开文件，只读</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w</td>\n<td style=\"text-align:center\">打开或建立文件只写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">追加打开一个文本文件，并在文件末尾写数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">rb</td>\n<td style=\"text-align:center\">二进制文件，同上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wb</td>\n<td style=\"text-align:center\">二进制文件，同上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ab</td>\n<td style=\"text-align:center\">二进制文件，同上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">r+</td>\n<td style=\"text-align:center\">读 + 写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w+</td>\n<td style=\"text-align:center\">读 + 写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a+</td>\n<td style=\"text-align:center\">读 + 写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">rb+&amp;wb+&amp;ab+</td>\n<td style=\"text-align:center\">类推</td>\n</tr>\n</tbody>\n</table>\n<p>总结如下：r (ead) , w (rite) , a (ppend) , t (ext) , b (inary) 。+：读和写<br>\n查看是否成功读入</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( ( fp = <span class=\"built_in\">fopen</span> ( <span class=\"string\">&quot;text&quot;</span> , <span class=\"string\">&quot;rb&quot;</span> ) ) == <span class=\"literal\">NULL</span>  ) &#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;error&quot;</span> ; </span><br><span class=\"line\">    <span class=\"built_in\">getch</span> ( ) ; <span class=\"built_in\">exit</span> ( <span class=\"number\">1</span> ) ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件关闭操作\"><a class=\"markdownIt-Anchor\" href=\"#文件关闭操作\">#</a> 文件关闭操作</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE * fp ; </span><br><span class=\"line\">fp = <span class=\"built_in\">fopen</span> ( <span class=\"string\">&quot;a.out&quot;</span> , <span class=\"string\">&quot;r&quot;</span> ) ; </span><br><span class=\"line\"><span class=\"built_in\">fclose</span> ( fp ) ; </span><br></pre></td></tr></table></figure>\n<p>关闭成功返回值为 0，否则为非零值<br>\n如果打开了多个文件且需要统一关闭：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fcloseall</span> <span class=\"params\">( )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>此函数关闭除了标准流意外的所有打开流，刷新所有的流缓冲区，并关闭返回的参数，否则返回 EOF。<br>\n标准流：stdin，stdout，stderr</p>\n<h3 id=\"文件结束检测\"><a class=\"markdownIt-Anchor\" href=\"#文件结束检测\">#</a> 文件结束检测</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">feof</span> <span class=\"params\">( FLIE * fp )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>文件未结束返回 0，已结束返回真。</p>\n<h3 id=\"文件错误检测函数\"><a class=\"markdownIt-Anchor\" href=\"#文件错误检测函数\">#</a> 文件错误检测函数</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ferror</span> <span class=\"params\">( FILE * fp )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>发生错误返回非零，否则返回 0</p>\n<h3 id=\"定位文件位置指针函数\"><a class=\"markdownIt-Anchor\" href=\"#定位文件位置指针函数\">#</a> 定位文件位置指针函数</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">fseek</span> ( FILE * fp , <span class=\"type\">long</span> offset , <span class=\"type\">int</span> startpos ) ; </span><br></pre></td></tr></table></figure>\n<p>offset 表示目标位置相对起始点的偏移量，要求偏移量为 long 型数据以便在文件长度大于 64KB 时不会出错，当用常量表示位移量时，要求加后缀 L.<br>\nstartpos 表示从何处计算偏移量：SEEK_SET:0 , SEEK_CUR:1 , SEEK_END:2 ;<br>\nfseek 函数一般用于二进制文件，在文本文件中由于要进行转换，故往往会出现错误。</p>\n<h3 id=\"重置文件位置指针函数\"><a class=\"markdownIt-Anchor\" href=\"#重置文件位置指针函数\">#</a> 重置文件位置指针函数</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">rewind</span> ( FILE * fp ) ; </span><br></pre></td></tr></table></figure>\n<p>移动到文件开始的位置。<br>\n无返回值</p>\n<h3 id=\"移动指针到当前位置函数\"><a class=\"markdownIt-Anchor\" href=\"#移动指针到当前位置函数\">#</a> 移动指针到当前位置函数</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"title\">ftell</span> <span class=\"params\">( FILE * p )</span> </span>;</span><br></pre></td></tr></table></figure>\n<p>若函数调用成功则函数的返回值时当前读写位置偏离文件头部的字节数，否则返回 - 1 ；<br>\n文件的长度</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ftell</span> ( fp , <span class=\"number\">0L</span> , SEEK_END ) ;</span><br><span class=\"line\">len = <span class=\"built_in\">ftell</span> ( fp ) ; </span><br></pre></td></tr></table></figure>\n<h3 id=\"面向字符的文件读写操作\"><a class=\"markdownIt-Anchor\" href=\"#面向字符的文件读写操作\">#</a> 面向字符的文件读写操作</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">fputc</span> ( <span class=\"type\">int</span> c , FILE * stream ) ; </span><br></pre></td></tr></table></figure>\n<p>c 是带写入的字符，可以是字符常量或者变量。<br>\n每写入一个字符，文件内部位置指针将向后移动一个字节。返回值为字符或者 EOF。<br>\n如果用写或者读写方式打开一个已存在的文件时将清除原有的文件内容，写入字符从文件首开始，如需保留原有文件内容，必须以追加的方式打开文件。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch = <span class=\"built_in\">fgetc</span> ( FILE * stream ) ; </span><br></pre></td></tr></table></figure>\n<p>读取的文件必须是以读写或读的方式打开的。</p>\n<h3 id=\"面向字符串的文件读写操作\"><a class=\"markdownIt-Anchor\" href=\"#面向字符串的文件读写操作\">#</a> 面向字符串的文件读写操作</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">char</span> * <span class=\"title\">fgets</span> <span class=\"params\">( <span class=\"type\">char</span> * string , <span class=\"type\">int</span> n , FILE * stream )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>函数的功能是从 stream 指向的文件中逐一读取 n-1 个字符，并将读取的字符保存到 string 指向的连续存储空间。<br>\n在读取 n-1 个字符之前如果遇到了换行符或 EOF，则读取结束。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fputs</span> <span class=\"params\">( <span class=\"type\">const</span> <span class=\"type\">char</span> * string , FILE * stream )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>执行成功返回非负整数，否则返回 EOF。不会把 \\0 写入文件。</p>\n<h3 id=\"面向格式化输入输出的文件读写操作\"><a class=\"markdownIt-Anchor\" href=\"#面向格式化输入输出的文件读写操作\">#</a> 面向格式化输入输出的文件读写操作</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fscanf</span> <span class=\"params\">( FILE * stream , <span class=\"type\">const</span> <span class=\"type\">char</span> * format[,argument]...)</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>返回值为读取正确的数据个数， EOF 为读取错误或文件结束。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fprintf</span> <span class=\"params\">( FILE * stream , <span class=\"type\">const</span> <span class=\"type\">char</span> * format[,argument]... )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>返回值为正确写入返回数据的个数，负值为读写错误。</p>\n<h3 id=\"面向信息块的文件读写操作\"><a class=\"markdownIt-Anchor\" href=\"#面向信息块的文件读写操作\">#</a> 面向信息块的文件读写操作</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">fread</span> ( <span class=\"type\">void</span> * buffer , <span class=\"type\">int</span> size , <span class=\"type\">int</span> count , FILE * fp ) ; </span><br><span class=\"line\"><span class=\"built_in\">fwrite</span> ( <span class=\"type\">void</span> * buffer , <span class=\"type\">int</span> size , <span class=\"type\">int</span> count , FILE * fp ) ; </span><br></pre></td></tr></table></figure>\n<p>例如：fread (fa , 4 , 5 , fp) ; 的意义是从 fp 所指的文件中，每次读 4 个字节，送入实数数组 fa 中，连续读 5 次。</p>\n",
            "tags": [
                "学习笔记",
                "C语言"
            ]
        },
        {
            "id": "http://amentiraz.github.io/2021/09/19/c%E5%A4%8D%E4%B9%A0/",
            "url": "http://amentiraz.github.io/2021/09/19/c%E5%A4%8D%E4%B9%A0/",
            "title": "c复习",
            "date_published": "2021-09-19T06:32:11.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-XGhDTRyH\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"578090\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>这篇文章是大一刚开学对 c 的复习，十分的不全面，看看就行。</p>\n<span id=\"more\"></span>\n<p>程序设计语言<br>\n机器语言 汇编语言 高级语言<br>\n return 0 ; return 表示 main 函数结束，0 表示程序在退出时给执行此程序的操作系统返回来一个结果，即返回值。</p>\n<h3 id=\"c程序的构成\"><a class=\"markdownIt-Anchor\" href=\"#c程序的构成\">#</a> c 程序的构成</h3>\n<h4 id=\"预处理部分\"><a class=\"markdownIt-Anchor\" href=\"#预处理部分\">#</a> 预处理部分</h4>\n<ol>\n<li>宏定义：#define 指令定义一个宏，#undef 指令删除一个宏定义</li>\n<li>头文件包含：#include</li>\n<li>条件编译语句：#if、#ifdef、#ifndef、#else 和 #endif 指令根据预处理器可以测试的条件来确定是将一段文本块包含到程序还是将其排除在外</li>\n</ol>\n<h4 id=\"说明部分\"><a class=\"markdownIt-Anchor\" href=\"#说明部分\">#</a> 说明部分</h4>\n<ol>\n<li>全局变量</li>\n<li>常量：#define PI 3.1416926f \\ const float PI 3.1415926</li>\n<li>函数声明</li>\n</ol>\n<h4 id=\"执行部分\"><a class=\"markdownIt-Anchor\" href=\"#执行部分\">#</a> 执行部分</h4>\n<ol>\n<li>主函数</li>\n<li>其他函数</li>\n</ol>\n<h3 id=\"标识符\"><a class=\"markdownIt-Anchor\" href=\"#标识符\">#</a> 标识符</h3>\n<p>由数字、字母和下划线字符构成的一个连续序列，不能有空白字符。<br>\n区分大小写</p>\n<h3 id=\"整型数据的分类\"><a class=\"markdownIt-Anchor\" href=\"#整型数据的分类\">#</a> 整型数据的分类</h3>\n<p>基本整型（int）、短整型（short int）和长整型（long int）<br>\nint 的取值范围 - 2147483648 与 2147483647（2^31-1)、字节数 4<br>\nshort (int) 的取值范围 -32768 与 32767 之间、字节数 2<br>\nlong (int) 主流编译器一般规定其取值范围与基本 int 类型相同、字节数 4<br>\nC 语言还提供了有符号和无符号整数类型<br>\n若希望表达非负整数，可以定义无符号整型，即在类型符号前面加上修饰符 unsigned<br>\n 加上 unsigned 变成原来的两倍、字节数不变<br>\n如：unsigned int : 0 ~ 4294967295</p>\n<h3 id=\"整型常数的书写形式\"><a class=\"markdownIt-Anchor\" href=\"#整型常数的书写形式\">#</a> 整型常数的书写形式</h3>\n<ol>\n<li>十进制形式</li>\n<li>八进制形式： 以 0 开头，如 0100、0123、0123456</li>\n<li>十六进制形式：以 0x 开头，如 0x100、0x123</li>\n<li>整型数据的储存形式：在计算机内部通常采用补码形式储存</li>\n</ol>\n<h3 id=\"补码-后面再补充相应知识\"><a class=\"markdownIt-Anchor\" href=\"#补码-后面再补充相应知识\">#</a> 补码 （ 后面再补充相应知识 ）</h3>\n<h3 id=\"浮点数类型\"><a class=\"markdownIt-Anchor\" href=\"#浮点数类型\">#</a> 浮点数类型</h3>\n<p>C 语言把浮点数类型分为 float（单精度浮点型）、double（双精度浮点型）和 long double （长双精度浮点型）<br>\n如表所示</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>字节数</th>\n<th>有效位数</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foat</td>\n<td>4</td>\n<td>6</td>\n<td>-3.4 * 10^38 ~ 3.4 * 10^38</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8</td>\n<td>15</td>\n<td>-1.7 * 10^308 ~ 3.4 * 10^308</td>\n</tr>\n<tr>\n<td>long double</td>\n<td>16</td>\n<td>19</td>\n<td>-1.2 * 10^4932 ~ 3.4 * 10^4932</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"浮点数的书写形式\"><a class=\"markdownIt-Anchor\" href=\"#浮点数的书写形式\">#</a> 浮点数的书写形式</h3>\n<ol>\n<li>当小数点前后的数是零时，可以省略 0，但是小数点不能省略如 5. 和.5 分别表示 5.0 和 0.5</li>\n<li>指数形式 ： 如 4.5678E2 代表 4.5678 * 10^2 \\ -5.7e-3 代表 - 5.7 * 10^-3 （E 和 e 本质是一样的）</li>\n</ol>\n<p>默认情况下，浮点型常数为 double 型。可以在浮点型常数后面加上 F (f) 以表示 float 型；也可以在浮点型常数后面加上 L (l）表示 long double 型</p>\n<h3 id=\"字符类型\"><a class=\"markdownIt-Anchor\" href=\"#字符类型\">#</a> 字符类型</h3>\n<p>ASCII 字符集的特征：0～9、26 个大写英文字母以及 26 哥消协的英文字母的编码各自是连续的<br>\n如：A 的编码加上 25 是 Z 的编码</p>\n<p>char 类型来描述单字节编码字符集中的字符类型数据<br>\n C 还提供了 [signed] char 和 unsigned char 类型，他们的区别在于：在参加算术运算时，把字符的编码当作有符号整数还是无符号整数来看待</p>\n<h4 id=\"字符型常量的三种书写方式\"><a class=\"markdownIt-Anchor\" href=\"#字符型常量的三种书写方式\">#</a> 字符型常量的三种书写方式：</h4>\n<ol>\n<li>以一对单引号括起来的一个字符：‘A’‘1’</li>\n<li>以字符对应的 ASCII 码来表示，这时必须用转义序列（以反斜杠开头的一串字符）</li>\n</ol>\n<ul>\n<li>八进制：’\\ddd’如’101’为字母 A 的 ASCII 码的八进制表示</li>\n<li>十六进制：’\\xhh’如’\\x41’为字母 A 的 ASCII 码的十六进制表示</li>\n</ul>\n<ol start=\"3\">\n<li>特殊的转移序列符号表示</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\a</td>\n<td>响铃</td>\n<td>\\v</td>\n<td>纵向制表</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>退格</td>\n<td>’</td>\n<td>单引号</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>换页</td>\n<td>‘’</td>\n<td>双引号</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>换行</td>\n<td>\\ | 反斜杠</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车</td>\n<td>\\0</td>\n<td>字符串结束</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td colspan=\"2\">横向制表</td>\n</tr>\n</tbody>\n</table>\n<p>“Please enter “Y” or “N”:<br>\n 当字符串包含双引号 &quot; 时，双引号应写成：”<br>\n 字符常量表示单个字符，字符串常量可表示多个字符<br>\n字符常量用’' 表示，字符串常量用 &quot;&quot; 表示<br>\n在储存字符串时，通常在最后一个字符后面储存一个表示字符串结束的标记符号</p>\n<p>两个实数相除的结果是双精度实数，两个整数相除的结果是整数</p>\n<h3 id=\"常用运算符的优先级与结合性\"><a class=\"markdownIt-Anchor\" href=\"#常用运算符的优先级与结合性\">#</a> 常用运算符的优先级与结合性</h3>\n<p>自行百度</p>\n<h3 id=\"输入输出语句\"><a class=\"markdownIt-Anchor\" href=\"#输入输出语句\">#</a> 输入输出语句</h3>\n<p>printf ( ) ; scanf ( ) ; getchar ( ) ; putchar ( ) ; puts ( ) ; gets ( ) ;</p>\n<h3 id=\"头文件\"><a class=\"markdownIt-Anchor\" href=\"#头文件\">#</a> 头文件</h3>\n<p>/#include&lt; &gt; 表示直接去查找系统的源文件<br>\n /#include&quot; &quot; 表示先去找用户存放源文件的子目录再去找系统文件<br>\n如果是自己写的头文件必须用第二种<br>\n如果头文件不在当前目录中，可以在双引号中写出文件路径 (#include “C:\\temp\\file.h”</p>\n<h3 id=\"scanf-与-printf\"><a class=\"markdownIt-Anchor\" href=\"#scanf-与-printf\">#</a> scanf 与 printf</h3>\n<p>特别的，scanf (“%2d%2d” , &amp; a , &amp; b ) ; 输入的数据可以为 1234<br>\n 则 a = 12 , b = 34 ；<br>\n如果 scanf (“a=% d,b=% d\\n” , &amp; a , &amp; b ) ;<br>\n 则用户必须输入 a=12,b=34 ;<br>\n 如果是 scanf (“% d * % d” , &amp; a , &amp; b ) ;<br>\n 那么用户输入 12，34｜12#34 都会得到正确的结果，因为 * 为忽略输入修饰符<br>\n scanf 输入时如果是 % c 那么空格也会被读入</p>\n<h3 id=\"空语句\"><a class=\"markdownIt-Anchor\" href=\"#空语句\">#</a> 空语句</h3>\n<p>空语句不做任何事情其作用是用于语法上需要一条语句的地方，而该地方又不需要做任何事情；例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    goto end ; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    end : ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 1 , sum = 0 ; </span><br><span class=\"line\">for ( ; i &lt;= 100 ; sum += i , i ++ ) ; </span><br></pre></td></tr></table></figure>\n<h3 id=\"switch-语句\"><a class=\"markdownIt-Anchor\" href=\"#switch-语句\">#</a> switch 语句</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch( &lt;整式表达式&gt; ) &#123; </span><br><span class=\"line\">    case 常量1: 语句序列1 ; break ; </span><br><span class=\"line\">    case 常量2: 语句序列2 ; break ;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    default ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>常量可为 1、2、3；‘c’、‘a’…</p>\n<p>case 常量 1: 语句序列 1 ; break ;</p>\n",
            "tags": [
                "学习笔记",
                "C语言",
                "复习资料"
            ]
        }
    ]
}