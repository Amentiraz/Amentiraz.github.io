{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amentiraz • All posts by \"dp\" tag",
    "description": "",
    "home_page_url": "http://Amentiraz.github.io",
    "items": [
        {
            "id": "http://amentiraz.github.io/2021/12/02/DP/",
            "url": "http://amentiraz.github.io/2021/12/02/DP/",
            "title": "DP",
            "date_published": "2021-12-02T09:26:14.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-spFbFTgV\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"464413083\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>学了三天 DP 连个 P 都不会，总的来说就是寄了，每道题不看题解就做不来，试着做了做三道提高组难度的题，做出来了俩，另外一个没有思路。这俩题我都想出了大部分思路，但最后几步由于经验问题没想出来。做完后我以为我懂了，然后膨胀了，去挑战<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDExMDg=\">低价购买</span>这道题。然后不出意外寄了。打算先不弄这个了，等以后在弄，先把之前写的贴上来吧。</p>\n<span id=\"more\"></span>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ4MzI=\">珈百璃的堕落</span><br>\n这番是好看的，题是不会的。<br>\n这道题有三个麻烦的点，一个是范围的确定，一个是 dp 数组的含义确定，还有一个是压缩数组的大小。<br>\n通过这道题我掌握了基本的 DP 递推的根据和要领，意思就是我能证明 dp 递推的正确性了，但然而并没有什么卵用，不会的还是不会。<br>\n我在高中时就做出来了这道题，但我认为在我高中的时候是不可能想出这道题的思路的，可以说我高中学竞赛就是在自欺欺人了（笑）。但讲道理的是，我起步太慢了，那个时候我也不是什么天才，依葫芦画瓢才是我应该干的，不管怎样我现在是不能这么干了。<br>\n一个很重要的点是，我们要继承上一个状态，又不能破坏现在的状态，所以起码要二维的数组，我们要尽力压缩空间，注意到第一维只会用到上一个的状态，所以我们调整一下。<br>\n代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;queue&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std ; </span><br><span class=\"line\"></span><br><span class=\"line\">int tots , totc , dp[2][2000006] ; </span><br><span class=\"line\">int T = 1000000 ; </span><br><span class=\"line\">char a[2000006] ; </span><br><span class=\"line\"></span><br><span class=\"line\">int main ( ) &#123;</span><br><span class=\"line\">    int n ; scanf ( &quot;%d&quot; , &amp; n ) ;</span><br><span class=\"line\">    int l = 0 , r = 0 ; </span><br><span class=\"line\">    for ( int i = 0 ; i &lt;= 2000006 ; i ++ ) dp[0][i] = dp[1][i] = -100000006 ; </span><br><span class=\"line\">    dp[0][T] = 0 ; </span><br><span class=\"line\">    for ( int i = 1 ; i &lt;= n ; i ++ ) &#123;</span><br><span class=\"line\">        scanf ( &quot;%s&quot; , a ) ; </span><br><span class=\"line\">        int len = strlen ( a ) , tots = 0 , totc = 0 ; </span><br><span class=\"line\">        for ( int j = 0 ; j &lt; len ; j += 2 ) </span><br><span class=\"line\">            a[j] == &#x27;s&#x27; ? tots ++ : totc ++ ; </span><br><span class=\"line\">        int v = totc , w = tots - totc ;</span><br><span class=\"line\">        l = min ( l + w , l ) ; r = max ( r + w , r ) ; </span><br><span class=\"line\">        for ( int j = l ; j &lt;= r ; j ++ ) &#123;</span><br><span class=\"line\">            dp[i&amp;1][T+j] = max ( dp[i&amp;1^1][T+j] , dp[i&amp;1][T+j] ) ; </span><br><span class=\"line\">            dp[i&amp;1][T+j] = max ( dp[i&amp;1^1][T+j-w] + v , dp[i&amp;1][T+j] ) ; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; dp[n&amp;1][T] ; </span><br><span class=\"line\">    return 0 ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDExNTY=\">垃圾陷阱</span><br>\n其实高度和维持生命的时间可以换一下，就是时间做数组，生命做值，但太麻烦了，就没写。<br>\n要时刻记住当前状态由上一个状态推导而来，别自己吓自己。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std ; </span><br><span class=\"line\"></span><br><span class=\"line\">struct L &#123;</span><br><span class=\"line\">    int t , f , h ; </span><br><span class=\"line\">&#125; trash[1005] ; </span><br><span class=\"line\">int dp[105][105] ; </span><br><span class=\"line\">bool cmp ( L x , L y ) &#123; return x.t &lt; y.t ; &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">int main ( ) &#123;</span><br><span class=\"line\">    int D , G ; scanf ( &quot;%d%d&quot; , &amp; D , &amp; G ) ; </span><br><span class=\"line\">    for ( int i = 1 ; i &lt;= G ; i ++ ) scanf ( &quot;%d%d%d&quot; , &amp; trash[i].t , &amp; trash[i].f , &amp; trash[i].h ) ; </span><br><span class=\"line\">    sort ( trash + 1 , trash + 1 + G , cmp ) ;</span><br><span class=\"line\">    dp[0][0] = 10 ; </span><br><span class=\"line\">    for ( int i = 1 ; i &lt;= G ; i ++ ) &#123;</span><br><span class=\"line\">        for ( int j = 0 ; j &lt;= D ; j ++ ) &#123;</span><br><span class=\"line\">            if ( j &gt;= trash[i].h &amp;&amp; dp[i-1][j-trash[i].h] &gt;= trash[i].t ) &#123;</span><br><span class=\"line\">                dp[i][j] = max ( dp[i-1][j-trash[i].h] ,dp[i][j] ) ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if ( dp[i-1][j] &gt;= trash[i].t ) &#123;</span><br><span class=\"line\">                dp[i][j] = max ( dp[i-1][j] + trash[i].f , dp[i][j] ) ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for ( int i = 1 ; i &lt;= G ; i ++ ) &#123;</span><br><span class=\"line\">        if ( dp[i][D] != 0 ) &#123;</span><br><span class=\"line\">            cout &lt;&lt; trash[i].t ; return 0 ; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int now = 10 ; </span><br><span class=\"line\">    for ( int i = 1 ; i &lt;= G; i ++ ) &#123;</span><br><span class=\"line\">        if ( now &lt; trash[i].t - trash[i-1].t ) &#123; cout &lt;&lt; trash[i-1].t + now ; return 0 ; &#125;  </span><br><span class=\"line\">        else now = now - trash[i].t + trash[i-1].t + trash[i].f ; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; trash[G].t + now ; </span><br><span class=\"line\">    return 0 ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "DP",
                "算法"
            ]
        }
    ]
}