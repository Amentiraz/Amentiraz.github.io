{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amentiraz • All posts by \"dijkstra\" tag",
    "description": "",
    "home_page_url": "http://Amentiraz.github.io",
    "items": [
        {
            "id": "http://amentiraz.github.io/2021/11/27/Dijkstra/",
            "url": "http://amentiraz.github.io/2021/11/27/Dijkstra/",
            "title": "Dijkstra",
            "date_published": "2021-11-27T07:44:01.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-BpvTOYAt\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"1345488418\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>Dijkstra 算法用于解决单源最短路问题，假设起始点为 S，在最开始我们可以知道 S 到某些点的距离，从中取出最小的一个，我们可以保证在我们取出这个最小值的时候不可能有任何路径可以更短的到达此点，，此过程使用了贪心的思想。每当我们找出一个这样的点就更新 S 到与此点相连的其它点的距离，我们每一次取点都保证取出的是最短的且未被访问的点，这就是 Dijkstra 算法。</p>\n<span id=\"more\"></span>\n<p>网上对于 Dijkstra 的优缺点有很好的描述我就直接引用了：</p>\n<blockquote>\n<p>优点：O (N*N), 加堆优化：O (N*logN)<br>\n 缺点：在单源最短路径问题的某些实例中，可能存在权为负的边。<br>\n如果图 G＝（V，E）不包含从源 s 可达的负权回路，<br>\n则对所有 v∈V，最短路径的权定义 d (s,v) 依然正确，<br>\n即使它是一个负值也是如此。但如果存在一从 s 可达的负回路，<br>\n最短路径的权的定义就不能成立。S 到该回路上的结点就不存在最短路径。<br>\n当有向图中出现负权时，则 Dijkstra 算法失效。当不存在源 s 可达的负回路时，<br>\n我们可用 Bellman-Ford 算法实现。<br>\n————————————————<br>\n 版权声明：本文为 CSDN 博主「Chandery」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>\n原文链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkeTEyMDY0NzM2MDEvYXJ0aWNsZS9kZXRhaWxzLzUyNjQ4NjE5\">https://blog.csdn.net/cdy1206473601/article/details/52648619</span></p>\n</blockquote>\n<p>下面贴上我年轻时写的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;queue&gt;</span><br><span class=\"line\">#include&lt;vector&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std ; </span><br><span class=\"line\"></span><br><span class=\"line\">const int maxn = 5000000 ;</span><br><span class=\"line\">int head[maxn] , nex[maxn] , to[maxn] , val[maxn] , cnt = 0 ; </span><br><span class=\"line\">int vis[maxn] , dis[maxn] ; </span><br><span class=\"line\">struct L &#123;</span><br><span class=\"line\">    int val , id ; </span><br><span class=\"line\">    bool operator &lt; ( const L &amp; x ) const &#123;</span><br><span class=\"line\">        return val &gt; x.val ; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; ; </span><br><span class=\"line\"></span><br><span class=\"line\">void add ( int x , int y , int z ) &#123; nex[++cnt] = head[x] ; head[x] = cnt ; to[cnt] = y ; val[cnt] = z ; &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">void dijkstra ( int s ) &#123; </span><br><span class=\"line\">    priority_queue &lt; L &gt; Q ; Q.push ( ( L ) &#123; 0 , s &#125; ) ; dis[s] = 0 ; </span><br><span class=\"line\">    while ( ! Q.empty ( ) ) &#123;</span><br><span class=\"line\">        L u = Q.top ( ) ; int x = u.id ; Q.pop ( ) ; </span><br><span class=\"line\">        if ( vis[x] ) continue ; vis[x] = 1 ; </span><br><span class=\"line\">        for ( int i = head[x] ; i ; i = nex[i] ) &#123; </span><br><span class=\"line\">            if ( dis[to[i]] &gt; dis[x] + val[i] ) &#123;</span><br><span class=\"line\">                dis[to[i]] = dis[x] + val[i] ; </span><br><span class=\"line\">                if ( ! vis[to[i]] ) Q.push ( ( L ) &#123; dis[to[i]] , to[i] &#125; ) ; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main ( ) &#123;</span><br><span class=\"line\">    int n , m , s ; scanf ( &quot;%d%d%d&quot; , &amp; n , &amp; m , &amp; s ) ; </span><br><span class=\"line\">    for ( int i = 1 ; i &lt;= m ; i ++ ) &#123;</span><br><span class=\"line\">        int x , y , z ; scanf ( &quot;%d%d%d&quot; , &amp; x , &amp; y , &amp; z ) ; </span><br><span class=\"line\">        add ( x , y , z ) ; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for ( int i = 1 ; i &lt;= n ; i ++ ) dis[i] = 0x7fffffff ; </span><br><span class=\"line\">    dijkstra ( s ) ; </span><br><span class=\"line\">    for ( int i = 1 ; i &lt;= n ; i ++ ) printf ( &quot;%d &quot; , dis[i] ) ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法",
                "Dijkstra"
            ]
        }
    ]
}