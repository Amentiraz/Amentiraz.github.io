{
    "version": "https://jsonfeed.org/version/1",
    "title": null,
    "subtitle": "",
    "icon": "http://amentiraz.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "http://Amentiraz.github.io",
    "items": [
        {
            "id": "http://amentiraz.github.io/%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E5%9B%9E%E5%BF%86%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E5%9B%9E%E5%BF%86%E4%BB%80%E4%B9%88/",
            "url": "http://amentiraz.github.io/%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E5%9B%9E%E5%BF%86%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E5%9B%9E%E5%BF%86%E4%BB%80%E4%B9%88/",
            "title": "当我们在回忆大学生活，我们在回忆什么",
            "date_published": "2025-07-17T02:53:18.000Z",
            "content_html": "<p>四年的时光转瞬即逝。在大二时我还在想大学时光漫长，每天枯燥的做核酸、上课，闲下来便躺在床上玩着手机，晚上还悠闲的在校园里漫步，似乎时间也变得粘稠起来。然而从大三开始为自己的未来做打算后，时间便再也没有为我停留，学习、与他人社交，每一件事都是我急迫去做的。然而当面临大四下数着时间毕业的日子里，回望我的大学生活，大部分事却已经回忆不起来，寥寥的几句话就能概括大部分时间，反而是一些鸡毛蒜皮的小事却格外清晰。我在大学究竟获得了什么，这个问题不由得让我沉默。</p>\n<p>其实仔细想想，我大学在纸面上还是做了许多事的，拿过两个 ACM 校内二等奖，美国数学建模竞赛特等奖，全国数学建模竞赛二等奖，学习成绩不好不坏，但最后也是靠着这些奖项保研了。然而当我去回忆这些竞赛时我回忆的是什么呢？ACM 的校内二等奖其实并没有怎么努力便获得了，全靠吃高中的老本，而且有意思的是大一的比赛我并没有参加，是因为我在预选的网络赛中虽然打到了前列的名次，然而我忘了去参加正式赛便遗憾落榜。而美赛我回忆起来的是由于比赛成绩发布是半夜，我的另外两个队友说他们要守夜等成绩，我早上醒来后发现他们半夜在欢呼拿到了很好的成绩，我倒是没什么感觉，但礼节上也装作激动惊讶的样子回复了几句便去上课了。而全国数学建模竞赛便不怎么如人意，由于队友也很敷衍加上自己当时由于其他的事心情不好便也草草交了。回想起来，对于我而言，似乎无论是奖项本身带来的成就还是去为了这些奖项去学习的过程都没有让我在回忆中留下深刻的回忆，反倒是一些出乎意料的状况格外印象深刻。</p>\n<p>大四上去试着面试了华为，那边的 HR 问我，你在打这些比赛之前的目标是怎样的，我一时语塞，但也如实回答了：我并没有什么目标，只是想去试试便去做了。面试官当时惊讶的看着我，似乎怀疑我有所隐瞒。是呀，有目标打比赛，获得荣誉然后去争取更好的前程才是正常人的思维吧，要不然有什么理由去打比赛呢，这不是毫无意义吗？</p>\n<p>想起来，我可能也是受到了高中经历的影响。在 CSP 比赛的前一周出门时，我的父母问我你这次比赛能拿到什么名次，我自信的说，上次我拿了省二，这次起码省一。然而最后由于发挥失常甚至连省三都没有。我现在还记得我在电子科技大学教学楼大厅内对着竞赛老师嚎啕大哭。到了现在，我已经记不起我做过的大部分题目了，而那次比赛我怎么都想不出来的” 格雷码 “这道题我仍旧记忆犹新。</p>\n<p>这么一看怎么记忆中的事情全是糟糕的东西组成的，这些奖项难道一点作用也没有吗？其实也是有的。当我获得美赛特等奖后虽然表面上没什么，但对我自身的心理产生了很正面的影响。在一个全球的竞赛中拿了很高的名次确实让我面对其他人更有自信了。仔细想想，整个年级也没几个的竞赛方面成果比我更厉害了。我和他人说活更有底气，我也因此更融入了 “社会” 而不是像大一一样用一种清高的不屑去看待人际交往。</p>\n<p>这样写起来我都感觉自己有点不要脸，有一点成就就想去炫耀，就想去获得他人的认可。但其实也并不完全是这样。获得奖项后才发现这些奖项如浮萍一般，这并不是去评判一个人的标准，这些奖项并不能代表我，反倒会使得别人误解我。这些奖项另一个积极的影响就是让我不再以成绩、社会地位等等诸如此类的东西去评判一个人。那么组成一个人的东西、或者说对于一个人来说他所真正拥有的东西是什么呢？在这些经历当中我们究竟获得的东西是什么？我认为我们获得的便是我们的心灵因此而受到改变的东西。这个东西能够以回忆的形式而得到重现。</p>\n<p>我的数学建模的队友都非常优秀，两个人都是名列前茅，均分 90 分往上，相比较而言我的主课成绩也就只有 85 左右。听他们聊起自己的生活似乎是被学习所填满的，需要忙很多事情，竞赛，大大小小的实验，平时上课也要一丝不苟，考试更是需要全力以赴。相比较而言，我虽然基本不翘课，但是也仅限于去听个响，最后考试也是提前一周突击应付完，甚至考试我保持着写完就提前交卷的习惯。我对自己学习专业课的目标是大致学懂就行，考试对我而言也只是走个形式。</p>\n<p>有人说，你心真大，不担心自己的未来吗。不是这样的，这其实是因为我完全不知道大学的升学流程。我直到大二下才清楚保研是需要平时成绩的，甚至找工作需要实习的流程我都是春招的时候才知道。但我如今无比庆幸自己没有去了解这些。</p>\n<p>我问我的队友，你现在天天都在忙，那你什么时候玩呢？他回答我说，等我年入百万就玩。我俩都沉默了一会儿，我说等你年入百万更没有时间玩了，他也不说话了。</p>\n<p>现在想来我也没有表达准确，我也没办法表达准确。“玩” 这个词并不准确，更准确的应该是，你何时为自己而活呢？有人会说，为自己的前途而奋斗这难道不是为自己而活吗。我之前也因为这个问题跟我的一个舍友进行过讨论。我认为人只有发自内心，不被其他外界条件约束，然而去生活才是为自己而活。那个舍友问我，难道为自己的家人父母获得更好的生活去奋斗这个也不算为自己而活吗。我当即没有反应过来便说，那也勉强算吧。但事后我也并不认为这是为自己而活，因为这种事在回忆中就像是那些大大小小的成就一样，即便达成后也只是单薄的一句话，要是为自己而活，一定是发自内心的去想要为他人付出，而不是受限于社会的责任的他人的戒律之下。</p>\n<p>那么我随心所欲的去放纵便是好的吗？这样能让我回忆起来更多的东西，增加我人生的厚度吗？很显然这也是不行的。我的一个舍友对我说：你的生活太单调了，每天准时起床，学习，吃饭，晚上又规律的睡觉，这样的生活多单调乏味啊，像我一样天天打游戏，虽然作息不规律，但是有意思的多。我说，这样下来难道不会很空虚吗？他说，这倒也是。</p>\n<p>实际上我在大二的时候放纵过一段时间，网课挂在旁边，自己躺在床上看网文，从早到晚，晚上实在撑不住了才放下手机睡觉，这样子我持续了两周左右。然而当我看完那本网文时，一种空虚和对现实所有事物感到无趣的情绪笼罩了我。说难听点就像吸了毒被送去戒毒所一样。我现在再也想不起那本网文讲了什么，但那股空虚感时刻警醒着我，我后来再也没有像那时一样没日没夜的去进行这种简单的娱乐了。</p>\n<p>现在想来，那种放纵虽然不是受到他人的约束，但确实是受到低级欲望的支配。并不是说这样不对，而是当我长时间去沉浸在这种非现实中会不自觉的受到非现实的世界观的影响，我的非现实的世界观定然会受到现实的冲击。我认识很多人上了大学便沉迷游戏和虚拟世界的社交之中，后来现实生活越来越糟。但你能断言他们的世界观是错误的吗。有人对我说：躺平才是面对这个世界正确的选择，这句话和人活着就是要不断地去追名逐利，又有什么区别呢？他们都不过是受限于一个框架下，去 “被迫” 过着 “自己” 的生活。然而据我观察，这样的生活往往会消融在框架之下，它们往往不会成为我们的一部分，我们所对它的阐述往往是 “调用” 了框架的 “接口”。实际上这样的生活真的组成了我们吗？我对此存疑。</p>\n<p>虚无主义是一个很流行的概念，说到底我们做的所有事都会受到一个问题的拷问：“有什么意义？”。以前父辈的人很少看到有人去思考这个问题，而我们这代人面对这个问题时往往会很取巧的说：一切本来就没有什么意义。或者会说：“本来没有意义，你认为有意义便有意义。” 以此为根据继续自己的生活。我对这个问题倒有一些不一样的看法，生活有价值的回忆往往是由无意义的事情组成的。无论你如何去为自己构建意义，这个意义真的能经受的住 “你所构建的意义有什么意义” 这个拷问吗？而那些无意义而去做的事情往往才是发自我们内心的。</p>\n<p>我很自豪的说，我上大学干过许多诸如此类无意义的事情：我几乎每天早上都去吃早饭，由此也认识了一位食堂的阿姨；我常常晚上出去散步，我知道绕学校一个小圈大概是半个小时，绕学校一个大圈是一个小时；我吃完晚饭会去弹弹吉他，从最开始大横按都不太行到现在开始试着弹 Marcin 的那些高难度的曲目，并且学了一些乐理可以开始即兴了；我大四的时候每周会抽一天时间去学学哲学，虽然还是一无所知但改变了我思考问题的方式；我去听了几场演奏会，看了几场爵士 jam，提升了我对音乐的理解；我思考了一年关于如何去面对我和一位女生的关系，最后决定把她约出来然后在第二天拉黑了她所有的联系方式；我开始写博客，用文字去记录自己的思考和生活。在无意义中我获得了意外的满足，我的生活从原来的 “似水流年” 变成了一个个的节点并组成了我。我不再为回忆的空虚而恐慌，我满足于我的回忆。</p>\n<p>大学生活中我最满意我的一点是我形成了我自己的价值观并且尽量知行合一。我热爱生活，并且基于自发的对他人的责任积极的去完成我的工作。然而自己的准则并不能保证我风雨无忧，我写过这样一句话：“当我下定决心去爱这个世界时，我才发现这个世界是一座地狱。”</p>\n<p>我和我的一个朋友曾有这样的争辩，我说，人人是平等的，他反驳我说，人人就不是平等的，有钱的人可以买到更多的东西，身处要职的人可以轻易的用权力去压迫其他人，生活中，老师是你需要尊敬的，领导是需要你恭维的，当然你也可以不恭维，那么代价又是什么呢？再极端一些，士兵在战场上如果不杀人，那结果就是被人杀。我们很难去决定自己的生活。</p>\n<p>事实上，他也是对的。我曾经对我的一个信仰伊斯兰教的舍友说，实际上我认为宗教挺好的，最起码由于大家都是上帝的子民，所以人人平等。现在上网你也能发现大部分人心底也根本不认同人人平等。人的贪欲被 “世界就是这样” 所合理化，人们更愿意认同那一张张纸作为金钱的真实也不愿意认同自己心中所迸发出的感情的真挚，处在这样的环境中你很难独善其身。似乎你只能随波逐流，要不然等待你的往往是他人的不理解和对自身的伤害。</p>\n<p>那我们能怎么办呢，是选择顺从这个世界，将自己变成他们的一份子吗？还是说带上面具，去假装迎合他人，但这且不提精神压力有多大，这个面具往往就是你的内心，你的内心不可能不受影响。还是说像堂吉诃德一般最终殉道于对理想主义的追求之中呢？我不知道该怎么做，我并没有足够的见识和能力去解决这个问题，但我猜如果把我逼急了可能会选择第二种吧。</p>\n<p>有点偏题了，但事实上我们并没有能力去选择我们的回忆。我们的回忆往往是突如其来的而非计划周全得来的。但即便它是突如其来的，我也应当去尽量选择它所来的方向。说到底，即使这个世界是一座地狱，那也并不影响我爱它。我决定了去受到它的影响，决定去成为它的一份子（或者说我本来就是它的一份子），我当然也能选择尽量不去受到它的影响。在这种决定与不决定当中，我能获得某种程度的自由，况且在被迫当中往往能明确自己的内心，属于自己的回忆往往能在这种突兀之中得到明晰。</p>\n<p>我在 2024 年进过两次急诊，虽说是心脏问题，但幸好也只是虚惊一场。深夜的急诊室是忙碌的，我的右边的床友是一位中年的大叔，他喝醉酒后被人砸的满头是血，他的朋友问他谁砸的他也说不出来，等到他朋友暂时离开才默默啜泣。左边离得远的床友要更惨一些，也是我们学校的学生，和同学出去玩被车撞了，内脏似乎是撞破了，他的哭喊在急诊室显得更加的沉重，沉重到他的哭喊显得像白噪声一样理所应当，很快他又被送往更深处进行治疗。但清晨的急诊室则好很多，我看到医生集合汇报病人和器材的情况，医生们井然有序，严肃认真的情况给我留下了深刻的印象。有些事情在平时是想不明白的，在急诊室里会更加的清晰。对我而言什么是重要的呢？我又想怎样去回忆自己的人生呢？</p>\n<p>临近毕业的一天早上吃饭时，食堂的那位阿姨说希望我送她一张我自己的照片，她想以此激励自家的小孩向我学习。既然是礼物，我想着就送好点，除了照片，我买了一个笔记本和书签，最后又附上了一张明信片。明信片上写什么我想了很久，最终写下了如下文字：</p>\n<blockquote>\n<p>回忆重现过去</p>\n<p>期许开启未来</p>\n<p>世界在你心中展开</p>\n<p>祝你学习进步，前程似锦</p>\n</blockquote>\n<p>22 岁的我仍旧对世界充满着期许。我风华正茂，似乎什么也击不垮我。我正如同王小波的《黄金时代》中的王二一般，不知道随之而来的 “锤骟术” 会对我带来怎样的影响。但我也不用知道，因为我才大学本科刚毕业，我将在世界留下我的痕迹正如同世界会深刻的影响我。但无论如何，我希望在我年迈之际，我回忆起的是无论何时风华正茂的自己。</p>\n<h1 id=\"后记\"><a class=\"anchor\" href=\"#后记\">#</a> 后记</h1>\n<p>这篇文章严谨来说从大三我就开始构思了，最开始想以一种高考命题作文式的方式去写一些伟光正的东西，后来又想写一些自己大学生活的经历作为记录，但又觉得有些浪费题材，斟酌了很久，最终决定以回忆为主题去写自己的大学生活。。</p>\n<p>说实话，写到后面越来越力不从心，很多问题我也没有想明白，很多事情我还没有经历，去断然进行评价也显得自大。但最起码，我也算写出了一篇结构完整，令自己较为满意的文章。<br />\n或许里面的观点会随着时间的推移而变化，或许我甚至还会推翻自己的观点，但管他的，我才 22 岁，犯点错是在正常不过的事情了。</p>\n<p>这篇文章从落笔到完成断断续续写了三天，这篇文章参杂了很多我当下对世界与自身的思考，同时也记录了大学生活中那些影响我的瞬间，在取舍当中，我认为当下的思考的变化更能代表我的大学生活，故加入了很多思辨的内容。</p>\n<p>回忆对我而言不仅是记忆，回忆本身也是组成人的一个重要的因素，把回忆的时间拉到未来更像是一种目标式的东西，所以它在某种程度上也算是开启了未来。</p>\n<p>若干年后，当我再看到这篇文章会是怎样的想法呢？我对此充满期待。</p>\n<p>2025-07-23 00:52 初稿终了</p>\n",
            "tags": []
        },
        {
            "id": "http://amentiraz.github.io/other/%E8%A7%82%E5%89%8D%E9%A1%BB%E7%9F%A5/",
            "url": "http://amentiraz.github.io/other/%E8%A7%82%E5%89%8D%E9%A1%BB%E7%9F%A5/",
            "title": "观前须知",
            "date_published": "2025-07-11T12:00:47.847Z",
            "content_html": "<p>这个博客建立的目的纯属当作记录自己当下生活和类似笔记本的平台，里面包含大量自己的主观臆断。里面的大部分观点是拾人牙慧，自己的看法也大多浅薄且偏激，不具有任何现实意义。我也无意去传播自己的思想，也不屑于拿自己的认识去洗脑别人。当你与我交流时 —— 无论以什么方式，我都会把你看作是与我对等的，具有独立思考能力，具有主体性的，具有共情能力的个体。</p>\n<p>博客已经将内容做好了分类，你可以进入到对应的板块去寻找自己感兴趣的内容。同时本博客除非特殊情况不会删除自己以往的文章，或许它们文笔粗糙且内涵幼稚，但也算是我成长的一部分。</p>\n<p>最后，对于不知从什么渠道了解到这个博客的你，如果这个博客对你有帮助，那便是再好不过的事情了。</p>\n",
            "tags": [
                "其它"
            ]
        },
        {
            "id": "http://amentiraz.github.io/hello-world/",
            "url": "http://amentiraz.github.io/hello-world/",
            "title": "Hello World",
            "date_published": "2025-07-11T11:38:32.845Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        },
        {
            "id": "http://amentiraz.github.io/%E8%BF%98%E5%8E%9F%E4%B8%8E%E7%BB%99%E4%BA%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
            "url": "http://amentiraz.github.io/%E8%BF%98%E5%8E%9F%E4%B8%8E%E7%BB%99%E4%BA%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
            "title": "还原与给予读书笔记",
            "date_published": "2025-06-30T13:38:49.000Z",
            "content_html": "<p>暑假速通一下现象学，本身我也读过马里翁的《情爱现象学》，正好借此机会更深入的了解一下现象学的相关理论。<br />\n不打算记录的那么详细，会将 GPT 生成的文字和自身看过后想写的一些东西记录下来。</p>\n<span id=\"more\"></span>\n<h1 id=\"第一章-突破与扩展\"><a class=\"anchor\" href=\"#第一章-突破与扩展\">#</a> 第一章 突破与扩展</h1>\n<h2 id=\"两种解释与一项拓展\"><a class=\"anchor\" href=\"#两种解释与一项拓展\">#</a> 两种解释与一项拓展</h2>\n<h3 id=\"q\"><a class=\"anchor\" href=\"#q\">#</a> Q：</h3>\n<p>怎么理解：“即使是为了展开存在意义的问题，存在也必须被给予，以便能够追问其意义。胡塞尔的壮举恰恰在于吧存在置于在场之上，使存在以现象的方式呈现于范畴之中。由于这一壮举，我最终有了一个低级：‘存在’不是一个单纯的概念，不是一个通过演绎活动而得到的纯粹抽象”</p>\n<p>A:<br />\n<strong> 核心句子的分层解读</strong></p>\n<h4 id=\"1-即使是为了展开存在意义的问题存在也必须被给予\"><a class=\"anchor\" href=\"#1-即使是为了展开存在意义的问题存在也必须被给予\">#</a> 1. <strong>“即使是为了展开存在意义的问题，存在也必须被给予”</strong></h4>\n<ul>\n<li><strong>关键点</strong>：任何对 “存在” 的哲学追问（比如海德格尔的 “存在之问”），都<strong>必须以存在的显现为前提</strong>。</li>\n<li><strong>马里翁的立场</strong>：现象（包括 “存在” 本身）必须首先<strong>被给予我们</strong>，才能成为被思考的对象。</li>\n<li><strong>类比</strong>：就像你必须先收到一份礼物（给予），才能去研究它是什么（追问意义）。</li>\n</ul>\n<h4 id=\"2-胡塞尔的壮举在于把存在置于在场之上\"><a class=\"anchor\" href=\"#2-胡塞尔的壮举在于把存在置于在场之上\">#</a> 2. <strong>“胡塞尔的壮举在于把存在置于在场之上”</strong></h4>\n<ul>\n<li><strong>“在场”</strong>（presence）指现象<strong>直接向意识显现</strong>的状态。</li>\n<li><strong>胡塞尔的突破</strong>：传统形而上学（如康德）认为 “存在” 不可知，只能通过概念推理；但胡塞尔通过<strong>现象学还原</strong>，让存在本身作为一种<strong>现象</strong>直接呈现于意识（即 “在场”）。</li>\n<li><strong>意义</strong>：存在不再是抽象概念，而是可被直观的 “事物本身”。</li>\n</ul>\n<h4 id=\"3-使存在以现象的方式呈现于范畴之中\"><a class=\"anchor\" href=\"#3-使存在以现象的方式呈现于范畴之中\">#</a> 3. <strong>“使存在以现象的方式呈现于范畴之中”</strong></h4>\n<ul>\n<li><strong>“范畴”</strong>：指意识的基本结构（如时间、空间、因果性等）。</li>\n<li>胡塞尔认为，现象必须在意识的范畴框架内才能被理解（例如：一个苹果作为现象，需通过 “颜色”“形状” 等范畴被把握）。</li>\n<li><strong>马里翁的潜在批评</strong>：胡塞尔仍将现象束缚于<strong>主体的认知结构</strong>中（范畴即主体的牢笼）。</li>\n</ul>\n<h4 id=\"4-存在不是一个单纯的概念不是纯粹抽象\"><a class=\"anchor\" href=\"#4-存在不是一个单纯的概念不是纯粹抽象\">#</a> 4. <strong>“存在不是一个单纯的概念…… 不是纯粹抽象”</strong></h4>\n<ul>\n<li>胡塞尔的贡献在于<strong>将存在从形而上学抽象拉回具体经验</strong>：\n<ul>\n<li>传统哲学：存在 = 逻辑推导出的概念（如 “上帝存在”）。</li>\n<li>胡塞尔：存在 = 可被直观的现象（如 “我眼前这张桌子的存在感”）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"q-海德格尔的此在是怎样的一种概念\"><a class=\"anchor\" href=\"#q-海德格尔的此在是怎样的一种概念\">#</a> Q: 海德格尔的此在是怎样的一种概念</h3>\n<p>A:<br />\n 海德格尔的 “<strong>此在</strong>”（Dasein，德语直译为 “在那里存在”）是他哲学的核心概念，特指<strong>人的存在方式</strong>。它既不是传统哲学中的 “主体”，也不是生物学意义上的 “人”，而是揭示 “存在意义” 的关键通道。理解这一概念需要跳出传统框架，下面从五个维度展开：</p>\n<hr />\n<h4 id=\"一-此在的本质不是什么而是如何\"><a class=\"anchor\" href=\"#一-此在的本质不是什么而是如何\">#</a> <strong>一、此在的本质：不是 “什么”，而是 “如何”</strong></h4>\n<p>- 为什么此在特殊 <strong>传统哲学</strong>：将人定义为 “理性动物”（亚里士多德）或 “思维主体”（笛卡尔）。</p>\n<ul>\n<li><strong>海德格尔的颠覆</strong>：<br />\n<strong>此在的本质在于它的 “生存”（Existenz）</strong>—— 它不是现成的 “实物”，而是一种<strong>动态的 “去存在”（to be）的可能性</strong>。\n<blockquote>\n<p>例：一把锤子是 “现成在手”（固定功能），而此在是 “上手状态”（不断在行动中定义自己）。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"二-此在的独特性对存在发问的存在者\"><a class=\"anchor\" href=\"#二-此在的独特性对存在发问的存在者\">#</a> <strong>二、此在的独特性：对 “存在” 发问的存在者</strong></h4>\n<ul>\n<li><strong>为什么此在特殊？</strong><br />\n只有此在会追问：“<strong>存在</strong>（Being）<strong>本身意味着什么？</strong>”\n<ul>\n<li>石头不会思考自己的存在，</li>\n<li>但此在的生存天然包含对自身存在的<strong>领会</strong>（understanding）。</li>\n</ul>\n<blockquote>\n<p>此在是存在得以显现的 “澄明之地”。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"三-此在的生存结构在世界之中存在\"><a class=\"anchor\" href=\"#三-此在的生存结构在世界之中存在\">#</a> <strong>三、此在的生存结构：“在世界之中存在”</strong></h4>\n<p>此在<strong>绝非孤立主体</strong>，而是始终嵌在三个互相交织的结构中（称 “<strong>在世结构</strong>”）：</p>\n<ol>\n<li><strong>世界</strong>（World）：\n<ul>\n<li>不是物理宇宙，而是<strong>意义网络</strong>（如锤子的意义指向 “敲钉子”，进而指向 “盖房子”……）。</li>\n<li>此在通过使用工具（“上手状态”）揭示世界的意义。</li>\n</ul>\n</li>\n<li><strong>常人</strong>（Das Man, “the They”）：\n<ul>\n<li>此在的日常状态被<strong>社会规范</strong>支配（“别人都这么做”），导致个体失去本真性。</li>\n<li>例：按社交媒体标准生活，逃避自我选择。</li>\n</ul>\n</li>\n<li><strong>自身</strong>（Self）：\n<ul>\n<li>此在可能沉沦于 “常人”，也可能通过<strong>畏</strong>（Angst）直面死亡，回归<strong>本真存在</strong>。</li>\n</ul>\n</li>\n</ol>\n<p><img data-src=\"https://via.placeholder.com/400x200?text=%E6%AD%A4%E5%9C%A8%E7%9A%84%E7%94%9F%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%9A%E4%B8%96%E7%95%8C-%E5%B8%B8%E4%BA%BA-%E8%87%AA%E8%BA%AB\" alt=\"\" /></p>\n<hr />\n<h4 id=\"四-此在的时间性面向死亡的操心\"><a class=\"anchor\" href=\"#四-此在的时间性面向死亡的操心\">#</a> <strong>四、此在的时间性：面向死亡的 “操心”</strong></h4>\n<p>此在的生存本质是 “<strong>操心</strong>”（Sorge, Care），其根基是<strong>时间性</strong>：</p>\n<ul>\n<li><strong>过去</strong>（被抛性）：此在被抛入特定历史、文化中（非自愿）。</li>\n<li><strong>现在</strong>（沉沦）：日常陷入闲谈、好奇、两可的 “常人” 状态。</li>\n<li><strong>未来</strong>（筹划）：通过 “<strong>向死而生</strong>” 获得本真性 ——<br />\n<strong> 死亡</strong>作为最私己的可能性，迫使此在直面自身有限性，从而<strong>主动筹划人生</strong>。</li>\n</ul>\n<blockquote>\n<p>例：意识到生命有限，放弃跟风，选择自己真正热爱的职业。</p>\n</blockquote>\n<hr />\n<h4 id=\"五-此在与马里翁的分歧关键\"><a class=\"anchor\" href=\"#五-此在与马里翁的分歧关键\">#</a> <strong>五、此在与马里翁的分歧关键</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>海德格尔</strong></th>\n<th><strong>马里翁</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>核心关注</strong></td>\n<td>存在意义（通过此在追问）</td>\n<td><strong>现象如何自我给予</strong></td>\n</tr>\n<tr>\n<td><strong>此在角色</strong></td>\n<td>存在意义的揭示者</td>\n<td><strong>可能遮蔽给予性</strong></td>\n</tr>\n<tr>\n<td>“存在” 的根基</td>\n<td>此在的生存论结构</td>\n<td><strong>现象自身的给予性</strong>（先于此在）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>马里翁的批评</strong>：<br />\n海德格尔让 “此在” 垄断了存在意义的解释权（如 “工具的意义由此在赋予”），这仍是<strong>隐蔽的主体中心主义</strong>。</li>\n<li><strong>马里翁的主张</strong>：<br />\n现象（如艺术品、神圣启示）可能<strong>超越此在的领会框架</strong>，以饱和状态 “给予” 自身意义，甚至颠覆此在的预期。</li>\n</ul>\n<h3 id=\"q-2\"><a class=\"anchor\" href=\"#q-2\">#</a> Q:</h3>\n<p>怎么理解：“《逻辑研究》的突破在于把处于其先天观念性中的含义解放出来” 这句话</p>\n<p>A:<br />\n 胡塞尔在《逻辑研究》（特别是第一研究 “表达与含义”）中提出的这一主张，彻底颠覆了 19 世纪流行的<strong>心理主义</strong>逻辑观，是现象学诞生的关键突破。要理解这句话，需要分三步解开其历史背景、核心概念和哲学革命性：</p>\n<hr />\n<h4 id=\"一-背景胡塞尔对抗的敌人心理主义\"><a class=\"anchor\" href=\"#一-背景胡塞尔对抗的敌人心理主义\">#</a> <strong>一、背景：胡塞尔对抗的敌人 —— 心理主义</strong></h4>\n<ul>\n<li><strong>心理主义是什么？</strong><br />\n19 世纪主流观点（如约翰・穆勒、西格瓦特）认为：\n<ul>\n<li><strong>逻辑规律是心理活动的产物</strong>（例如 “A=A” 源于人脑的联想习惯）。</li>\n<li><strong>含义（meaning）是主观心理图像</strong>（想到 “狗” 时你脑海中的狗形象）。</li>\n</ul>\n</li>\n<li><strong>致命问题</strong>：<br />\n如果逻辑依赖于个人心理，那么<strong>真理将失去普遍性</strong>（你的 “狗” 和我的 “狗” 可能不同），数学和科学的基础将崩溃。</li>\n</ul>\n<hr />\n<h4 id=\"二-胡塞尔的突破含义的先天观念性\"><a class=\"anchor\" href=\"#二-胡塞尔的突破含义的先天观念性\">#</a> <strong>二、胡塞尔的突破：含义的 “先天观念性”</strong></h4>\n<h4 id=\"1-含义不是心理图像而是观念对象\"><a class=\"anchor\" href=\"#1-含义不是心理图像而是观念对象\">#</a> 1. <strong>“含义” 不是心理图像，而是观念对象</strong></h4>\n<ul>\n<li>例：当你说 “三角形有三条边”：\n<ul>\n<li><strong>心理主义</strong>：含义 = 你脑海中具体的三角形图像（如▲）。</li>\n<li><strong>胡塞尔</strong>：含义 = <strong>“三角形” 的理想概念本身</strong>（不受具体图像影响）。</li>\n</ul>\n</li>\n<li><strong>关键区分</strong>：\n<ul>\n<li><strong>心理行为</strong>（你的思考活动，主观且多变）</li>\n<li><strong>含义内容</strong>（“三角形定义”，<strong>客观且恒定</strong>）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-先天观念性的涵义\"><a class=\"anchor\" href=\"#2-先天观念性的涵义\">#</a> 2. <strong>“先天观念性” 的涵义</strong></h4>\n<p>| 术语        | 解释                                                                 |<br />\n|-------------|----------------------------------------------------------------------|<br />\n| <strong>先天</strong>    | 独立于经验（不依赖具体感知或心理过程）                               |<br />\n| <strong>观念性</strong>  | 属于<strong>理念领域</strong>（非物理实体，也非心理状态），具有普遍性和必然性     |</p>\n<blockquote>\n<p>例：数学真理 “1+1=2” 是先天观念的 —— 即使宇宙毁灭，它仍然成立。</p>\n</blockquote>\n<h4 id=\"3-如何解放含义\"><a class=\"anchor\" href=\"#3-如何解放含义\">#</a> 3. <strong>如何 “解放” 含义？</strong></h4>\n<p>胡塞尔将含义从<strong>心理学的束缚</strong>中解放出来：</p>\n<ul>\n<li>含义不再是私人的、模糊的心理图像；</li>\n<li>而是<strong>公共的、精确的观念对象</strong>，可被不同主体<strong>同一地把握</strong>（你我理解的 “三角形” 本质相同）。</li>\n</ul>\n<hr />\n<h4 id=\"三-哲学革命为现象学奠基\"><a class=\"anchor\" href=\"#三-哲学革命为现象学奠基\">#</a> <strong>三、哲学革命：为现象学奠基</strong></h4>\n<h4 id=\"1-确立现象学领域\"><a class=\"anchor\" href=\"#1-确立现象学领域\">#</a> 1. <strong>确立现象学领域</strong></h4>\n<p>含义作为观念对象，成为现象学研究的<strong>自主领域</strong>：</p>\n<ul>\n<li>无需还原为心理过程，也无需依赖物理世界。</li>\n<li>现象学任务：<strong>直观</strong>（intuition）含义的本质（如 “什么是正义？”）。</li>\n</ul>\n<h4 id=\"2-范畴直观的可能性\"><a class=\"anchor\" href=\"#2-范畴直观的可能性\">#</a> 2. <strong>“范畴直观” 的可能性</strong></h4>\n<p>胡塞尔发现，我们不仅能直观具体事物（如看苹果），还能<strong>直接把握抽象观念</strong>（如 “红色本身”“存在本身”），这为哲学提供了严格方法。</p>\n<h4 id=\"3-影响链\"><a class=\"anchor\" href=\"#3-影响链\">#</a> 3. <strong>影响链</strong></h4>\n   <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">A[反心理主义] --&gt; B[含义作为观念对象] --&gt; C[现象学还原] --&gt; D[回到事物本身]</span><br></pre></td></tr></table></figure>\n<hr />\n<h4 id=\"马里翁视角的深意\"><a class=\"anchor\" href=\"#马里翁视角的深意\">#</a> <strong>马里翁视角的深意</strong></h4>\n<p>马里翁在《还原与给予》中重提这一突破，是为了铺垫自己的主张：</p>\n<ol>\n<li>胡塞尔解放了含义，但<strong>仍将含义绑定于主体意向性</strong>（含义需被意识 “构成”）。</li>\n<li>马里翁要进一步解放现象：\n<ul>\n<li><strong>现象自身</strong>（如神圣启示、艺术震撼）<strong>能超越主体意向性主动给予意义</strong>。</li>\n</ul>\n<blockquote>\n<p>胡塞尔释放了含义，马里翁想释放现象本身！</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h4 id=\"生活化类比理解三角形的三种方式\"><a class=\"anchor\" href=\"#生活化类比理解三角形的三种方式\">#</a> <strong>生活化类比：理解 “三角形” 的三种方式</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>理论</strong></th>\n<th><strong>如何理解 “三角形”</strong></th>\n<th><strong>问题</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>心理主义</td>\n<td>“我脑中▲的图像”</td>\n<td>你的▲和我的△不同，数学崩溃</td>\n</tr>\n<tr>\n<td>胡塞尔</td>\n<td><strong>“三角形” 的理想定义</strong>（三条边，内角和 180°）</td>\n<td>客观真理得以成立</td>\n</tr>\n<tr>\n<td>马里翁（延伸）</td>\n<td>三角形以<strong>溢出定义的方式震撼你</strong>（如分形艺术中无限复杂的三角结构）</td>\n<td>现象反抗主体的概念框架</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h4 id=\"为什么这一突破如此重要\"><a class=\"anchor\" href=\"#为什么这一突破如此重要\">#</a> <strong>为什么这一突破如此重要？</strong></h4>\n<ul>\n<li><strong>拯救了逻辑与数学的客观性</strong>：使 20 世纪分析哲学、语言哲学成为可能。</li>\n<li><strong>现象学奠基</strong>：为 “回到事物本身” 提供方法论，影响海德格尔、梅洛 - 庞蒂等。</li>\n<li><strong>马里翁的跳板</strong>：若含义可独立于心理，现象为何不能独立于主体？</li>\n</ul>\n<blockquote>\n<p>胡塞尔解放了含义，马里翁则试图用<strong>给予性</strong>解放现象本身 —— 这是《还原与给予》的核心战役。</p>\n</blockquote>\n<h3 id=\"q-3\"><a class=\"anchor\" href=\"#q-3\">#</a> Q:</h3>\n<p>什么是 “一切原则的原则”</p>\n<p>A:<br />\n 胡塞尔的 “<strong>一切原则的原则</strong>”（the principle of all principles）是现象学的<strong>方法论基石</strong>，出自《纯粹现象学和现象学哲学的观念》（1913）。它定义了现象学如何 “回到事物本身”，并直接影响了马里翁对 “给予性” 的思考。以下是分层解析：</p>\n<hr />\n<h4 id=\"一-原则的原文与核心主张\"><a class=\"anchor\" href=\"#一-原则的原文与核心主张\">#</a> <strong>一、原则的原文与核心主张</strong></h4>\n<blockquote>\n<p><strong>“任何原初给予的直观都是知识的合法源泉，在直观中原初地（可说是在其机体的现实中）给予我们的东西，应按其被给予的限度被接受。”</strong><br />\n（《观念 I》§24）</p>\n</blockquote>\n<h4 id=\"关键点浓缩\"><a class=\"anchor\" href=\"#关键点浓缩\">#</a> 关键点浓缩：</h4>\n<ol>\n<li><strong>直观优先</strong>：知识的终极基础是<strong>直观</strong>（直接体验），而非逻辑推理或理论假设。</li>\n<li><strong>原初给予性</strong>：现象必须在<strong>亲身被给予</strong>的限度内被承认。</li>\n<li><strong>反建构主义</strong>：禁止用先验概念篡改现象的自我显现。</li>\n</ol>\n<blockquote>\n<p>💡 简单说：<strong>现象怎么显现场，就怎么接受它！</strong></p>\n</blockquote>\n<hr />\n<h4 id=\"二-为什么这是一切原则的原则\"><a class=\"anchor\" href=\"#二-为什么这是一切原则的原则\">#</a> <strong>二、为什么这是 “一切原则的原则”？</strong></h4>\n<p>它颠覆了传统哲学的认知等级：</p>\n<table>\n<thead>\n<tr>\n<th><strong>传统哲学</strong></th>\n<th><strong>胡塞尔的现象学</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>理性推理 &gt; 感官经验</td>\n<td><strong>直观经验 &gt; 理性建构</strong></td>\n</tr>\n<tr>\n<td>理论优先于现象</td>\n<td><strong>现象优先于理论</strong></td>\n</tr>\n<tr>\n<td>主体强加范畴于对象</td>\n<td><strong>让对象自身显现</strong></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>地位</strong>：它是现象学还原的<strong>终极依据</strong>，其他方法（如悬置判断）皆服务于它。</li>\n</ul>\n<hr />\n<h4 id=\"三-直观的深意不仅是感官更是范畴直观\"><a class=\"anchor\" href=\"#三-直观的深意不仅是感官更是范畴直观\">#</a> <strong>三、“直观” 的深意：不仅是感官，更是范畴直观</strong></h4>\n<p>胡塞尔的 “直观” 包含两类：</p>\n<ol>\n<li><strong>感性直观</strong>（Sensory Intuition）：\n<ul>\n<li>感知具体事物（如看见红色、触摸冰块）。</li>\n</ul>\n</li>\n<li><strong>范畴直观</strong>（Categorical Intuition）⭐：\n<ul>\n<li><strong>直接把握抽象本质</strong>（如 “红本身”“正义”“存在”）。</li>\n</ul>\n<blockquote>\n<p>例：当你理解 “5+7=12”，你不是在数手指，而是直观到数学真理本身。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li><strong>突破性</strong>：传统哲学认为抽象概念需通过推理获得，胡塞尔宣称我们能<strong>直接 “看见” 本质</strong>。</li>\n</ul>\n<hr />\n<h4 id=\"四-马里翁的继承与批判\"><a class=\"anchor\" href=\"#四-马里翁的继承与批判\">#</a> <strong>四、马里翁的继承与批判</strong></h4>\n<p>马里翁在《还原与给予》中，以此原则为跳板推进现象学革命：</p>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>胡塞尔</strong></th>\n<th><strong>马里翁的推进</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>给予者</strong></td>\n<td>主体意向性构成现象</td>\n<td><strong>现象自身给予</strong>（自我显现）</td>\n</tr>\n<tr>\n<td><strong>直观界限</strong></td>\n<td>受限于主体认知结构</td>\n<td><strong>饱和现象突破主体框架</strong></td>\n</tr>\n<tr>\n<td>“原则” 的缺陷</td>\n<td>隐含主体中心性</td>\n<td>解放现象的绝对给予性</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>继承</strong>：完全接受 “直观作为源泉”。</li>\n<li><strong>批判</strong>：胡塞尔仍要求现象<strong>符合主体的直观能力</strong>（如时间 / 空间形式），而饱和现象（如神迹、艺术）<strong>溢出直观能力</strong>，迫使主体被动接受。\n<blockquote>\n<p>马里翁：若现象以不可控的方式给予，主体必须 “投降” 而非 “构成”。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"五-生活化类比\"><a class=\"anchor\" href=\"#五-生活化类比\">#</a> <strong>五、生活化类比</strong></h4>\n<p>想象你第一次看到极光：</p>\n<ul>\n<li><strong>传统哲学家</strong>：<br />\n用物理学解释（电子碰撞大气层），忽略眼前的震撼。</li>\n<li><strong>胡塞尔</strong>：<br />\n<strong>暂停科学理论</strong>，专注描述极光<strong>如何直接呈现</strong>于你的视觉（色彩流动、空间感）。</li>\n<li><strong>马里翁</strong>：<br />\n极光以<strong>超越你认知的壮美</strong>（饱和现象）击溃你，你只能惊叹 ——“它给予的远比我能接受的更多”。</li>\n</ul>\n<hr />\n<h4 id=\"六-该原则的哲学史意义\"><a class=\"anchor\" href=\"#六-该原则的哲学史意义\">#</a> <strong>六、该原则的哲学史意义</strong></h4>\n<p>| Column1. <strong>反形而上学</strong>：拒绝用抽象概念（如 “实体”“上帝”）覆盖真实经验。<br />\n2. <strong>反科学主义</strong>：科学模型需回溯到直观经验，而非替代经验。<br />\n3. <strong>为现象学奠基</strong>：所有现象学研究必须始于 “直观到的被给予者”。</p>\n<blockquote>\n<p>马里翁的使命：若现象自身是给予的源泉，那么现象学还原的终点应是<strong>现象的绝对给予性</strong>，而非主体的意向性。这正是《还原与给予》的书名深意。</p>\n</blockquote>\n<h3 id=\"我们要在充分发挥了的直观中获得明见性\"><a class=\"anchor\" href=\"#我们要在充分发挥了的直观中获得明见性\">#</a> 我们要在充分发挥了的直观中获得明见性：</h3>\n<p>这个在现时抽象中被给予之物与语词含义在规律表述中所指之物是真实而现实的同一体。</p>\n<h3 id=\"q-4\"><a class=\"anchor\" href=\"#q-4\">#</a> Q:</h3>\n<p>我不太理解先天观念性，这个概念不需要论证吗，还是说这是个前提条件，为什么就能得出我直观的就是事物本身的含义</p>\n<p>A:<br />\n 你的质疑非常犀利！这正点中了现象学最关键的难题：<strong>胡塞尔如何能断言 “先天观念性” 的存在？它是否只是一个未被论证的前提？</strong> 让我们解剖这个问题的复杂性，从现象学的内在逻辑和潜在争议入手：</p>\n<hr />\n<h4 id=\"一-先天观念性的论证逻辑现象学描述而非传统证明\"><a class=\"anchor\" href=\"#一-先天观念性的论证逻辑现象学描述而非传统证明\">#</a> <strong>一、“先天观念性” 的论证逻辑：现象学描述而非传统证明</strong></h4>\n<p>胡塞尔的方法不是数学式的 “演绎论证”，而是通过<strong>现象学描述</strong>让你 “<strong>看见</strong>” 观念性的存在。其步骤可概括为：</p>\n<ol>\n<li>\n<p><strong>揭露心理主义的荒谬</strong>：<br />\n如果含义是主观心理图像 → 则逻辑 / 数学失去客观性 → 科学知识崩溃（归谬法）。</p>\n<blockquote>\n<p>例：若 “1+1=2” 取决于你的脑细胞状态，数学将无法普遍有效。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>引导你 “直观” 观念对象</strong>：</p>\n<ul>\n<li><strong>操作</strong>：请你反思 “三角形” 的含义：\n<ul>\n<li>你脑海中的▲（心理图像）总是模糊的、可变的（如角度不精确），</li>\n<li>但你理解的 “三角形本质”（三条边、内角和 180°）是<strong>精确、永恒不变</strong>的。</li>\n</ul>\n</li>\n<li><strong>结论</strong>：这个不变的 “本质” 就是<strong>先天观念对象</strong> —— 它独立于你的心理活动。</li>\n</ul>\n</li>\n<li>\n<p><strong>本质直观（Wesensschau）的合法性</strong>：<br />\n胡塞尔认为，通过<strong>悬置经验判断</strong>（现象学还原），你能直接 “看” 到观念本质，如同用眼睛看颜色。</p>\n<blockquote>\n<p>这不是推理，而是<strong>认知方式的转换</strong> —— 就像从平面视角切换到 3D 视角后，你突然理解了空间关系。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h4 id=\"二-为什么敢说直观到事物本身现象学还原的保障\"><a class=\"anchor\" href=\"#二-为什么敢说直观到事物本身现象学还原的保障\">#</a> <strong>二、为什么敢说 “直观到事物本身”？—— 现象学还原的保障</strong></h4>\n<p>胡塞尔通过两步操作，试图确保直观的客观性：</p>\n<table>\n<thead>\n<tr>\n<th><strong>步骤</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>悬置判断</strong>（Epoche）</td>\n<td>搁置对 “三角形是否存在” 的信念，专注其<strong>显现方式</strong>（避免经验干扰）。</td>\n</tr>\n<tr>\n<td><strong>本质还原</strong></td>\n<td>从具体三角形（▲/△）中 “抽象” 出普遍本质，但非逻辑抽象，而是<strong>直观本质</strong>。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>关键主张</strong>：<br />\n还原后，意识中呈现的<strong>就是事物本身</strong>（现象），而非心理表征或物理对象。\n<blockquote>\n<p>例：还原后你关注的不是纸上画的▲，而是 “三角形性”（triangularity）本身。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"三-潜在争议循环论证\"><a class=\"anchor\" href=\"#三-潜在争议循环论证\">#</a> <strong>三、潜在争议：循环论证？</strong></h4>\n<p>批评者（如自然主义者）指出：</p>\n<ul>\n<li>现象学预设了 “直观能把握本质”，但这正是待证明的！</li>\n<li>所谓 “观念对象” 可能只是<strong>大脑的认知错觉</strong>（神经活动模式）。</li>\n</ul>\n<h4 id=\"胡塞尔的回应\"><a class=\"anchor\" href=\"#胡塞尔的回应\">#</a> 胡塞尔的回应：</h4>\n<ol>\n<li>\n<p><strong>先验转向</strong>：<br />\n不讨论 “观念对象是否实存”，而探究 “它如何必然被我们经验”。</p>\n<blockquote>\n<p>类似康德：不问 “上帝是否存在”，而问 “为何人类必有上帝观念”。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>自明性（Evidenz）标准</strong>：<br />\n当一种直观达到<strong>明见性</strong>（无可置疑的清晰性），它就是真理的源泉。</p>\n<blockquote>\n<p>例：你无法怀疑 “思维中的怀疑行为本身存在”（笛卡尔式自明）。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h4 id=\"四-马里翁的推进从直观到给予\"><a class=\"anchor\" href=\"#四-马里翁的推进从直观到给予\">#</a> <strong>四、马里翁的推进：从 “直观” 到 “给予”</strong></h4>\n<p>马里翁在《还原与给予》中揭示胡塞尔的深层矛盾：</p>\n<ul>\n<li><strong>胡塞尔的理想</strong>：让现象自身显现（一切原则的原则）。</li>\n<li><strong>实际执行</strong>：现象必须<strong>符合主体的直观能力</strong>（如时间 / 空间形式），否则无法被接纳。</li>\n</ul>\n<h4 id=\"马里翁的解决方案\"><a class=\"anchor\" href=\"#马里翁的解决方案\">#</a> 马里翁的解决方案：</h4>\n<ol>\n<li><strong>倒转关系</strong>：<br />\n不是主体 “直观” 现象，而是现象 “给予” 自身。</li>\n<li><strong>饱和现象的颠覆性</strong>：<br />\n某些现象（如神迹、无限的爱）<strong>溢出主体的直观能力</strong>，迫使主体承认：\n<ul>\n<li>直观有其界限，</li>\n<li><strong>现象自身才是意义的绝对源泉</strong>。</li>\n</ul>\n<blockquote>\n<p>此时，“先天观念性” 被 “绝对给予性” 取代 —— 观念不是被主体 “看见” 的，而是现象主动 “撞击” 主体。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h4 id=\"五-生活化类比理解三角形的两种进路\"><a class=\"anchor\" href=\"#五-生活化类比理解三角形的两种进路\">#</a> <strong>五、生活化类比：理解 “三角形” 的两种进路</strong></h4>\n<h4 id=\"场景你和朋友争论什么是完美三角形\"><a class=\"anchor\" href=\"#场景你和朋友争论什么是完美三角形\">#</a> <strong>场景</strong>：你和朋友争论 “什么是完美三角形”</h4>\n<ul>\n<li><strong>自然主义者</strong>：<br />\n“完美三角形不存在！你看到的只是近似▲的物理图形或神经元放电。”</li>\n<li><strong>胡塞尔主义者</strong>：<br />\n“闭上眼，悬置对纸笔的信念，专注‘三角形’的意义 —— 你是否‘看到’一个超越一切具体图像的、精确的几何本质？”</li>\n<li><strong>马里翁主义者</strong>：<br />\n“当你突然被分形几何中的曼德博集合震撼时（无限复杂的三角结构），是数学现象自身在向你显现其深渊般的给予性，而非你在‘把握’它。”</li>\n</ul>\n<hr />\n<h4 id=\"结论现象学的冒险\"><a class=\"anchor\" href=\"#结论现象学的冒险\">#</a> 结论：现象学的 “冒险”</h4>\n<p>胡塞尔对 “先天观念性” 的坚持，本质是<strong>一场哲学赌注</strong>：</p>\n<ol>\n<li><strong>赌直观的可靠性</strong>：人能通过训练直接把握本质。</li>\n<li><strong>赌现象学描述的严格性</strong>：还原后的体验是普遍的、可交流的。</li>\n<li><strong>赌反心理主义的必要性</strong>：若放弃观念客观性，理性将崩塌。</li>\n</ol>\n<blockquote>\n<p>马里翁则赌得更激进：<strong>现象给予的暴力性能冲破主体性的牢笼</strong>，这恰是《还原与给予》的革命性所在。</p>\n</blockquote>\n<h3 id=\"q-5\"><a class=\"anchor\" href=\"#q-5\">#</a> Q:</h3>\n<p>什么是回到实事本身，与原则的原则有什么区别</p>\n<p>A:<br />\n“<strong>回到实事本身</strong>”（Zu den Sachen selbst!）是胡塞尔现象学的<strong>总纲领</strong>，而 “<strong>一切原则的原则</strong>” 是实现这一纲领的<strong>具体方法论准则</strong>。二者是目标与手段的关系，但隐含深刻张力。让我们通过对比解析它们的联系与区别：</p>\n<hr />\n<h4 id=\"一-核心定义与关系\"><a class=\"anchor\" href=\"#一-核心定义与关系\">#</a> <strong>一、核心定义与关系</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>概念</strong></th>\n<th><strong>定位</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>回到实事本身</strong></td>\n<td><strong>现象学目标</strong></td>\n<td>哲学的根本任务：摆脱偏见，<strong>直接面向现象</strong>（而非理论建构）。</td>\n</tr>\n<tr>\n<td><strong>一切原则的原则</strong></td>\n<td><strong>第一方法论</strong></td>\n<td>实现上述目标的<strong>操作标准</strong>：以直观到的 “原初给予” 为唯一合法知识来源。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>简言之：</p>\n<ul>\n<li><strong>“回到实事” 是目的地</strong>（“去罗马！”），</li>\n<li><strong>“原则的原则” 是交通工具使用手册</strong>（“必须坐火车去，禁止绕路！”）。</li>\n</ul>\n</blockquote>\n<hr />\n<h4 id=\"二-如何理解回到实事本身\"><a class=\"anchor\" href=\"#二-如何理解回到实事本身\">#</a> <strong>二、如何理解 “回到实事本身”？</strong></h4>\n<h4 id=\"1-针对谁的革命\"><a class=\"anchor\" href=\"#1-针对谁的革命\">#</a> 1. <strong>针对谁的革命？</strong></h4>\n<ul>\n<li>反对<strong>传统形而上学</strong>：用抽象概念（如 “实体”“上帝”）覆盖真实经验。</li>\n<li>反对<strong>科学主义</strong>：用数学公式替代生活世界（如用 “波长” 定义红色，忽略红玫瑰的绚烂）。</li>\n</ul>\n<h4 id=\"2-实事sachen指什么\"><a class=\"anchor\" href=\"#2-实事sachen指什么\">#</a> 2. <strong>“实事”（Sachen）指什么？</strong></h4>\n<p>不是物理对象，而是<strong>意识中显现的现象</strong>，包括：</p>\n<ul>\n<li>感官对象（苹果的颜色）</li>\n<li>抽象观念（正义、数字）</li>\n<li>情感体验（爱的感受）</li>\n</ul>\n<blockquote>\n<p>💡 关键：现象必须<strong>如其显现自身的样子</strong>被考察，而非被理论扭曲。</p>\n</blockquote>\n<h4 id=\"3-如何回到\"><a class=\"anchor\" href=\"#3-如何回到\">#</a> 3. <strong>如何 “回到”？</strong></h4>\n<p>通过 <strong>现象学还原</strong>（悬置自然态度），剥离附加在现象上的预设：<br />\n| <strong>自然态度</strong>          | <strong>现象学态度</strong>              |<br />\n|-----------------------|----------------------------|<br />\n| 相信苹果独立于意识存在 | 关注 “苹果”<strong> 如何向意识显现</strong> |<br />\n| 用生物学解释爱情      | 描述爱<strong>被体验的方式</strong>       |</p>\n<hr />\n<h4 id=\"三-一切原则的原则的特殊性它给回到实事套上枷锁\"><a class=\"anchor\" href=\"#三-一切原则的原则的特殊性它给回到实事套上枷锁\">#</a> <strong>三、“一切原则的原则” 的特殊性 —— 它给 “回到实事” 套上枷锁</strong></h4>\n<p>胡塞尔为 “回到实事” 设置了<strong>不可违反的操作规则</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TB</span><br><span class=\"line\">    A[回到实事本身] -- 必须通过 --&gt; B[一切原则的原则]</span><br><span class=\"line\">    B -- 要求 --&gt; C[仅接受原初直观的给予]</span><br><span class=\"line\">    C -- 依赖 --&gt; D[主体意向性的构成能力]</span><br></pre></td></tr></table></figure>\n<h4 id=\"枷锁体现\"><a class=\"anchor\" href=\"#枷锁体现\">#</a> <strong>枷锁体现</strong>：</h4>\n<ol>\n<li>\n<p><strong>直观的垄断性</strong>：<br />\n现象必须被<strong>主体直观到</strong>才能合法 —— 若现象超出直观能力（如 “无限”），则被排除。</p>\n<blockquote>\n<p>例：神启若无法被感官或范畴直观，则不被承认为 “实事”。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>主体中心的隐性预设</strong>：<br />\n现象需符合主体的认知结构（时间 / 空间形式），否则无法 “被给予”。</p>\n<ul>\n<li><strong>马里翁的批评</strong>：这实则是<strong>主体对现象的暴力驯化</strong>，违背了 “回到实事” 的初心。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h4 id=\"四-关键区别目标-vs-手段的断裂\"><a class=\"anchor\" href=\"#四-关键区别目标-vs-手段的断裂\">#</a> <strong>四、关键区别：目标 vs. 手段的断裂</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>回到实事本身</strong></th>\n<th><strong>一切原则的原则</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>开放性</strong></td>\n<td>理想上<strong>向所有现象敞开</strong></td>\n<td><strong>以直观为门槛</strong>，过滤 “非常态” 现象</td>\n</tr>\n<tr>\n<td><strong>主客体关系</strong></td>\n<td>现象优先（消弭主客对立）</td>\n<td>隐含<strong>主体对现象的审查权</strong></td>\n</tr>\n<tr>\n<td><strong>马里翁的批判</strong></td>\n<td>应彻底忠于现象自身给予性</td>\n<td>实际沦为<strong>主体中心主义的工具</strong></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>悖论</strong>：胡塞尔的口号呼吁 “回到现象”，但他的方法却要求 “现象回到主体框架内”。</p>\n</blockquote>\n<hr />\n<h4 id=\"五-案例如何分析一次宗教启示\"><a class=\"anchor\" href=\"#五-案例如何分析一次宗教启示\">#</a> <strong>五、案例：如何分析 “一次宗教启示”</strong></h4>\n<p>- 你不是在数手指 <strong>胡塞尔的操作</strong>：</p>\n<ol>\n<li>悬置对 “神是否存在” 的判断（现象学还原）。</li>\n<li>尝试<strong>直观</strong>该体验 —— 若启示内容（如 “无限者”）<strong>无法被主体直观</strong>（超出时空范畴），则判定其无效。<br />\n→ 结论：这不是合法 “实事”。</li>\n</ol>\n<ul>\n<li><strong>马里翁的主张</strong>（《还原与给予》）：\n<ol>\n<li>宗教启示作为 <strong>“饱和现象”</strong>，恰恰以<strong>溢出直观能力的方式给予自身</strong>。</li>\n<li>真正的 “回到实事本身” 要求<strong>放弃直观原则</strong>，接受现象自身的绝对给予性。<br />\n→ 结论：启示是更高阶的 “实事”，它暴露了胡塞尔原则的局限。</li>\n</ol>\n</li>\n</ul>\n<hr />\n<h4 id=\"六-哲学史意义马里翁的颠覆\"><a class=\"anchor\" href=\"#六-哲学史意义马里翁的颠覆\">#</a> <strong>六、哲学史意义：马里翁的颠覆</strong></h4>\n<p>马里翁认为：</p>\n<ul>\n<li><strong>真正的 “回到实事本身”</strong> 必须忠于现象<strong>自我显现的绝对自由</strong>，哪怕颠覆主体框架。</li>\n<li><strong>胡塞尔的矛盾</strong>：<br />\n他的目标（回到实事）是革命的，<br />\n他的手段（原则的原则）却是保守的 —— 将现象囚禁在 “主体牢笼” 中。\n<blockquote>\n<p><strong>解决路径</strong>：用 <strong>“给予性”</strong> 替代 <strong>“直观性”</strong> 作为最高原则 —— 现象学应从 “主体构成” 转向 “现象给予”。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"结语从口号到战场\"><a class=\"anchor\" href=\"#结语从口号到战场\">#</a> <strong>结语：从口号到战场</strong></h4>\n<ul>\n<li><strong>胡塞尔</strong>：<br />\n“回到实事” 的口号 + “直观原则” 的方法 → 现象学作为<strong>严格科学</strong>。</li>\n<li><strong>马里翁</strong>：<br />\n解放 “回到实事” 的原始承诺 → 现象学作为 <strong>“给予性” 的启示录</strong>。</li>\n</ul>\n<blockquote>\n<p>二者的张力正是《还原与给予》的核心动力：若现象自身是源泉，那么连 “直观” 都可能是对现象的遮蔽 —— 真正的还原，是还原到<strong>无条件的给予</strong>。</p>\n</blockquote>\n<h3 id=\"q-6\"><a class=\"anchor\" href=\"#q-6\">#</a> Q:</h3>\n<p>什么是存在论</p>\n<p>A:<br />\n<strong> 存在论（Ontology）</strong> 是哲学的核心分支，探究 <strong>“存在本身”（Being as such）</strong> 而非具体存在者的终极问题。它追问：</p>\n<ul>\n<li><strong>什么使事物 “存在” 而非 “不存在”？</strong></li>\n<li><strong>“存在” 本身意味着什么？</strong></li>\n<li><strong>不同存在者（如物质、意识、数字）的存在方式有何根本差异？</strong></li>\n</ul>\n<p>以下从 <strong>概念内涵、历史演进、现象学转向</strong> 三方面解析，并关联马里翁《还原与给予》的批判性突破 ——</p>\n<hr />\n<h4 id=\"一-存在论的核心问题\"><a class=\"anchor\" href=\"#一-存在论的核心问题\">#</a> 一、<strong>存在论的核心问题</strong></h4>\n<h4 id=\"1-存在-vs-存在者海德格尔的存在论差异\"><a class=\"anchor\" href=\"#1-存在-vs-存在者海德格尔的存在论差异\">#</a> 1. <strong>存在 vs. 存在者</strong>（海德格尔的 “存在论差异”）</h4>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>解释</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存在者</strong>（beings）</td>\n<td>具体存在的实体（人、石头、数字、情感）</td>\n<td>这把椅子、牛顿定律、你此刻的喜悦</td>\n</tr>\n<tr>\n<td><strong>存在</strong>（Being）</td>\n<td>使存在者得以存在的 <strong>根本条件</strong> 或 <strong>显现方式</strong>（非实体）</td>\n<td>椅子的 “物性”、定律的 “真理性”、喜悦的 “情绪性”</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>关键</strong>：存在论不研究 “椅子是什么”，而研究 <strong>“椅子为何能作为‘物’存在”</strong>。</p>\n</blockquote>\n<h4 id=\"2-经典问题域\"><a class=\"anchor\" href=\"#2-经典问题域\">#</a> 2. <strong>经典问题域</strong></h4>\n<ul>\n<li>存在是 <strong>一还是多</strong>？</li>\n<li>存在是 <strong>物质还是精神</strong>？</li>\n<li>存在具有 <strong>层级结构</strong> 吗？（如柏拉图：理念 &gt; 现象）</li>\n<li><strong>虚无是否存在</strong>？</li>\n</ul>\n<hr />\n<h4 id=\"二-存在论的历史演进\"><a class=\"anchor\" href=\"#二-存在论的历史演进\">#</a> 二、<strong>存在论的历史演进</strong></h4>\n<h4 id=\"1-古希腊奠基\"><a class=\"anchor\" href=\"#1-古希腊奠基\">#</a> 1. <strong>古希腊奠基</strong></h4>\n<ul>\n<li><strong>巴门尼德</strong>：存在是 “ <strong>一</strong> ”（永恒不变），非存在不可言说。</li>\n<li><strong>亚里士多德</strong>：提出 <strong>“第一哲学”</strong>（即存在论），定义存在为 <strong>“实体”</strong>（ousia），并通过 <strong>范畴</strong>（如质、量、关系）分析存在方式。</li>\n</ul>\n<h4 id=\"2-中世纪神学转向\"><a class=\"anchor\" href=\"#2-中世纪神学转向\">#</a> 2. <strong>中世纪神学转向</strong></h4>\n<ul>\n<li>存在 = <strong>上帝创造</strong>（阿奎那：存在分等级，上帝是 “纯粹存在”）。</li>\n</ul>\n<h4 id=\"3-近代认识论挤压\"><a class=\"anchor\" href=\"#3-近代认识论挤压\">#</a> 3. <strong>近代认识论挤压</strong></h4>\n<ul>\n<li>笛卡尔 → 康德：存在论问题被 <strong>认识论</strong>（人如何认识存在？）取代。\n<blockquote>\n<p>康德：存在 <strong>不是谓词</strong>（说 “上帝存在” 未增加新内容），只能通过主体范畴认知。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"4-现象学重启存在论\"><a class=\"anchor\" href=\"#4-现象学重启存在论\">#</a> 4. <strong>现象学重启存在论</strong></h4>\n<table>\n<thead>\n<tr>\n<th>哲学家</th>\n<th>突破</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>胡塞尔</strong></td>\n<td>搁置 “存在是否客观” 问题，专注 <strong>现象如何在意识中显现</strong>（意向性）。</td>\n</tr>\n<tr>\n<td><strong>海德格尔</strong></td>\n<td>⭐ <strong>存在论革命</strong>：追问 <strong>“存在本身的意义”</strong>，揭示 “此在”（人）是理解存在的通道。</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h4 id=\"三-海德格尔的存在论革命-马里翁的批判\"><a class=\"anchor\" href=\"#三-海德格尔的存在论革命-马里翁的批判\">#</a> 三、<strong>海德格尔的存在论革命 → 马里翁的批判</strong></h4>\n<h4 id=\"1-海德格尔的核心主张\"><a class=\"anchor\" href=\"#1-海德格尔的核心主张\">#</a> 1. <strong>海德格尔的核心主张</strong></h4>\n<ul>\n<li><strong>此在（Dasein）优先性</strong>：<br />\n只有人（此在）会追问存在意义，故存在论需通过 <strong>此在的生存分析</strong>（如 “在世”“向死而生”）展开。</li>\n<li><strong>存在被时间性定义</strong>：<br />\n存在不是现成实体，而是 <strong>动态的 “去存在”</strong>（becoming），其意义在时间中生成。</li>\n</ul>\n<h4 id=\"2-马里翁在还原与给予中的爆破\"><a class=\"anchor\" href=\"#2-马里翁在还原与给予中的爆破\">#</a> 2. <strong>马里翁在《还原与给予》中的爆破</strong></h4>\n<p>马里翁认为海德格尔仍陷于 <strong>隐蔽的主体中心主义</strong>：</p>\n<ul>\n<li><strong>问题</strong>：<br />\n海德格尔让 <strong>此在垄断存在意义的解释权</strong>（存在需通过此在的生存结构显现）。</li>\n<li><strong>解决方案</strong>：<br />\n用 <strong>“给予性”（givenness）取代 “存在”</strong> 作为第一哲学范畴：\n<ul>\n<li>现象（如神迹、艺术品）可 <strong>主动自我给予</strong>，溢出此在的理解框架（饱和现象）。</li>\n<li><strong>存在本身也需被给予</strong>！ → 存在不是起点，而是 <strong>给予的结果</strong>。</li>\n</ul>\n<blockquote>\n<p>“存在者必须首先 <strong>被给予</strong>，才能追问其存在” —— 这才是现象学最彻底的还原。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"四-生活化类比存在论的三种视角\"><a class=\"anchor\" href=\"#四-生活化类比存在论的三种视角\">#</a> 四、<strong>生活化类比：存在论的三种视角</strong></h4>\n<h4 id=\"场景面对一座雪山\"><a class=\"anchor\" href=\"#场景面对一座雪山\">#</a> <strong>场景</strong>：面对一座雪山</h4>\n<table>\n<thead>\n<tr>\n<th>视角</th>\n<th>存在论问题</th>\n<th>回应</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>传统哲学</strong></td>\n<td>雪山是 <strong>什么实体</strong>？</td>\n<td>“由岩石、冰雪构成的物质实体”</td>\n</tr>\n<tr>\n<td><strong>海德格尔</strong></td>\n<td>雪山如何向 <strong>此在显现存在意义</strong>？</td>\n<td>“在攀登的畏与美中，揭示自然的在场性”</td>\n</tr>\n<tr>\n<td><strong>马里翁</strong></td>\n<td>雪山如何 <strong>自我给予</strong> 其存在？</td>\n<td>“雪山的壮美 <strong>强行侵入</strong> 我的感知，使我被动接受其超越性”</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h4 id=\"五-为什么马里翁要解构存在论\"><a class=\"anchor\" href=\"#五-为什么马里翁要解构存在论\">#</a> 五、<strong>为什么马里翁要解构存在论？</strong></h4>\n<p>在《还原与给予》中，他试图证明：</p>\n<ol>\n<li>\n<p><strong>存在论的历史是遗忘 “给予性” 的历史</strong>：<br />\n从古希腊到海德格尔，哲学总将存在 <strong>预设为起点</strong>，却忽略了存在者首先需 <strong>被给予我们</strong>。</p>\n</li>\n<li>\n<p><strong>现象学应回归更本源维度</strong>：</p>\n<p>饱和现象（如十字架上的牺牲、梵高的《星空》）证明：</p>\n<ul>\n<li><strong>给予先于存在</strong>，</li>\n<li><strong>现象自身才是意义的绝对源泉</strong>。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>存在论非被废除，而是被 <strong>置于给予性之下</strong> —— 这是马里翁对现象学的彻底激进化。</p>\n</blockquote>\n<hr />\n<h3 id=\"q-7\"><a class=\"anchor\" href=\"#q-7\">#</a> Q:</h3>\n<p>怎么理解下面这段话：“如果这种对认识意义的思索所提供的不是一种单纯的意见，而是像这里所严格要求的那样，提供一种明晰的 (einsichtig) 知识，那么它就必须在被给予的思维体验和认识体验的典范性的基础上作为纯粹的本质直观来进行”</p>\n<p>A:<br />\n 这段出自胡塞尔《现象学的观念》的文本，浓缩了现象学作为<strong>严格科学</strong>的方法论核心 —— 它要求哲学必须摆脱意见（doxa），通过<strong>本质直观</strong>（Wesensschau）获得<strong>绝对明晰的知识</strong>。以下分三步拆解其逻辑：</p>\n<hr />\n<h4 id=\"一-句子结构解剖\"><a class=\"anchor\" href=\"#一-句子结构解剖\">#</a> <strong>一、句子结构解剖</strong></h4>\n<blockquote>\n<p>“如果这种对认识意义的思索……”</p>\n<ul>\n<li><strong>目标</strong>：获得 <strong>“明晰的知识”</strong>（非主观意见）</li>\n<li><strong>方法</strong>：<strong>纯粹的本质直观</strong></li>\n<li><strong>操作基础</strong>：<strong>被给予的思维体验和认识体验的典范性实例</strong></li>\n</ul>\n</blockquote>\n<hr />\n<h4 id=\"二-关键概念解析\"><a class=\"anchor\" href=\"#二-关键概念解析\">#</a> <strong>二、关键概念解析</strong></h4>\n<h4 id=\"1-明晰的知识einsichtig\"><a class=\"anchor\" href=\"#1-明晰的知识einsichtig\">#</a> 1. <strong>“明晰的知识”（einsichtig）</strong></h4>\n<ul>\n<li>不是逻辑推理的结论，而是 <strong>直接自明的真理</strong>（如同 “2+2=4” 般无可置疑）。</li>\n<li>要求 <strong>绝对清晰性</strong>，排除任何模糊、推测或传统偏见。</li>\n</ul>\n<blockquote>\n<p>💡 现象学的野心：哲学应像数学一样严密。</p>\n</blockquote>\n<h4 id=\"2-被给予的思维体验和认识体验\"><a class=\"anchor\" href=\"#2-被给予的思维体验和认识体验\">#</a> 2. <strong>“被给予的思维体验和认识体验”</strong></h4>\n<ul>\n<li><strong>思维体验</strong>（Denkerlebnisse）：具体意识活动（如怀疑、判断、想象）。</li>\n<li><strong>认识体验</strong>（Erkenntniserlebnisse）：指向真理的意识行为（如理解一个数学证明）。</li>\n<li><strong>关键</strong>：这些体验必须是 <strong>现象学还原后的纯粹现象</strong>（悬置其是否对应外部实在），仅关注其 <strong>内在被给予性</strong>。</li>\n</ul>\n<h4 id=\"3-典范性的基础上\"><a class=\"anchor\" href=\"#3-典范性的基础上\">#</a> 3. <strong>“典范性的基础上”</strong></h4>\n<ul>\n<li>需选取 <strong>典型实例</strong> 作为分析对象（如分析 “感知” 时，选一个苹果的视觉体验）。</li>\n<li>这些实例是 <strong>本质直观的跳板</strong>，类似几何学家用具体三角形把握 “三角性”。</li>\n</ul>\n<h4 id=\"4-纯粹的本质直观reine-wesensintuition\"><a class=\"anchor\" href=\"#4-纯粹的本质直观reine-wesensintuition\">#</a> 4. <strong>“纯粹的本质直观”</strong>（reine Wesensintuition）⭐</h4>\n<ul>\n<li><strong>本质直观 ≠ 经验归纳</strong>：\n<table>\n<thead>\n<tr>\n<th>经验归纳</th>\n<th>本质直观</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>从 100 个苹果观察红色</td>\n<td>从一个苹果的红色 <strong>直观 “红本身”</strong></td>\n</tr>\n</tbody>\n</table>\n</li>\n<li><strong>操作步骤</strong>：\n<ol>\n<li><strong>自由想象变更</strong>：在想象中任意修改苹果的属性（大小、形状、位置）。</li>\n<li><strong>发现不变项</strong>：当所有属性变化时，“红” 的<strong>本质内核</strong>依然恒定。</li>\n<li><strong>把握本质</strong>：这个不变项（如 “视觉延展性”“色谱定位”）就是 <strong>“红” 的本质</strong>。</li>\n</ol>\n</li>\n</ul>\n<hr />\n<h4 id=\"三-深层逻辑现象学如何成为严格科学\"><a class=\"anchor\" href=\"#三-深层逻辑现象学如何成为严格科学\">#</a> <strong>三、深层逻辑：现象学如何成为 “严格科学”？</strong></h4>\n<h4 id=\"1-对抗两种错误路径\"><a class=\"anchor\" href=\"#1-对抗两种错误路径\">#</a> 1. <strong>对抗两种错误路径</strong></h4>\n<p>| 错误类型       | 问题                     | 现象学方案               |<br />\n|----------------|--------------------------|--------------------------|<br />\n| <strong>经验主义</strong>   | 依赖感官，知识或然性     | 通过本质直观获得<strong>必然性</strong> |<br />\n| <strong>理性主义</strong>   | 脱离体验，陷入概念空转   | 以<strong>被给予的体验</strong>为地基 |</p>\n<h4 id=\"2-本质直观的合法性保障\"><a class=\"anchor\" href=\"#2-本质直观的合法性保障\">#</a> 2. <strong>本质直观的合法性保障</strong></h4>\n<ul>\n<li><strong>自明性</strong>（Evidenz）：当直观达到 <strong>无可置疑的清晰度</strong>（如你无法否认 “正在思考” 这一行为的存在），即为真理。</li>\n<li><strong>主体间可验证性</strong>：不同主体对同一本质（如 “红”）的直观结果一致（类似数学家对 “圆” 的理解相同）。</li>\n</ul>\n<h4 id=\"3-马里翁的潜在批评\"><a class=\"anchor\" href=\"#3-马里翁的潜在批评\">#</a> 3. <strong>马里翁的潜在批评</strong></h4>\n<p>胡塞尔假设本质直观 <strong>依赖主体能力</strong>（自由变更需主体执行），而马里翁主张：</p>\n<ul>\n<li>某些现象（如神圣者的显现）<strong>抗拒自由变更</strong>（无法被任意想象修改），</li>\n<li>其本质恰恰在 <strong>突破主体框架</strong> 时自我给予。</li>\n</ul>\n<blockquote>\n<p>例：基督的复活事件不可 “想象变更”，它以 <strong>绝对饱和性</strong> 给予自身本质。</p>\n</blockquote>\n<hr />\n<h4 id=\"四-生活化示例理解愤怒的本质\"><a class=\"anchor\" href=\"#四-生活化示例理解愤怒的本质\">#</a> <strong>四、生活化示例：理解 “愤怒” 的本质</strong></h4>\n<h4 id=\"传统哲学\"><a class=\"anchor\" href=\"#传统哲学\">#</a> <strong>传统哲学</strong></h4>\n<ul>\n<li>经验主义：统计 100 人发怒时的生理数据（心跳加速、脸红）→ 得出概率性结论。</li>\n<li>理性主义：用概念推演 “愤怒是理性的丧失”。</li>\n</ul>\n<h4 id=\"胡塞尔现象学操作\"><a class=\"anchor\" href=\"#胡塞尔现象学操作\">#</a> <strong>胡塞尔现象学操作</strong></h4>\n<ol>\n<li><strong>选取典范体验</strong>：回忆一次真实愤怒（如被无故指责）。</li>\n<li><strong>自由想象变更</strong>：\n<ul>\n<li>变更对象（老板 / 朋友）、场合（办公室 / 家中）、强度（暴怒 / 隐忍）...</li>\n</ul>\n</li>\n<li><strong>发现不变本质</strong>：\n<ul>\n<li>愤怒的 <strong>核心</strong> = <strong>“对不公侵犯的抗拒感”</strong>（即使对象和形式变化，此内核不变）。</li>\n</ul>\n</li>\n<li><strong>获得明晰知识</strong>：\n<ul>\n<li>这不是统计结论，而是 <strong>直观到的愤怒本质本身</strong>。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h4 id=\"五-哲学史意义现象学的科学奠基\"><a class=\"anchor\" href=\"#五-哲学史意义现象学的科学奠基\">#</a> <strong>五、哲学史意义：现象学的科学奠基</strong></h4>\n<p>胡塞尔借此宣告：</p>\n<ol>\n<li><strong>哲学知识可能</strong>：通过本质直观突破 “意见” 的泥潭。</li>\n<li><strong>操作严格性</strong>：需扎根于被给予的体验，避免形而上学空谈。</li>\n<li><strong>对马里翁的启示</strong>：\n<ul>\n<li>胡塞尔的 <strong>“被给予性”</strong> 是起点，</li>\n<li>但马里翁将其推向极致：现象自我给予的 <strong>暴力性</strong> 可摧毁主体直观框架（如饱和现象）。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>这段文本是 <strong>现象学方法论的浓缩宣言</strong> —— 它要求哲学家像科学家观察实验般 <strong>“直观” 意识的本质结构</strong>，而这正是《还原与给予》中马里翁既继承又爆破的基点。</p>\n</blockquote>\n<h3 id=\"q-8\"><a class=\"anchor\" href=\"#q-8\">#</a> Q:</h3>\n<p>怎么理解：“胡塞尔宣布了：对原初的感性感念，即对直观和感知这两个概念的不可或缺的扩展，这种扩展使得我们有权探讨范畴直观，特别是有权谈论普遍直观”</p>\n<p>A:<br />\n 胡塞尔在《逻辑研究》中提出的 <strong>“范畴直观”</strong>（categorial intuition）概念，是对传统认识论的根本性革命。这句话宣告了现象学对 “直观” 能力的 <strong>双重扩展</strong>，彻底打破了经验主义对直观的狭隘限定。以下是逐层解析：</p>\n<hr />\n<h4 id=\"一-背景传统直观理论的枷锁\"><a class=\"anchor\" href=\"#一-背景传统直观理论的枷锁\">#</a> <strong>一、背景：传统直观理论的枷锁</strong></h4>\n<h4 id=\"传统哲学经验主义康德的教条\"><a class=\"anchor\" href=\"#传统哲学经验主义康德的教条\">#</a> 传统哲学（经验主义 + 康德）的教条：</h4>\n<ol>\n<li><strong>直观仅限感性</strong>：\n<ul>\n<li>直观 = 感官直接接收的内容（颜色、声音、触感等）。</li>\n</ul>\n</li>\n<li><strong>范畴仅属理性</strong>：\n<ul>\n<li>抽象概念（如 “存在”“统一性”“因果”）需通过 <strong>知性范畴加工</strong> 感性材料获得，<strong>无法被直观</strong>。</li>\n</ul>\n<blockquote>\n<p>康德：范畴是主体的先天认知框架，现象需经其 “塑形” 才能被认识。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h4 id=\"二-胡塞尔的突破直观概念的双重扩展\"><a class=\"anchor\" href=\"#二-胡塞尔的突破直观概念的双重扩展\">#</a> <strong>二、胡塞尔的突破：直观概念的 “双重扩展”</strong></h4>\n<p>胡塞尔的核心主张：</p>\n<blockquote>\n<p><strong>直观不仅限于感性！我们还能直接 “看见” 范畴与普遍本质！</strong></p>\n</blockquote>\n<h4 id=\"扩展1从感性直观到范畴直观\"><a class=\"anchor\" href=\"#扩展1从感性直观到范畴直观\">#</a> 扩展 1：<strong>从 “感性直观” 到 “范畴直观”</strong></h4>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>对象</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>感性直观</strong></td>\n<td>具体事物的属性</td>\n<td>看见苹果的红色（感觉材料）</td>\n</tr>\n<tr>\n<td><strong>范畴直观</strong> ⭐</td>\n<td><strong>范畴关系与形式</strong></td>\n<td>直接把握 “苹果 <strong>是</strong> 红的”（“是” 的关系）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>关键案例</strong>（《逻辑研究》VI）：<br />\n当你看见 <strong>“一张白纸”</strong>：\n<ul>\n<li>感性直观：白色、矩形、光滑感。</li>\n<li><strong>范畴直观</strong>：\n<ul>\n<li>“白”<strong> 与</strong> “纸” 的 <strong>联结</strong>（“白 - 纸” 而非 “白 + 纸”），</li>\n<li>纸 <strong>作为主体</strong> 承载白色（<strong>主谓结构</strong>），</li>\n<li>整张纸 <strong>是</strong> 白的（<strong>存在判断</strong>）。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 <strong>革命性</strong>：范畴形式（如 “是”“与”“或”）<strong>本身被给予</strong>，而非主体强加！</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"扩展2从个别直观到普遍直观\"><a class=\"anchor\" href=\"#扩展2从个别直观到普遍直观\">#</a> 扩展 2：<strong>从 “个别直观” 到 “普遍直观”</strong></h4>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>对象</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>个别直观</strong></td>\n<td>单个事物</td>\n<td>看见这只苹果</td>\n</tr>\n<tr>\n<td><strong>普遍直观</strong> ⭐</td>\n<td><strong>本质或共相</strong></td>\n<td>直观 “苹果性”（所有苹果的普遍本质）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>操作方式</strong>：<strong>自由想象变更</strong>（见前文分析）\n<blockquote>\n<p>例：通过想象不同苹果（青 / 红、大 / 小），发现不变内核 ——<strong>“苹果性”</strong>（多汁果肉、核心种子等）。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"三-为什么不可或缺现象学作为严格科学的根基\"><a class=\"anchor\" href=\"#三-为什么不可或缺现象学作为严格科学的根基\">#</a> <strong>三、为什么 “不可或缺”？—— 现象学作为严格科学的根基</strong></h4>\n<p>胡塞尔扩展直观，是为了解决哲学的核心危机：</p>\n<ol>\n<li><strong>拯救逻辑与数学的客观性</strong>：\n<ul>\n<li>若 “1+1=2” 或 “A=A” 无法被直观，则它们只是主观约定。</li>\n<li><strong>范畴直观</strong>使逻辑律（如矛盾律）成为 <strong>自明的被给予者</strong>。</li>\n</ul>\n</li>\n<li><strong>为本质科学奠基</strong>：\n<ul>\n<li>数学、几何学、伦理学的研究对象（数、正义、空间）需通过 <strong>普遍直观</strong> 把握其本质。</li>\n</ul>\n</li>\n<li><strong>打破主客二元对立</strong>：\n<ul>\n<li>范畴不再仅是 “主观形式”，而是 <strong>现象自身显现的关系结构</strong>。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>马里翁在《还原与给予》中的继承</strong>：<br />\n胡塞尔证明直观可超越感性，为马里翁的 <strong>“饱和现象”</strong>（如神性显现）奠定基础 —— 若范畴可被直观，更高阶的给予为何不能？</p>\n</blockquote>\n<hr />\n<h4 id=\"四-生活化示例理解友谊\"><a class=\"anchor\" href=\"#四-生活化示例理解友谊\">#</a> <strong>四、生活化示例：理解 “友谊”</strong></h4>\n<ul>\n<li><strong>经验主义</strong>：<br />\n统计 100 对朋友的行为（吃饭、聊天频率）→ 归纳 “友谊” 特征（或然性结论）。</li>\n<li><strong>胡塞尔现象学</strong>：\n<ol>\n<li><strong>典范实例</strong>：反思你与挚友的一次深谈。</li>\n<li><strong>范畴直观</strong>：把握 “信任 <strong>与</strong> 理解”“他 <strong>为</strong> 你付出” 等关系形式。</li>\n<li><strong>普遍直观</strong>：\n<ul>\n<li>想象变更朋友身份（同学 / 同事）、事件（借钱 / 陪伴）...</li>\n<li>发现不变本质：<strong>“互为主体性的精神共在”</strong>。<br />\n→ 获得对 “友谊” 的 <strong>本质性明见</strong>（必然知识）。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<hr />\n<h4 id=\"五-哲学史意义从康德到胡塞尔的哥白尼反转\"><a class=\"anchor\" href=\"#五-哲学史意义从康德到胡塞尔的哥白尼反转\">#</a> <strong>五、哲学史意义：从康德到胡塞尔的哥白尼反转</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>康德</strong></th>\n<th><strong>胡塞尔</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>范畴是主体加工感性的工具</td>\n<td><strong>范畴是现象自身显现的形式</strong></td>\n</tr>\n<tr>\n<td>普遍性来自主体先天能力</td>\n<td><strong>普遍性被直观在现象中</strong></td>\n</tr>\n<tr>\n<td>现象符合主体</td>\n<td><strong>主体忠于现象的自我给予</strong></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>胡塞尔的宣言</strong>：<br />\n<strong>现象自身包含范畴结构！</strong> 主体只需 “看”，而非 “构造”。\n<blockquote>\n<p>这为马里翁的 <strong>“现象主权”</strong>（现象主动给予意义）埋下伏笔。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"结语直观的解放与现象学的彻底化\"><a class=\"anchor\" href=\"#结语直观的解放与现象学的彻底化\">#</a> <strong>结语：直观的解放与现象学的彻底化</strong></h4>\n<p>胡塞尔对直观的扩展，使哲学真正可能 <strong>“回到事物本身”</strong>：</p>\n<ol>\n<li><strong>砸碎枷锁</strong>：直观不再被感官禁锢，可通达关系与本质。</li>\n<li><strong>马里翁的激进推进</strong>：\n<ul>\n<li>若直观能接纳范畴与普遍者，</li>\n<li>为何不能接纳 <strong>彻底超越主体框架的饱和现象</strong>（如神的绝对他性）？</li>\n</ul>\n<blockquote>\n<p>《还原与给予》的核心使命：将直观扩展进行到底，直至现象 <strong>无条件自我给予</strong> 的深渊。<br />\nh</p>\n</blockquote>\n</li>\n</ol>\n",
            "tags": [
                "影视书籍",
                "书",
                "读书笔记"
            ]
        },
        {
            "id": "http://amentiraz.github.io/GEARS/",
            "url": "http://amentiraz.github.io/GEARS/",
            "title": "GEARS",
            "date_published": "2025-06-30T02:07:32.000Z",
            "content_html": "<p>Predicting transcriptional outcomes of novel multigene perturbations with GEARS.</p>\n<span id=\"more\"></span>\n<p>实验目的：Understanding cellular responses to genetic perturbation is central to numerous biomedical application, from identifying genetic interations involved in cancer to developing methods for regenerative medicine.</p>\n<p>挑战： The combinatorial explosion in the number of possible multigene perturbations severely limits experimental interrogation.</p>\n<p>GEARS: graph-enhanced gene activation and repression simulator. A method that integrates deep learning with a knowledge graph of gene-gene relationships to predict transcriptional responses to both single and multigene perturbations using single-cell RNA-sequencing data from perturbational screens.</p>\n<p>这段话不是很理解：The screens were run using the Perturb-seq assay, which combines a pooled screen with a single-cell RNA-sequencing readout of the entire transcriptome for each cell. 什么是 Perturb-seq assay，什么又是 pooled screen</p>\n<p>“pooled screen” 指的是把多个扰动一起进行实验，而不是一个一个单独做，节省时间和资源。</p>\n",
            "tags": [
                "论文",
                "生物",
                "学习笔记类",
                "算法"
            ]
        },
        {
            "id": "http://amentiraz.github.io/life/%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/",
            "url": "http://amentiraz.github.io/life/%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/",
            "title": "重庆之旅",
            "date_published": "2025-06-08T14:53:34.000Z",
            "content_html": "<p>重庆旅游记录</p>\n<span id=\"more\"></span>\n<p>快毕业了，正好没什么事干，闪现重庆。</p>\n<p>西安到重庆一共是 5 个多小时的高铁，高铁上看了会儿书，又昏昏欲睡，很快也到了重庆。</p>\n<p>我是暂住在我姐家，很多事情也不用操心，本来打算自己挑战一下旅游的，结果这方面都给我安排好了，少了很多麻烦。后面这个暑假还会去旅游，下次就自己搞定，实实在在的锻炼一下。</p>\n<p>晚上是去吃的烤串。和西安的不一样重庆的烤串就是点菜，西安则是店家烤好了分。烤串肉质很不错，很有嚼劲。和西安相似的是这里的烤串也是放在锡纸垫着的烤炉上，吃着也一直是热乎的。除了烤串还尝了一下烤串店卖的冰汤圆，还有小朋友很喜欢吃的一个类似于芝士焗蟹肉的小吃，也是非常不错，芝士和蟹肉的组合配合的很好，口感也爽口，小孩吃着也轻松。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin1.jpg\" alt=\"\" /><br />\n吃完烤串，我和我姐又去了重庆市规划展览馆上面去看了夜景，遗憾的是我们刚上去江对面的灯就熄了，没看到最漂亮的夜景。眺望江对岸有一种回到了上海外滩的感觉，各种各样的高楼大厦，游船在江上行驶，仔细一看楼上利用 LED 灯显示出各种各样的文字，景色也是十分不错了。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin2.jpg\" alt=\"\" /><br />\n第二天，早上去吃了重庆小面。说是重庆小面，我姐告诉我一般正宗的重庆小面都不叫重庆小面，我想也是，就像四川川菜的店铺不可能说店名就叫川菜，但奇怪的是陕西的陕菜确实标榜自己是陕菜（乐）。我们吃的那家是叫什么凳凳面，吃饭的方式也很奇特，一个大椅子用来放吃的，人坐在小凳子上吃。我点了一份豌杂面，辣度应该是标准辣。本来以为自己吃不了这种辣，结果发现还好，确实是比平时的辣度更高，但是这个辣的很有滋味，看得出来调料很有一手，观察面的话发现汤居然是黑的，这是说明它辣的发黑吗？我在西安吃过几次重庆小面，每一次都给我劝退得不行，要不然辣的遭不住，要不然面吃着一股方便面的味道，今天尝了下正宗的确实不一样。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin4.jpg\" alt=\"\" /></p>\n<p>吃了饭我们便去了山城步道，我原本以为是类似山路那样，结果路上全是商贩。吃的喝的，纪念品，走在路上不是感觉到原滋原味的重庆山城，而是重庆热情似火的商业化氛围。我和我姐吐槽，如果我评价西安是商业化太严重了，那重庆不如说只有商业化。当然也有十分不错的地方，由于山城步道离江很近所以能看到江景。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin6.jpg\" alt=\"\" /><br />\n山城步道里面还有很多小巷子，但全是商业化十分彻底，比较稀奇的甚至还看到了有人在用塔罗牌给人占卜。穿梭在各个商店之间让我感到有些无聊，但奇怪的是其它年轻的游客很有热情，巷子里塞满了各种适合拍照打卡的要素，用年轻人的话来说就是很潮（虽然我也是年轻人）。走在这条路上，感觉又很熟悉，我不仅想起当时在日本去参观清水寺还是浅水寺的时候，也是一段上坡路上路旁摆满了各种商铺。当我走进卖纪念品的店时，我竟然发现了类似于日本印账的东西，他们称呼为手账，你可以在上面盖章打卡。我一寻思这不就是日本的东西吗？当然也不大可能是日本抄袭的中国的，毕竟人家全国各地都有。我记得我在日本旅游的时候便对这种打卡形式直呼精妙，既满足了人的收藏癖，也可以时候拿来炫耀和纪念，美中不足的是我看重庆这种模型并不像日本一样现场手写，而是采用盖章的形式。这个时候我便意识到重庆的旅游景点模式，很有设计感。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin7.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin8.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin9.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin10.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin11.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin12.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin13.jpg\" alt=\"\" /></p>\n<p>话虽如此，山城步道还是有很多值得参观的地方，特别是快到尽头时的那个平台，一进去有一种进入了世外桃源的感觉，一颗巨大的树矗立在高处不仅让人浮想联翩。值得一提是，快到尽头时能看到很多猫，这些猫完全不怕人，慵懒的睡在道路旁 “任人宰割”，很少有见到完全不怕人的猫，路旁还有很多蓝色的花，没人去采摘，自然生长，重庆人的素质还是相当的高。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin14.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin15.jpg\" alt=\"\" /></p>\n<p>这里有个图书馆，我们坐在这里休息了很久，虽然要 5 块钱的门票费，但环境清幽，书籍也很多，体验还是相当不错。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin17.jpg\" alt=\"\" /></p>\n<p>吃完饭后我们去了解放碑，打算中午吃点小吃。又试了一下小汤圆，味道确实不错，有一种把冰粉换成汤圆的感觉，但是总归来说，感觉口味对我来说还是淡了。然后吃了一下这里的鬼包子，说是鬼包子其实就是小笼包，这个名字也是让人望而生畏，但包子尝起来也是很不错，肉馅是颗粒样的，可惜不能混装，只能一笼一笼的买。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin18.jpg\" alt=\"\" /></p>\n<p>我也去试着喝了一下茶颜悦色，说实话完全没有听说过这个品牌，但似乎这个又挺出名的，买的人也很多。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin19.jpg\" alt=\"\" /><br />\n尝了一下最推荐的那一款，怎么说呢，感觉有点太淡了，上面也就是普通的奶油，下面的奶茶和白开水最大的区别就是你知道自己喝的不是白开水，淡淡的味道，说不上难喝，但很难理解为什么受人追捧。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin21.jpg\" alt=\"\" /><br />\n我们下午去了三峡博物馆，人非常非常多，但可能是我的文化水平不高，看着那些文化的介绍，看看重庆的历史，从猴子开始讲起一直讲到各个国家来这里建领事馆，又讲到革命又是工业发展，场馆修着波澜壮阔，历史遗物丰富多彩，但可能是我学识短浅再加上确实没怎么认真转，怎么给人一种没什么文化底蕴的感觉呢？我不好说。但说实话，如果没什么文化底蕴，很多事情能解释的通了，其实也能下判断了，重庆的旅游业发达，是因为它人造的美很不错。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin22.jpg\" alt=\"\" /><br />\n然后是鹅岭二厂。这个名字就很奇怪，为什么一个厂都能算一个景点。来了发现，这边拍照打卡的地方很多，年轻的女性在这里拍摄照片歌颂自己的青春，我和我姐在这 city walk 穷游走路的不想走。我也是老了。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin26.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin27.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin25.jpg\" alt=\"\" /></p>\n<p>重庆和这些网红文化是双向奔赴的，互联网造就了重庆，重庆也迎合互联网，我想这也是为什么重庆文旅爆火的原因。しかし......</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin28.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin29.jpg\" alt=\"\" /></p>\n<p>终于来到了最期待也最害怕的重庆火锅，点了个微辣，就这样给我吓得都不行。之前在网上看到过别人吃重庆火锅，听说鸭肠是必点的，这次也特地点了个鸭肠，店员推荐了他们的血旺，这个也试了一下。刚开始吃的时候并没有感觉到辣，重庆的辣更多的是香辣，并不是像其他地方模仿重庆火锅一样为了辣而辣，血旺十分好吃，在我的记忆当中算是最好吃的一次了，咬下去确实是入口即化。鸭肠也很不错，特意点的脑花原本以为会很腻吃起来也很不错。但是吃到后面辣味便涌上来了，奇怪的是一般辣的受不了是感觉刺痛刺痛的那种，但这次吃却没有那种感觉，它的辣似乎被其它材料 “包裹” 住了，虽说后面没有吃完，但确实重庆火锅十分不错。</p>\n<h1 id=\"day-2\"><a class=\"anchor\" href=\"#day-2\">#</a> Day 2</h1>\n<p>早上尝了一下这边的抄手，抄手明显就要比面辣的多，吃完后我便前往龙门浩了。路上的出租车司机很热情，听我的口音后问我是不是本地人，我说我是成都的他便说川渝一家亲，后面又和我介绍重庆的历史，看得出来他对重庆很有自豪感。我说到重庆这种隔江的建筑有点像上海的外滩，他说他去过，感觉不如重庆，又说自己去过伦敦，也就那样。出租车师傅突然沉默了一下说他年轻的时候赚了很多钱，我还没恭喜他他又接着说，但是赌博，追求刺激又把钱都还回去了。我不知道该说什么，他又很激动的说，小兄弟，毒和毒千万不能碰，千万不能学我，我又能说什么呢？我说一定的。随后我们也很默契的把话题岔开，他听说我是大学生，又说起自己的儿子是空军，十分的优秀，我也为他高兴。快下车时，他说最近考勤严格，希望我给他打个好评。下车后我也是特意打开了 APP 给出了好评，也希望他生活顺利吧。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin30.jpg\" alt=\"\" /><br />\n龙门浩说实话没什么转的，也就是可能是我来的比较早的原因，商家也没有开门。说实话，我都不太明白龙门浩怎么也算个景点，倒是能看到许多艺人来这里打卡的照片，摆在路旁作为宣传。倒是龙门浩与一座桥是连在一起的，乘坐电梯可以到桥上。差不多逛完龙门浩后，我便徒步过桥前往朝天门。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin32.jpg\" alt=\"\" /><br />\n我习惯性的去旅游一个城市便去当地走走，于是我便徒步从龙门浩走到了朝天门。其实我倒觉得重庆的路边便魅力十足，错落有致的房屋，从上而下俯视便像是在攀爬山峰，这种难一见的城市景观才是重庆的一大特色。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin34.jpg\" alt=\"\" /><br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin33.jpg\" alt=\"\" /><br />\n抵达朝天门便能看到许多旅行团的，或者是网红在拍照，其实说白了就是一个平台，隔江望过去便是城市规划展览馆，临江看风景时意外还看到许多工人在下面借着建筑遮挡阳光在午睡。</p>\n<p>我去了解放碑吃了午饭，特意尝了一下酸辣粉。这玩意太辣了，味道还行但是太辣了，吃了一半便边擤鼻涕边喝水，抬头看看周围都感觉恍如隔世，头皮发麻的让人飘飘欲仙。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin41.jpg\" alt=\"\" /><br />\n下午也没看什么，去了洪崖洞周围也没有真的去洪崖洞，又点了一杯茶颜悦色，那种意料之中的淡味让人感到安心。没点茶百道但在茶百道睡了一个小时。稍作停顿便前往 Live house 去看演出了，这个部分放到另外的文章叙述。</p>\n<h1 id=\"day-3\"><a class=\"anchor\" href=\"#day-3\">#</a> Day 3</h1>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin31.jpg\" alt=\"\" /><br />\n早上去了城市规划展览馆。这个地方感觉是政府用来在正式场合对外宣传的，虽然也有大学生在逛，但能看到很多白衬衫的公务人员，也能看到外国人在听讲解员讲解。这个地方完整且正面的展示了重庆市的历史，文化，特色。逛完后我对重庆的印象好了不少。如果不是逛这个我离开了重庆也不知道大足石刻、巫峡等等也重庆的，咋不多宣传宣传这些，尽搞些网红文化。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin36.jpg\" alt=\"\" /><br />\n重庆美术馆。一眼和上海的那个美术馆差不多，外观就差不多。进去参观，大失所望。wdnmd，头一次听说美术馆的画明码标价，支持微信支付。而且这些国画说白了就是重庆美术馆的内部人员画的，委婉点来说就最开头的副馆长那幅画能看得出来有点水平，当然副馆长的画也不敢随便拍卖，其它的画我能看的出来还是可以，但是一看价格我就不太想看画了。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin37.jpg\" alt=\"\" /><br />\n二楼的画是一个叫张杰的个人展，虽然没有完全的展示，但是水平相当不错，人物的眼神，表情相当讲究，栩栩如生，看的时候我便觉得为震撼。很好的把这种普通中国人的生活表现了出来，而且能看出有自己的思想在里面，特别是《城市梦》那两张，真是非常厉害。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin40.jpg\" alt=\"\" /><br />\n下面这张也十分不错，不知道是透视的原理还是什么，整个城市像是在水面上一样，很有味道。</p>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>重庆之旅也就告一段落了</p>\n",
            "tags": [
                "生活",
                "旅游",
                "生活",
                "重庆",
                "旅游"
            ]
        },
        {
            "id": "http://amentiraz.github.io/life/MeetingJazz2025-06-01/",
            "url": "http://amentiraz.github.io/life/MeetingJazz2025-06-01/",
            "title": "MeetingJazz2025-06-01",
            "date_published": "2025-06-01T16:44:45.000Z",
            "content_html": "<p>在爵士酒吧过六一儿童节</p>\n<span id=\"more\"></span>\n<p>先说酒，点的 “大都会”，很清爽的味道，但是没什么酒味，有一种喝西柚水的味道，但那种实打实的涩味告诉我喝的是酒。酒的度数也不是很高，也没有什么变化，干干脆脆，感觉女性会更喜欢这类酒。综合打个 5 分，虽说还不错，但以后也不会点了。</p>\n<p>再说爵士现场，今天是四重奏，后面加入了人声，但时间比较赶听到 11：40 差不多我们就走了。吉他手有两个，一个年轻，一个老成。年轻的乐手的演奏很有热情，编排的很密但缺少了一些细腻的味道，老成的那位就十分厉害，无论是律动还是动态都处理的非常好，特别是在节奏舒缓的曲目更是厉害，揉弦恰到好处，即兴也很有味道。鼓手技巧很厉害，但我同行的同学对鼓手意见比较大，认为他干扰了自己听贝斯，但有一说一贝斯比较羞涩，虽说很有实力，但存在感却很低。</p>\n<p>演奏的前半场比较吵闹，有来玩的，后半场来玩的人都走了，剩下的人看得出来对爵士都很有热情，前半场不敢欢呼的在后半场补了回来，难得能看到这么浓厚的音乐氛围。</p>\n<p>看得出来这场演出，老成的那位吉他手的水平是远超其它乐手的，综合评价来说这次体验能给到 8 分，因为吉他演出确实不错。</p>\n",
            "tags": [
                "生活",
                "演奏会",
                "生活",
                "音乐"
            ]
        },
        {
            "id": "http://amentiraz.github.io/note/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E6%95%B0%E6%8D%AE/",
            "url": "http://amentiraz.github.io/note/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E6%95%B0%E6%8D%AE/",
            "title": "系统学习如何处理生物信息学数据",
            "date_published": "2025-05-20T07:14:29.000Z",
            "content_html": "<p>对于这个<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc2MtYmVzdC1wcmFjdGljZXMub3JnL3ByZWFtYmxlLmh0bWw=\">网页</span>下的知识的系统学习。</p>\n<span id=\"more\"></span>\n<h3 id=\"single-cell-rna-sequencing\"><a class=\"anchor\" href=\"#single-cell-rna-sequencing\">#</a> Single-cell RNA sequencing</h3>\n<p>Sequencing of RNA can be mainly conducted in two ways: Either by sequencing the mixed RNA from the source of interest across cells (bulk sequencing) or by sequencing the transcriptomes of the cells individually (single-cell sequencing).</p>\n<h3 id=\"transcript-quantification\"><a class=\"anchor\" href=\"#transcript-quantification\">#</a> Transcript quantification</h3>\n<p>Transcript quantification is the process of converting the raw data into an table of estimated transcript counts per gene per sample (for bulk-sequencing) or per cell (for single-cell sequencing).</p>\n",
            "tags": [
                "代码",
                "python",
                "学习笔记",
                "python"
            ]
        },
        {
            "id": "http://amentiraz.github.io/life/%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%AD%94%E7%9A%84%E5%90%AB%E4%B9%89/",
            "url": "http://amentiraz.github.io/life/%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%AD%94%E7%9A%84%E5%90%AB%E4%B9%89/",
            "title": "关于面孔的含义",
            "date_published": "2025-05-20T07:04:50.000Z",
            "content_html": "<p>对 DeepSeek 询问了关于伦理学中对于列维纳斯在面孔和外在性等方面的看法。</p>\n<span id=\"more\"></span>\n<h1 id=\"q-我想知道什么是完全现象他的法语是phenomene-de-plein-droit\"><a class=\"anchor\" href=\"#q-我想知道什么是完全现象他的法语是phenomene-de-plein-droit\">#</a> Q: 我想知道什么是完全现象，他的法语是 phenomene de plein droit</h1>\n<p>A:<br />\n 您提出的 “phénomène de plein droit”（完全现象 / 自主现象）是一个极具现象学深度的概念，需要从三个维度展开解析：</p>\n<hr />\n<h3 id=\"一-术语溯源与法语语境\"><a class=\"anchor\" href=\"#一-术语溯源与法语语境\">#</a> 一、术语溯源与法语语境</h3>\n<ol>\n<li>\n<p><strong>词源暴力</strong><br />\n “plein droit” 直译为 “充分权利”，在法律语境中指 “无需附加条件的法定资格”。移植到现象学中，<strong>萨特在《存在与虚无》<strong>中使用该词强调现象的</strong>自我授权性</strong> —— 现象不依赖他者证明其存在，其显现即是存在的确证。</p>\n</li>\n<li>\n<p><strong>现象学的权利革命</strong><br />\n与传统哲学将现象视为 “表象”（apparence）不同，<strong>梅洛 - 庞蒂在《知觉现象学》<strong>中指出：“现象不是通往本质的跳板，它就是本质栖居之地”。“完全现象” 颠覆了康德 “物自体 - 现象” 的二分，主张现象自身具有</strong>存在论上的完满性</strong>。</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"二-完全现象的四个特征\"><a class=\"anchor\" href=\"#二-完全现象的四个特征\">#</a> 二、完全现象的四个特征</h3>\n<ol>\n<li>\n<p><strong>非剩余性</strong>（Non-résiduel）<br />\n现象不隐藏任何 “背后的真理”，如 ** 列维纳斯在《别样于存在》** 所言：“他者的面容（visage）作为 phénomène de plein droit，不指向任何表象背后的灵魂，面容即是伦理命令本身”。</p>\n</li>\n<li>\n<p><strong>场域肉身性</strong>（Chair du monde）<br />\n梅洛 - 庞蒂通过 “肉身”（chair）概念说明：完全现象是<strong>身体 - 世界交织的拓扑学节点</strong>。例如疼痛不是 “神经系统信号”，而是身体空间向世界敞开的原初现象。</p>\n</li>\n<li>\n<p><strong>反构造性</strong>（Anti-constitution）<br />\n区别于胡塞尔 “意识构造现象” 的传统，** 马里翁在《既给予》** 中提出：“完全现象具有饱和性（saturation），它反向淹没意向性，迫使意识放弃构造权”。</p>\n</li>\n<li>\n<p><strong>伦理先验性</strong>（Primauté éthique）<br />\n在列维纳斯体系中，他者作为完全现象具有<strong>存在论暴力</strong>：不是 “我思故他在”，而是 “他者凝视迫使我存在”。这种伦理关系优先于认识论关系。</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"三-思想实验咖啡馆里的完全现象\"><a class=\"anchor\" href=\"#三-思想实验咖啡馆里的完全现象\">#</a> 三、思想实验：咖啡馆里的完全现象</h3>\n<p>假设您坐在巴黎花神咖啡馆，此时：</p>\n<ul>\n<li><strong>普通现象</strong>：侍应生的制服、咖啡杯的质感、邻座的笑声 —— 这些可被意向性捕获的对象</li>\n<li><strong>完全现象</strong>：\n<ol>\n<li>突然与陌生人的目光相遇，那种<strong>无法对象化的注视</strong>（列维纳斯）</li>\n<li>手中咖啡杯在疲劳时呈现的<strong>重量感突变</strong>（梅洛 - 庞蒂的 “身体图示” 重组）</li>\n<li>听见母语脏话时的<strong>语词暴力穿透</strong>（马里翁的 “饱和现象”）</li>\n</ol>\n</li>\n</ul>\n<p>这些情境中，现象<strong>挣脱了意向性框架</strong>，不再是意识的操作对象，反而成为重塑主体性的力量 —— 这正是 “完全现象” 的存在论特权。</p>\n<hr />\n<h3 id=\"四-哲学史坐标\"><a class=\"anchor\" href=\"#四-哲学史坐标\">#</a> 四、哲学史坐标</h3>\n<table>\n<thead>\n<tr>\n<th>思想家</th>\n<th>对 “完全现象” 的推进</th>\n<th>关键文本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>胡塞尔</td>\n<td>现象作为意向相关项</td>\n<td>《观念 I》</td>\n</tr>\n<tr>\n<td>海德格尔</td>\n<td>现象作为存在开显</td>\n<td>《存在与时间》</td>\n</tr>\n<tr>\n<td>列维纳斯</td>\n<td>现象作为伦理事件</td>\n<td>《总体与无限》</td>\n</tr>\n<tr>\n<td>马里翁</td>\n<td>现象作为给予性过剩</td>\n<td>《既给予》</td>\n</tr>\n</tbody>\n</table>\n<p>这个概念的演变史，折射出现象学从 “意识哲学” 到 “他者哲学” 再到 “给予性哲学” 的三次范式革命。理解 “phénomène de plein droit”，实质是把握现象学最激进的宣言：<strong>现象不再是哲学的起点，而是哲学的暴君</strong>。</p>\n<h1 id=\"q他者的他性怎么理解\"><a class=\"anchor\" href=\"#q他者的他性怎么理解\">#</a> Q: 他者的他性怎么理解</h1>\n<p>A:<br />\n 理解 “他者的他性”（alterity/altérité）是 20 世纪现象学与伦理哲学的核心命题，尤其以列维纳斯（Emmanuel Levinas）的论述最为深刻。这一概念挑战了西方哲学传统的 “同一性” 霸权，指向一种无法被自我消化、占有或同化的绝对差异。我们可以从五个维度展开：</p>\n<hr />\n<h3 id=\"一-哲学史背景从同一性暴力到他性解放\"><a class=\"anchor\" href=\"#一-哲学史背景从同一性暴力到他性解放\">#</a> 一、<strong>哲学史背景：从同一性暴力到他性解放</strong></h3>\n<ul>\n<li>\n<p><strong>传统哲学的困境</strong><br />\n自巴门尼德提出 “存在是一” 以来，西方哲学长期陷入 “同一性暴力”（violence of the Same）：将万物还原为 “我思” 的对象（笛卡尔）、绝对精神的环节（黑格尔）或权力意志的产物（尼采）。他者在此框架中只是<strong>认知的猎物</strong>。</p>\n</li>\n<li>\n<p><strong>现象学的转折点</strong><br />\n胡塞尔在《笛卡尔式沉思》中提出 “主体间性”（intersubjectivity），试图通过 “移情” 理解他者，但仍将他者视为 “另一个自我”（alter ego）—— 这本质上仍是<strong>自我的殖民化投射</strong>。</p>\n</li>\n<li>\n<p><strong>列维纳斯的颠覆</strong><br />\n “他性” 概念彻底扭转了这一逻辑：<strong>不是 “我理解他者”，而是 “他者质询我”</strong>。他者的存在先于我的理解，其不可还原的异质性成为伦理关系的起点。</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"二-他性的核心内涵四项不可还原性\"><a class=\"anchor\" href=\"#二-他性的核心内涵四项不可还原性\">#</a> 二、<strong>他性的核心内涵：四项不可还原性</strong></h3>\n<ol>\n<li>\n<p><strong>面容的不可见性</strong>（Invisibilité du visage）<br />\n列维纳斯在《总体与无限》中指出：“他者的面容（visage）拒绝被视觉捕获”。当我们凝视面容时，看到的不是五官的组合，而是一种<strong>伦理命令</strong> ——“汝不可杀人”（Tu ne tueras point）。面容超越表象，成为他性的肉身化符号。</p>\n</li>\n<li>\n<p><strong>时间的断裂性</strong>（Rupture temporelle）<br />\n他者的时间与我的时间<strong>不同步</strong>。在对话中，他者话语的 “此刻” 永远迟于我的预期，这种时差构成<strong>绝对的意外性</strong>，如同德里达所言：“他者的到来总是‘太迟’却又‘尚未’”。</p>\n</li>\n<li>\n<p><strong>语言的不可翻译性</strong>（Intraduisibilité）<br />\n即使使用同一种语言，他者的言说始终携带<strong>剩余意义</strong>。列维纳斯用犹太教 “托拉”（Torah）的诠释传统作喻：经文的意义永远超出注释，他者的话语是 “能指的溢出”。</p>\n</li>\n<li>\n<p><strong>存在的非对称性</strong>（Asymétrie existentielle）<br />\n我对他者的责任<strong>无需对等回报</strong>。这种伦理关系像陀思妥耶夫斯基笔下的 “为所有人承担罪责”，或是《塔木德》中 “他人的血比你自己的血更红”—— 他者的优先性瓦解了黑格尔式的主奴辩证法。</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"三-他性的伦理转向从认识论到责任\"><a class=\"anchor\" href=\"#三-他性的伦理转向从认识论到责任\">#</a> 三、<strong>他性的伦理转向：从认识论到责任</strong></h3>\n<ul>\n<li>\n<p><strong>伦理作为第一哲学</strong><br />\n列维纳斯将伦理学置于本体论之前：“在他者面前，存在被质疑”。这不是道德规训，而是<strong>存在方式的根本转变</strong> —— 他者的他性迫使我从 “自我保存” 转向 “为他者存在”。</p>\n</li>\n<li>\n<p><strong>责任的无限性</strong><br />\n “我对他者的责任比所有责任更责任”（《别样于存在》）。这种责任不设边界：纳粹集中营的看守对犹太囚犯的责任，并不少于母亲对孩子的责任。他性在此成为<strong>存在之重</strong>的源头。</p>\n</li>\n<li>\n<p><strong>替代（Substitution）的激进性</strong><br />\n最极端的他性体验体现为 “为他者受难”：当他人饥饿时，“我的胃在痉挛”（列维纳斯）。这种身体性的共感超越同情，直指<strong>存在的替代结构</strong> ——“我” 的位置永远可能被他者占据。</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"四-现象学谱系中的他性之争\"><a class=\"anchor\" href=\"#四-现象学谱系中的他性之争\">#</a> 四、<strong>现象学谱系中的他性之争</strong></h3>\n<table>\n<thead>\n<tr>\n<th>思想家</th>\n<th>对他性的态度</th>\n<th>关键隐喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>胡塞尔</td>\n<td><strong>温和他性</strong>：他者是 “另一个我”</td>\n<td>镜子中的倒影</td>\n</tr>\n<tr>\n<td>海德格尔</td>\n<td><strong>共在他性</strong>：在 “共在”（Mitsein）中稀释差异</td>\n<td>森林中的小径</td>\n</tr>\n<tr>\n<td>萨特</td>\n<td><strong>对抗他性</strong>：“他人即地狱”</td>\n<td>窥视与被窥视</td>\n</tr>\n<tr>\n<td>列维纳斯</td>\n<td><strong>绝对他性</strong>：他者是 “无限”（Infini）</td>\n<td>沙漠中的面容</td>\n</tr>\n</tbody>\n</table>\n<p>此表显示：列维纳斯的他性理论是对存在主义传统的爆破，将现象学从 “存在的焦虑” 推向 “伦理的震颤”。</p>\n<hr />\n<h3 id=\"五-他性的当代启示\"><a class=\"anchor\" href=\"#五-他性的当代启示\">#</a> 五、<strong>他性的当代启示</strong></h3>\n<ul>\n<li>\n<p><strong>技术社会的他性危机</strong><br />\n社交媒体将他人简化为数据点，算法推荐制造 “同温层”—— 这本质是<strong>他性的数字化谋杀</strong>。列维纳斯的警示在此愈发尖锐：当面容被转化为头像，伦理责任如何可能？</p>\n</li>\n<li>\n<p><strong>生态哲学的新维度</strong><br />\n深层生态学将 “他性” 扩展到非人类存在：一座山的沉默、一只鲸鱼的歌声，是否也携带不可还原的他性？这挑战了人类中心主义的伦理框架。</p>\n</li>\n<li>\n<p><strong>跨文化对话的伦理基础</strong><br />\n在文化冲突中，他性要求我们放弃 “理解他人” 的傲慢，转而保持 “不可理解的敬畏”。正如犹太教对 “不可 pronunciar 的神名”（יהוה）的态度 —— 他者的神圣性正在于其不可言说。</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"结语他性作为存在的伤口\"><a class=\"anchor\" href=\"#结语他性作为存在的伤口\">#</a> 结语：他性作为存在的伤口</h3>\n<p>列维纳斯的他性不是哲学概念，而是<strong>存在的创伤体验</strong>。它像一道永不愈合的伤口，提醒我们：真正的伦理生活不是 “与他人和解”，而是 “为他者流血”。在这个意义上，他性的不可理解性，恰恰是我们逃离自我牢狱的唯一通道。</p>\n<h1 id=\"q为什么汝不可杀人\"><a class=\"anchor\" href=\"#q为什么汝不可杀人\">#</a> Q: 为什么汝不可杀人</h1>\n<p>A:</p>\n<p>从列维纳斯（Emmanuel Levinas）的现象学伦理学视角看，“汝不可杀人”（Tu ne tueras point）这一诫命并非简单的道德律令，而是一种 <strong>存在论层面的伦理原初事件</strong>。它根植于他者的 “面容”（visage）对主体的绝对召唤，是对西方哲学传统中 “自我中心主义” 的彻底颠覆。以下分步骤解析：</p>\n<hr />\n<h3 id=\"一-面容的现象学分析他者的暴力性在场\"><a class=\"anchor\" href=\"#一-面容的现象学分析他者的暴力性在场\">#</a> 一、<strong>面容的现象学分析：他者的暴力性在场</strong></h3>\n<ol>\n<li>\n<p><strong>面容的非对象性</strong><br />\n列维纳斯在《总体与无限》中指出，他者的面容是 <strong>“不能被主题化”</strong> 的。它不是一张可被观察、描述或概念化的 “脸”（如生物学意义上的五官组合），而是 <strong>一种直接刺入我存在的伦理命令</strong>。当我试图用视觉捕捉面容时，它立刻溢出我的认知框架 —— 面容的 <strong>脆弱性</strong>（皮肤下跳动的血管、瞳孔中反射的光）和 <strong>裸露性</strong>（毫无防御的敞开）构成了一种 <strong>无声的控诉</strong>，迫使我意识到：</p>\n<blockquote>\n<p>“在面容中，他者以绝对的被动性抵抗我的权力 —— 这种抵抗本身就是伦理的显现。”</p>\n</blockquote>\n</li>\n<li>\n<p><strong>面容的 “汝不可杀人”</strong><br />\n 面容的显现天然携带禁令。列维纳斯强调：</p>\n<blockquote>\n<p>“面容的第一句话就是‘汝不可杀人’。”<br />\n 这不是宗教或法律的规训，而是 <strong>存在论上的先验结构</strong>。在凝视面容的瞬间，杀戮的 <strong>可能性</strong> 与 <strong>不可能性</strong> 同时爆发：</p>\n</blockquote>\n<ul>\n<li><strong>可能性</strong>：我握有物理能力杀死他者（如掐住喉咙）；</li>\n<li><strong>不可能性</strong>：面容的伦理在场已预先消解了这种暴力的合法性，杀人成为 <strong>存在论的自杀</strong>（因我的主体性依赖于他者的召唤）。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"二-伦理的优先性存在被质疑\"><a class=\"anchor\" href=\"#二-伦理的优先性存在被质疑\">#</a> 二、<strong>伦理的优先性：存在被质疑</strong></h3>\n<ol>\n<li>\n<p><strong>伦理学先于本体论</strong><br />\n列维纳斯颠倒了传统哲学的秩序。对他而言，<strong>伦理关系</strong>（与他者的面对面）比 “存在之思” 更根本：</p>\n<blockquote>\n<p>“在他者面前，我的存在本身成为问题。”<br />\n 当面容显现时，自我中心的 “存在意志”（conatus essendi）—— 即海德格尔式的 “向死存在” 或斯宾诺莎的 “自我保存”—— 突然被 <strong>伦理的震颤</strong> 打断。我被迫从 “为自身存在” 转向 “为他者存在”。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>责任的无限性</strong><br />\n “汝不可杀人” 不是对具体行为的禁止，而是对 <strong>无限责任</strong> 的揭示：</p>\n<ul>\n<li>他者的脆弱性要求我承担 <strong>不对称的责任</strong>（即使他者伤害我，我也无权报复）；</li>\n<li>这种责任不设边界，如列维纳斯所言：\n<blockquote>\n<p>“我对他者的责任比所有责任更责任，比所有义务更义务。”（《别样于存在》）<br />\n例如：在集中营里，纳粹看守对犹太囚犯的责任，并不亚于母亲对孩子的责任 —— 因为责任源于他者的绝对他性，而非社会关系或情感纽带。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"三-杀戮的哲学本质对无限性的谋杀\"><a class=\"anchor\" href=\"#三-杀戮的哲学本质对无限性的谋杀\">#</a> 三、<strong>杀戮的哲学本质：对无限性的谋杀</strong></h3>\n<ol>\n<li>\n<p><strong>暴力如何可能？</strong><br />\n列维纳斯承认，现实中的杀戮屡见不鲜，但这恰恰证明了人性的 <strong>堕落</strong>。当人实施杀戮时，本质上是企图 <strong>将他者还原为同一</strong>（the Same）：</p>\n<ul>\n<li>通过暴力将他者变成 “尸体”（一个可操纵的物体）；</li>\n<li>抹除他者的 “言说”（dire）能力，使其沉默为 “被言说者”（dit）。<br />\n这种还原是 <strong>存在论层面的犯罪</strong>，因为它否定了他者作为 “无限”（Infini）的超越性。</li>\n</ul>\n</li>\n<li>\n<p><strong>自杀的逻辑悖论</strong><br />\n列维纳斯甚至指出：</p>\n<blockquote>\n<p>“杀人者所杀的，正是那个唯一能赋予他杀人‘意义’的存在。”<br />\n 因为只有当他者作为伦理命令的来源在场时，杀戮才具有 “恶” 的维度；一旦他者被杀，杀人者也失去了自身作为 <strong>伦理主体</strong> 的资格，沦为动物性的暴力存在。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h3 id=\"四-替代substitution为他者受难的极端伦理\"><a class=\"anchor\" href=\"#四-替代substitution为他者受难的极端伦理\">#</a> 四、<strong>替代（Substitution）：为他者受难的极端伦理</strong></h3>\n<p>列维纳斯在后期著作中提出更激进的 “替代” 概念：</p>\n<blockquote>\n<p>“我始终是他人的人质。”（《别样于存在》）</p>\n</blockquote>\n<ul>\n<li><strong>身体层面的替代</strong>：当他者饥饿时，“我的胃在痉挛”；当他者受苦时，“我的皮肤在灼烧”。这种感受不是同情，而是 <strong>存在论上的替代结构</strong> —— 我的身体成为他者痛苦的容器。</li>\n<li><strong>责任的创伤性</strong>：替代不是自愿的选择，而是一种 <strong>被动的承受</strong>。正如约伯无缘无故受难，伦理责任也是无理由的强加。这种 “创伤” 恰恰证明了责任的 <strong>神圣性</strong>。</li>\n</ul>\n<hr />\n<h3 id=\"五-对传统哲学的爆破\"><a class=\"anchor\" href=\"#五-对传统哲学的爆破\">#</a> 五、<strong>对传统哲学的爆破</strong></h3>\n<p>列维纳斯的 “汝不可杀人” 彻底挑战了西方哲学的根基：</p>\n<ol>\n<li><strong>对抗黑格尔</strong>：否定 “主奴辩证法” 中的承认斗争，强调责任先于自由。</li>\n<li><strong>超越海德格尔</strong>：拒绝 “共在”（Mitsein）的温情，坚持他者的不可消化性。</li>\n<li><strong>批判康德</strong>：义务不再来自理性自律，而是他者面容的强制命令。</li>\n</ol>\n<hr />\n<h3 id=\"结语作为存在之伤的伦理\"><a class=\"anchor\" href=\"#结语作为存在之伤的伦理\">#</a> 结语：作为存在之伤的伦理</h3>\n<p>对列维纳斯而言，“汝不可杀人” 不是道德说教，而是 <strong>存在的伤口</strong>。它揭示了一个残酷的真相：</p>\n<blockquote>\n<p><strong>人类的高贵不在于征服他者，而在于为他者流血。</strong><br />\n当面容刺入我的世界时，我不再是自足的主体，而是沦为 <strong>他者的人质</strong> —— 这种伦理的 “被动性”，恰恰是人性最后的避难所。</p>\n</blockquote>\n<h1 id=\"q-什么是外在性\"><a class=\"anchor\" href=\"#q-什么是外在性\">#</a> Q: 什么是外在性</h1>\n<p>A:<br />\n<strong> 外在性（Exteriority）在列维纳斯哲学中的核心阐释</strong></p>\n<p>在列维纳斯（Emmanuel Levinas）的现象学伦理学中，<strong>外在性</strong>（Exteriorité/Exteriority）是一个颠覆传统哲学的核心概念，指向他者（the Other）不可被自我（the Self）同化、占有或还原的绝对异质性。它挑战了西方哲学中 “同一性”（the Same）的霸权，强调他者始终外在于自我的认知与权力体系，构成伦理责任的根源。以下从多个维度展开分析：</p>\n<hr />\n<h3 id=\"一-哲学史背景对同一性的批判\"><a class=\"anchor\" href=\"#一-哲学史背景对同一性的批判\">#</a> 一、<strong>哲学史背景：对 “同一性” 的批判</strong></h3>\n<ol>\n<li>\n<p><strong>传统哲学的困境</strong><br />\n自柏拉图至黑格尔，西方哲学倾向于将一切存在纳入 “同一性” 的框架，通过理性将差异消解为总体（Totality）。他者被简化为自我的镜像（如黑格尔的 “他者即自我的否定”），或知识的对象（如胡塞尔的 “移情” 理论）。</p>\n<ul>\n<li><strong>列维纳斯的突破</strong>：外在性彻底否定这种 “同一性暴力”，主张他者的存在先于且外在于自我的理解，其异质性不可被概念化或总体化。</li>\n</ul>\n</li>\n<li>\n<p><strong>与存在主义的区别</strong><br />\n萨特的 “他人即地狱” 仍将他者视为威胁自我自由的对抗性存在，而列维纳斯的外在性强调他者的<strong>伦理优先性</strong> —— 他者不是威胁，而是对自我提出无条件责任的召唤。</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"二-外在性的核心特征\"><a class=\"anchor\" href=\"#二-外在性的核心特征\">#</a> 二、<strong>外在性的核心特征</strong></h3>\n<ol>\n<li>\n<p><strong>不可还原的异质性（Irreducible Alterity）</strong><br />\n他者不能被纳入自我的意识结构或语言体系。例如，面对他者的<strong>面容</strong>（visage），我们无法将其简化为视觉对象或心理表征，其存在始终溢出认知框架，构成一种 “存在的溢出”（excess of being）。</p>\n</li>\n<li>\n<p><strong>无限的超越性（Infinite Transcendence）</strong><br />\n外在性与他者的 “无限性”（Infinity）紧密关联。列维纳斯借用笛卡尔的 “无限观念” 指出：</p>\n<blockquote>\n<p>“无限不是被思考的对象，而是思考的条件。”<br />\n 他者的无限性迫使自我承认自身的有限性，从而打破封闭的主体性。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>伦理的被动性（Ethical Passivity）</strong><br />\n外在性要求自我以<strong>被动性</strong>回应他者。这种被动性非消极，而是伦理责任的起点 —— 在他者的面容前，自我无法选择是否回应，只能被责任 “扣押”（obsession）。</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"三-外在性的现象学呈现面容与言说\"><a class=\"anchor\" href=\"#三-外在性的现象学呈现面容与言说\">#</a> 三、<strong>外在性的现象学呈现：面容与言说</strong></h3>\n<ol>\n<li>\n<p><strong>面容（Visage）作为外在性的具象化</strong></p>\n<ul>\n<li>面容不是物理意义上的脸，而是他者存在的直接显现。它的<strong>脆弱性</strong>（如皮肤下跳动的血管）与<strong>裸露性</strong>（无防御的敞开）发出无声的伦理命令：“汝不可杀人”（Tu ne tueras point）。</li>\n<li>面容的显现是<strong>非暴力的暴力</strong> —— 它不通过力量压制，却以脆弱性瓦解自我的权力意志。</li>\n</ul>\n</li>\n<li>\n<p><strong>言说（Dire）与所说（Dit）的张力</strong></p>\n<ul>\n<li><strong>言说</strong>（Dire）：他者的语言作为外在性的动态表达，始终携带未被说出的意义，拒绝被固化为 “所说”（Dit，即命题化、主题化的内容）。</li>\n<li><strong>语言的超越性</strong>：他者的言说如犹太教《塔木德》的诠释传统，永远留有意义的剩余，迫使自我放弃对意义的垄断。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"四-外在性的伦理意涵\"><a class=\"anchor\" href=\"#四-外在性的伦理意涵\">#</a> 四、<strong>外在性的伦理意涵</strong></h3>\n<ol>\n<li>\n<p><strong>责任先于自由</strong><br />\n列维纳斯颠倒了传统伦理学的根基：不是自由选择产生责任，而是他者的外在性<strong>强加责任</strong>于自我。这种责任是：</p>\n<ul>\n<li><strong>不对称的</strong>：无需他者回报；</li>\n<li><strong>无限的</strong>：超越具体情境的算计；</li>\n<li><strong>创伤性的</strong>：如 “人质” 般被劫持，被迫为他者承担一切。</li>\n</ul>\n</li>\n<li>\n<p><strong>替代（Substitution）：存在的极端形式</strong></p>\n<ul>\n<li>外在性在伦理层面体现为 “为他者受难”。列维纳斯提出：\n<blockquote>\n<p>“我即是他者的人质。”<br />\n 例如，当他者饥饿时，“我的胃在痉挛”—— 这不是共情，而是存在论上的替代，自我成为他者痛苦的载体。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"五-外在性与现代性反思\"><a class=\"anchor\" href=\"#五-外在性与现代性反思\">#</a> 五、<strong>外在性与现代性反思</strong></h3>\n<ol>\n<li>\n<p><strong>技术社会的危机</strong><br />\n在算法与大数据时代，他者被简化为数据点（如社交媒体的 “用户画像”），外在性被数字化的 “同一性” 吞噬。列维纳斯警示：失去外在性，意味着伦理关系的消亡。</p>\n</li>\n<li>\n<p><strong>生态伦理的扩展</strong><br />\n外在性可延伸至非人类存在（如动物、自然），挑战人类中心主义。一座山的沉默或一只动物的凝视，是否也携带不可还原的外在性？这为深层生态学提供了哲学基础。</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"六-列维纳斯与相关哲学家的对比\"><a class=\"anchor\" href=\"#六-列维纳斯与相关哲学家的对比\">#</a> 六、<strong>列维纳斯与相关哲学家的对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>哲学家</th>\n<th>核心概念</th>\n<th>与外在性的关系</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>黑格尔</td>\n<td>主奴辩证法</td>\n<td>他者被同一性消解，外在性被否定</td>\n</tr>\n<tr>\n<td>胡塞尔</td>\n<td>主体间性</td>\n<td>他者作为 “另一个自我”，外在性被弱化</td>\n</tr>\n<tr>\n<td>海德格尔</td>\n<td>共在（Mitsein）</td>\n<td>他者融入存在结构，外在性被稀释</td>\n</tr>\n<tr>\n<td>萨特</td>\n<td>他人即地狱</td>\n<td>外在性沦为对抗性，失去伦理维度</td>\n</tr>\n<tr>\n<td>德里达</td>\n<td>延异（Différance）</td>\n<td>外在性被解构为符号差异，缺乏伦理强制</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h3 id=\"结语外在性作为存在的救赎\"><a class=\"anchor\" href=\"#结语外在性作为存在的救赎\">#</a> 结语：外在性作为存在的救赎</h3>\n<p>列维纳斯的外在性不仅是一个哲学概念，更是对现代性危机的诊断与解药。在自我膨胀、他者消逝的今天，外在性提醒我们：<br />\n<strong>真正的伦理生活，始于承认他者永远外在于我的掌控，并甘愿为其付出无限责任。</strong><br />\n这种 “被动性” 非但不是弱点，反而是人性对抗虚无的最后堡垒。</p>\n<h1 id=\"q简单介绍一下对列维纳斯这套理论的批判\"><a class=\"anchor\" href=\"#q简单介绍一下对列维纳斯这套理论的批判\">#</a> Q：简单介绍一下对列维纳斯这套理论的批判</h1>\n<p>A:</p>\n<p>列维纳斯的伦理学尽管深刻，但也面临多方批判。以下是几个主要批判方向，结合具体例子说明：</p>\n<hr />\n<h3 id=\"一-抽象性困境脱离具体历史与社会\"><a class=\"anchor\" href=\"#一-抽象性困境脱离具体历史与社会\">#</a> 一、<strong>抽象性困境：脱离具体历史与社会</strong></h3>\n<ol>\n<li>\n<p><strong>真空中的伦理</strong><br />\n批判者（如齐泽克）指出，列维纳斯将伦理简化为 “面对面” 的抽象关系，<strong>忽视权力结构</strong>。例如：</p>\n<ul>\n<li>一个贫民窟儿童与跨国资本家的 “面容相遇” 中，结构性的剥削被伦理责任遮蔽。</li>\n<li>列维纳斯未回答：当 “他者” 是系统性暴力的受益者时，无限责任是否合理？</li>\n</ul>\n</li>\n<li>\n<p><strong>历史创伤的缺席</strong><br />\n列维纳斯虽受大屠杀影响，但理论未直面<strong>历史具体性</strong>。汉娜・阿伦特批评：</p>\n<blockquote>\n<p>“对纳粹刽子手谈‘汝不可杀人’，等于纵容邪恶。”<br />\n 伦理的绝对性可能消解对结构性不义的抵抗。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h3 id=\"二-政治无能从伦理到实践的断裂\"><a class=\"anchor\" href=\"#二-政治无能从伦理到实践的断裂\">#</a> 二、<strong>政治无能：从伦理到实践的断裂</strong></h3>\n<ol>\n<li>\n<p><strong>责任 vs 正义</strong><br />\n列维纳斯强调个体对 “他者” 的责任，但未解决<strong>多重他者的冲突</strong>。例如：</p>\n<ul>\n<li>巴勒斯坦人与以色列人互相视对方为 “他者”，无限责任如何转化为政治方案？</li>\n<li>南希・弗雷泽指出：“当多个他者的诉求冲突时，列维纳斯缺乏分配正义的原则。”</li>\n</ul>\n</li>\n<li>\n<p><strong>非暴力的悖论</strong><br />\n列维纳斯反对一切暴力，但现实中抵抗压迫常需暴力（如反殖民斗争）。弗朗茨・法农批评：</p>\n<blockquote>\n<p>“被殖民者的暴力，是对殖民者‘杀人禁令’早已失效的回应。”<br />\n 绝对非暴力可能沦为对压迫的默许。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h3 id=\"三-性别盲区女性主义的批判\"><a class=\"anchor\" href=\"#三-性别盲区女性主义的批判\">#</a> 三、<strong>性别盲区：女性主义的批判</strong></h3>\n<ol>\n<li>\n<p><strong>男性中心的伦理</strong><br />\n露西・伊丽格瑞指出，列维纳斯的 “他者” 实质是<strong>男性化的他者</strong>：</p>\n<ul>\n<li>女性作为 “他者之他者”（如母亲、妻子）被排除在伦理场景外。</li>\n<li>面容的脆弱性隐喻强化女性 “被动受害” 的刻板形象。</li>\n</ul>\n</li>\n<li>\n<p><strong>母性经验的矛盾</strong><br />\n列维纳斯用 “母性” 比喻替代性责任（“为他者受难”），但女性主义者朱迪斯・巴特勒反驳：</p>\n<blockquote>\n<p>“这浪漫化了母性的牺牲，掩盖了真实生育中的权力不对等。”</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h3 id=\"四-哲学内部的矛盾\"><a class=\"anchor\" href=\"#四-哲学内部的矛盾\">#</a> 四、<strong>哲学内部的矛盾</strong></h3>\n<ol>\n<li>\n<p><strong>语言背叛</strong><br />\n德里达在《暴力与形而上学》中指出：列维纳斯用哲学语言（一种 “总体化” 工具）言说 “不可言说的他者”，陷入<strong>自我解构</strong>：</p>\n<blockquote>\n<p>“试图用概念捕捉外在性，恰是对外在性的谋杀。”</p>\n</blockquote>\n</li>\n<li>\n<p><strong>犹太性的困境</strong><br />\n列维纳斯将犹太教伦理普世化，但批评者（如巴迪欧）认为这是<strong>特殊主义的伪装</strong>：</p>\n<ul>\n<li>“无限责任” 实质是犹太选民意识的世俗版本，缺乏跨文化有效性。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"五-生态批判人类中心主义的阴影\"><a class=\"anchor\" href=\"#五-生态批判人类中心主义的阴影\">#</a> 五、<strong>生态批判：人类中心主义的阴影</strong></h3>\n<ol>\n<li>\n<p><strong>非人类他者的缺席</strong><br />\n列维纳斯的他者仅限于人类，<strong>动物、自然被排除在伦理领域外</strong>。生态哲学家蒂莫西・莫顿质问：</p>\n<blockquote>\n<p>“一座因石油开采而消失的冰川，是否拥有‘面容’？”</p>\n</blockquote>\n</li>\n<li>\n<p><strong>技术物的伦理地位</strong><br />\n人工智能、仿生人等 “非人他者” 的出现，暴露其理论的局限性：</p>\n<ul>\n<li>如果 AI 的 “面容” 发出伦理命令，人类是否有责任服从？</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"总结批判的价值与理论的边界\"><a class=\"anchor\" href=\"#总结批判的价值与理论的边界\">#</a> 总结：批判的价值与理论的边界</h3>\n<p>这些批判并非否定列维纳斯的贡献，而是揭示其理论的<strong>历史局限与内在紧张</strong>。关键在于：</p>\n<ul>\n<li><strong>伦理的纯粹性 vs 现实的复杂性</strong>：当责任无限性与具体情境冲突时，如何抉择？</li>\n<li><strong>个体的神圣性 vs 集体的正义</strong>：当拯救一个他者需牺牲更多他者时，伦理是否失效？</li>\n</ul>\n<p>列维纳斯的真正遗产，或许不在于提供答案，而在于迫使我们在一个 “他者” 日渐被数据、资本与权力吞噬的时代，<strong>不断追问伦理的可能性与代价</strong>。</p>\n",
            "tags": [
                "生活",
                "思考",
                "列维纳斯",
                "现象学",
                "GPT"
            ]
        },
        {
            "id": "http://amentiraz.github.io/life/%E5%8F%A5%E5%AD%90%E6%91%98%E5%BD%95/",
            "url": "http://amentiraz.github.io/life/%E5%8F%A5%E5%AD%90%E6%91%98%E5%BD%95/",
            "title": "句子摘录",
            "date_published": "2025-05-11T07:49:06.000Z",
            "content_html": "<p>平时看到的一些好的句子就记录在这里面吧。</p>\n<span id=\"more\"></span>\n<p>Everything in the universe is within you, Ask all from yourself. -- 鲁米</p>\n<hr />\n<p>“我的社交能力还不如 5 岁的儿童和狗” -- 《孤独摇滚》</p>\n<hr />\n<p>你从不曾爱过我，你只爱我在你的生命中坠落。 -- 李娟</p>\n<hr />\n<p>“一直以来，似乎在关键的时刻，我大约都是选择困难的道理。”</p>\n<p>“在一种疏离感中获得意外的自由”</p>\n<p>-- 坂本龙一</p>\n<hr />\n<p>就让我在别人眼中虚伪吧，如果我对自己忠诚。 -- 艾米莉・勃朗特</p>\n<hr />\n<p>我宁愿和你一起奔向毁灭，也不愿意体验舒适的孤独。 -- 加缪</p>\n<hr />\n",
            "tags": [
                "生活",
                "摘录",
                "摘录"
            ]
        },
        {
            "id": "http://amentiraz.github.io/article/scPerturb/",
            "url": "http://amentiraz.github.io/article/scPerturb/",
            "title": "scPerturb",
            "date_published": "2025-05-11T02:16:23.000Z",
            "content_html": "<p>scPerturb: harmonized single-cell perturbation data.</p>\n<span id=\"more\"></span>\n<p>第一次接触这个领域，仔细的研读一下。</p>\n<h1 id=\"abstract\"><a class=\"anchor\" href=\"#abstract\">#</a> Abstract</h1>\n<p>这篇文章应用了 uniform quality control pipelines 和 harmonize feature annotations. 然后对于它的模型 scPerturb 的目的是 facilitates comparison and integration across datasets. 它们描述了一个 energy statistics (E-statistics) 去衡量 perturbation 和显著性检验。</p>\n<p>This work provides an information resource for researchers working with single-cell perturbation data and recommendations for experimental design, including optimal cell counts and read depth.</p>\n<h1 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> Introduction</h1>\n<p>Perturbation experiments probe the response of cells or cellular systems to changes in conditions.</p>\n<p>Nowadays, with advanced functional genomics techniques, single-cell genetic perturbations acting on individual cellular components are available. Perturbations using different technologies target different layers of the hierarchy of protein production.</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/41592_2023_2144_Fig1_HTML.webp\" alt=\"\" /><br />\n这里解释一下这张图，上面提到的 different technologies 指的是例如 CRISPR-cas9、CRISPRi 这些东西。比如 CRISPR-cas9 它在基因上直接做增删，CRISPRi 和 CRISPRa 分别抑制和激活转录 (transcription)，CRISPR-cas13 切割 RNA，一些小分子的药物影响蛋白质产物例如酶和受体。</p>\n<p>然后是比较关键的一句话： Barcodes associated with unique CRISPR guide perturbations are read alongside single-cell RNA sequencing (scRNA-seq), CITE-seq (cellular indexing of transcriptomes and epitopes by sequencing) or scATAC-seq (single-cell sequencing assay for transposase-accessible chromatin) to identify each cell’s perturbation condition.</p>\n<p>感觉很难理解上面这句话，我拿 GPT 跑了一个解释。</p>\n<details class=\"danger\"><summary>三种数据</summary><div>\n<p>下面分别对这三种单细胞多组学技术做详细介绍，包括它们的基本原理、实验流程、优势与局限，以及典型应用场景。</p>\n<hr />\n<h2 id=\"1-single-cell-rna-sequencing-scrna-seq\"><a class=\"anchor\" href=\"#1-single-cell-rna-sequencing-scrna-seq\">#</a> 1. Single-cell RNA sequencing (scRNA-seq)</h2>\n<h3 id=\"基本原理\"><a class=\"anchor\" href=\"#基本原理\">#</a> 基本原理</h3>\n<p>scRNA-seq 用于在单细胞水平上定量每个细胞的转录组（mRNA）表达。它能够揭示细胞间在基因表达谱上的异质性，识别不同细胞类型、细胞状态和发育轨迹。</p>\n<h3 id=\"实验流程\"><a class=\"anchor\" href=\"#实验流程\">#</a> 实验流程</h3>\n<ol>\n<li>\n<p><strong>单细胞分离</strong></p>\n<ul>\n<li>微流控芯片（如 10x Genomics Chromium）或滴式微流控（Drop-seq、inDrop）将单个细胞包封于微小液滴或孔室中。</li>\n</ul>\n</li>\n<li>\n<p><strong>细胞裂解与逆转录</strong></p>\n<ul>\n<li>每个液滴内加入含有细胞条形码（cell barcode）和分子标签（UMI, unique molecular identifier）的引物，裂解细胞并逆转录生成带有条形码的 cDNA。</li>\n</ul>\n</li>\n<li>\n<p><strong>文库构建与测序</strong></p>\n<ul>\n<li>将所有液滴中的 cDNA 汇合，进行扩增、建库并上机高通量测序（Illumina）。</li>\n</ul>\n</li>\n<li>\n<p><strong>数据处理与分析</strong></p>\n<ul>\n<li>根据条形码将每条读数（read）分配回对应细胞，UMI 去重后得到每个细胞中每个基因的表达量矩阵。</li>\n<li>下游分析包括细胞聚类、差异表达、伪时序分析等。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"优势\"><a class=\"anchor\" href=\"#优势\">#</a> 优势</h3>\n<ul>\n<li>能在单细胞水平揭示生物体系的异质性。</li>\n<li>支持大规模细胞通量（可达数万到数十万细胞）。</li>\n<li>数据成熟，分析工具丰富（Seurat、Scanpy 等）。</li>\n</ul>\n<h3 id=\"局限\"><a class=\"anchor\" href=\"#局限\">#</a> 局限</h3>\n<ul>\n<li>只捕获多聚 A 尾 mRNA，无法直接测到非 polyadenylated RNA（如部分非编码 RNA）。</li>\n<li>有 “高掉落率”（dropout）现象：低丰度转录本常常检测不到。</li>\n<li>无空间信息，需要结合空间转录组或成像技术。</li>\n</ul>\n<h3 id=\"应用场景\"><a class=\"anchor\" href=\"#应用场景\">#</a> 应用场景</h3>\n<ul>\n<li>细胞类型鉴定与注释</li>\n<li>发育过程伪时序重构</li>\n<li>疾病微环境中的免疫细胞分型</li>\n<li>药物或基因扰动后细胞响应分析</li>\n</ul>\n<hr />\n<h2 id=\"2-cite-seq\"><a class=\"anchor\" href=\"#2-cite-seq\">#</a> 2. CITE-seq</h2>\n<p>(Cellular Indexing of Transcriptomes and Epitopes by Sequencing)</p>\n<h3 id=\"基本原理-2\"><a class=\"anchor\" href=\"#基本原理-2\">#</a> 基本原理</h3>\n<p>CITE-seq 在常规模版 scRNA-seq 的基础上，额外对细胞表面或胞内蛋白进行标记与测量。它使用带有寡核苷酸标签的抗体（antibody–oligo conjugates），让蛋白质水平的定量也能通过测序来获取。</p>\n<h3 id=\"实验流程-2\"><a class=\"anchor\" href=\"#实验流程-2\">#</a> 实验流程</h3>\n<ol>\n<li>\n<p><strong>抗体标记</strong></p>\n<ul>\n<li>每种待测抗体共轭一个短的 DNA 报告子序列（antibody barcode）。</li>\n</ul>\n</li>\n<li>\n<p><strong>细胞染色</strong></p>\n<ul>\n<li>将多重标记的抗体混合物与细胞（或细胞悬液）孵育，使抗体特异性结合对应表面蛋白。</li>\n</ul>\n</li>\n<li>\n<p><strong>单细胞分离与裂解</strong></p>\n<ul>\n<li>如同 scRNA-seq，包封单细胞并裂解，同时释放 mRNA 和抗体上的 DNA barcode。</li>\n</ul>\n</li>\n<li>\n<p><strong>共逆转录与扩增</strong></p>\n<ul>\n<li>同时逆转录 mRNA（带细胞条形码 + UMI）与抗体 DNA barcode。</li>\n</ul>\n</li>\n<li>\n<p><strong>文库构建与测序</strong></p>\n<ul>\n<li>分离两种 cDNA：一部分用于测序转录组，另一部分用于测序抗体验证条形码（常用定制引物扩增）。</li>\n</ul>\n</li>\n<li>\n<p><strong>数据融合</strong></p>\n<ul>\n<li>将每个细胞的基因表达数据与对应的抗体信号（epitope 数量）整合，得到 “RNA + 蛋白” 联合矩阵。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"优势-2\"><a class=\"anchor\" href=\"#优势-2\">#</a> 优势</h3>\n<ul>\n<li>同时获得转录组与蛋白组信息，提高细胞类型鉴别的精度。</li>\n<li>蛋白质水平数据对低丰度或翻译后调控的靶点更敏感。</li>\n<li>可以同时检测几十到上百种表面 / 胞内蛋白。</li>\n</ul>\n<h3 id=\"局限-2\"><a class=\"anchor\" href=\"#局限-2\">#</a> 局限</h3>\n<ul>\n<li>抗体质量和特异性决定实验效果，需要严格的抗体验证。</li>\n<li>抗体–oligo 的成本和制备复杂度高于普通 scRNA-seq 试剂。</li>\n<li>通量受抗体组数和测序深度限制。</li>\n</ul>\n<h3 id=\"应用场景-2\"><a class=\"anchor\" href=\"#应用场景-2\">#</a> 应用场景</h3>\n<ul>\n<li>免疫细胞谱系分型（T 细胞亚群、B 细胞亚群鉴定）</li>\n<li>转录组与表型标志物联合分析</li>\n<li>细胞分化过程中蛋白与 RNA 调控耦合研究</li>\n<li>临床样本中多标志物联合表型剖析</li>\n</ul>\n<hr />\n<h2 id=\"3-single-cell-atac-sequencing-scatac-seq\"><a class=\"anchor\" href=\"#3-single-cell-atac-sequencing-scatac-seq\">#</a> 3. Single-cell ATAC sequencing (scATAC-seq)</h2>\n<p>(Assay for Transposase-Accessible Chromatin)</p>\n<h3 id=\"基本原理-3\"><a class=\"anchor\" href=\"#基本原理-3\">#</a> 基本原理</h3>\n<p>scATAC-seq 用于在单细胞水平绘制染色质开放性（chromatin accessibility）图谱，揭示基因调控元件（如启动子、增强子）在不同细胞类型或状态下的可及性差异。</p>\n<h3 id=\"实验流程-3\"><a class=\"anchor\" href=\"#实验流程-3\">#</a> 实验流程</h3>\n<ol>\n<li>\n<p><strong>单细胞分离</strong></p>\n<ul>\n<li>类似 scRNA-seq，可用微流控芯片（10x Genomics Chromium）或微流体滴式系统。</li>\n</ul>\n</li>\n<li>\n<p><strong>Tn5 转座酶标记</strong></p>\n<ul>\n<li>在裂解后的细胞核中加入加载了测序接头的 Tn5 转座酶，它会 preferentially 插入到开放染色质区，使这些区域同时获得测序接头。</li>\n</ul>\n</li>\n<li>\n<p><strong>条形码融合</strong></p>\n<ul>\n<li>通过在微液滴或孔室中完成转座反应，使插入片段带上细胞条形码和 UMI。</li>\n</ul>\n</li>\n<li>\n<p><strong>扩增与测序</strong></p>\n<ul>\n<li>扩增插入了接头的 DNA 片段，构建文库并进行高通量测序。</li>\n</ul>\n</li>\n<li>\n<p><strong>数据处理与分析</strong></p>\n<ul>\n<li>根据条形码将读数分配到细胞，去除 PCR 重复后得到每个细胞在基因组各位点的可及性矩阵（细胞 × peaks）。</li>\n<li>下游可做细胞聚类、TF motif 分析、基因调控网络推断等。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"优势-3\"><a class=\"anchor\" href=\"#优势-3\">#</a> 优势</h3>\n<ul>\n<li>直接捕获调控元件活性，补充转录组数据无法提供的调控层信息。</li>\n<li>能鉴定特异细胞类型的关键增强子或 TF 結合位点。</li>\n<li>与 scRNA-seq 联合（例如 Multiome）可同时获取转录组和染色质可及性数据。</li>\n</ul>\n<h3 id=\"局限-3\"><a class=\"anchor\" href=\"#局限-3\">#</a> 局限</h3>\n<ul>\n<li>通量和数据稀疏性问题更严重，通常每个细胞只有几千到一万条有效片段。</li>\n<li>峰（peak）调用和比对较复杂，对计算资源要求高。</li>\n<li>需要更深的测序深度以覆盖低频开放区域。</li>\n</ul>\n<h3 id=\"应用场景-3\"><a class=\"anchor\" href=\"#应用场景-3\">#</a> 应用场景</h3>\n<ul>\n<li>构建细胞类型特异的调控元件图谱</li>\n<li>推断转录因子活性与基因调控网络</li>\n<li>发育过程中染色质重塑动态研究</li>\n<li>结合 GWAS 数据定位变异影响的调控元件</li>\n</ul>\n<hr />\n<p><strong>总结对比</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>scRNA-seq</th>\n<th>CITE-seq</th>\n<th>scATAC-seq</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>主要测量层面</td>\n<td>mRNA 转录本</td>\n<td>mRNA + 表面 / 胞内蛋白</td>\n<td>染色质开放性（调控元件可及性）</td>\n</tr>\n<tr>\n<td>条形码与 UMI</td>\n<td>都有</td>\n<td>都有</td>\n<td>都有</td>\n</tr>\n<tr>\n<td>数据稀疏性</td>\n<td>较高（dropout）</td>\n<td>较高（RNA 部分） + 蛋白部分相对低 sparsity</td>\n<td>非常高（开放片段稀疏）</td>\n</tr>\n<tr>\n<td>分辨信息</td>\n<td>转录本丰度</td>\n<td>转录本 + 表型蛋白</td>\n<td>调控元件活性</td>\n</tr>\n<tr>\n<td>典型通量</td>\n<td>10⁴–10⁵ 细胞</td>\n<td>10⁴ 细胞（视抗体数量与测序深度而定）</td>\n<td>10³–10⁴ 细胞</td>\n</tr>\n</tbody>\n</table>\n<p>这三种技术各有侧重，常常结合使用以获得细胞多层次的分子图谱，帮助我们更全面地理解细胞状态与功能。</p>\n</div></details>\n<p>说实话，总感觉这段话有点牵强，真的和 perturbations 相关性这么大吗。</p>\n<p>下面的一段说了一下大规模数据的影响，目前精确去预测网络的 interactions 还是受限于数据规模小的影响。Large-scale single-cell perturbation–response screens enable exploration of complex cellular behavior inaccessible in bulk measurements.</p>\n<p>研究目的：Reliable analysis of increasingly large perturbation datasets requires efficient statistical tools to harness large numbers of cells and perturbations. 研究背景：The inherently high dimensionality of perturbation–response data complicates calculation of distances between perturbations, as does cell-to-cell variation and data sparsity. 本文基于各种 Multiple distance measures 方法中的 energy distance。</p>\n<p>“Cell lines”（细胞系）是指在体外条件下（通常是培养皿或培养瓶中），从多细胞生物体取出的细胞经适当处理后，能够持续生长、分裂并保持特定特征的一类细胞群体。</p>\n<p>Large perturbation screens are specifically designed to study a particular system, such as a cell line, under a set of perturbations of interest. 研究背景：“the field has accumulated a heterogeneous assortment of single-cell perturbation–response data with a wide range of different cell types, such as immortalized cell lines and induced pluripotent stem cell-derived models, and different perturbation technologies, including knockouts, activation, interference, base editing and prime editing”。所以 Computational methods to efficiently harmonize these different perturbation datasets are needed.</p>\n<p>所以这个文章干了两件事，第一，提供了 scPerturb 去标准化数据集，第二，提供了 E-distance 作为衡量指标。</p>\n<p>还是有点懵。</p>\n<h1 id=\"results\"><a class=\"anchor\" href=\"#results\">#</a> Results</h1>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/41592_2023_2144_Fig2_HTML.webp\" alt=\"\" /></p>\n<p>这里记一个结论：The average sequencing depth, that is, the mean number of reads per cell, in each study affects the number of low-expression genes observed. Increasing sequencing depth increases the UMI counts measured even for low-expression genes, reducing the uncertainty associated with zero counts.</p>\n<p>“测序深度（sequencing depth）” 是指在测序实验中，每个位点或每个分子被测序的平均次数，它反映的是数据的丰富程度或覆盖程度。</p>\n<p>这一大段挺难理解的，我拿 GPT 跑了一个解释：<br />\n这段话的核心在讲：<strong>不同数据集的测序质量指标差异很大，而测序深度对单细胞扰动实验的可解释性和分析结果有显著影响。</strong></p>\n<p>具体讲了以下几点：</p>\n<hr />\n<h3 id=\"1-不同数据集的样本质量差异显著\"><a class=\"anchor\" href=\"#1-不同数据集的样本质量差异显著\">#</a> 🔍 1. <strong>不同数据集的样本质量差异显著</strong></h3>\n<ul>\n<li>\n<p>数据集中细胞总数的多少主要受限于实验条件（例如样本处理能力、试剂成本、设备通量），尽管随着技术进步总量有增长趋势（见 Fig. 2b）。</p>\n</li>\n<li>\n<p>常用的质量控制指标包括：</p>\n<ul>\n<li>每个细胞的总 <strong>UMI 数（unique molecular identifier）</strong></li>\n<li>每个细胞检测到的 <strong>基因数量</strong></li>\n</ul>\n<blockquote>\n<p>👉 这些数值反映了测序的 “有效信息量”，在后续数据分析中用于筛选低质量细胞。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h3 id=\"2-平均测序深度影响低表达基因的检测\"><a class=\"anchor\" href=\"#2-平均测序深度影响低表达基因的检测\">#</a> 📊 2. <strong>平均测序深度影响低表达基因的检测</strong></h3>\n<ul>\n<li>\n<p><strong>平均测序深度 = 每个细胞平均测得的 reads 数量</strong></p>\n</li>\n<li>\n<p>测序越深，就越可能捕获到<strong>低表达的基因</strong>，UMI 数也越高，进而：</p>\n<ul>\n<li>减少 “0 表达” 现象的误判（dropout）</li>\n<li>提高低表达基因的可靠检测</li>\n</ul>\n</li>\n<li>\n<p>这意味着：深度高不仅能检测更多基因，还能<strong>降低因低丰度而产生的假阴性</strong></p>\n</li>\n</ul>\n<hr />\n<h3 id=\"3-测序深度-数据质量\"><a class=\"anchor\" href=\"#3-测序深度-数据质量\">#</a> 🧪 3. <strong>测序深度 ≠ 数据质量</strong></h3>\n<ul>\n<li>\n<p><strong>并非只要加深测序就能弥补实验缺陷</strong>：</p>\n<ul>\n<li>如果在实验过程中 mRNA 已经降解了，reads 再多也无法 “复原” 丢失的转录本。</li>\n<li>数据恢复的上限受限于样本质量，常用 ** 测序饱和度（sequencing saturation）** 来估计。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"️-4-这些质量差异会影响后续分析\"><a class=\"anchor\" href=\"#️-4-这些质量差异会影响后续分析\">#</a> ⚠️ 4. <strong>这些质量差异会影响后续分析</strong></h3>\n<ul>\n<li>\n<p>不同扰动条件下，如果测序深度或数据质量不一致，可能会影响：</p>\n<ul>\n<li>扰动间的差异是否能被识别（distinguishability）</li>\n<li>聚类、差异表达、轨迹分析等下游计算的效果（downstream analysis performance）</li>\n</ul>\n</li>\n</ul>\n<hr />\n<p>这里介绍了 E-distance 这个概念，对于两组细胞，它描述了这两组细胞的分布的 distance。More precisely, it compares the mean pairwise distance of cells between two different perturbations to the mean pairwise distance of cells within each of the two distribution.</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/41592_2023_2144_Fig3_HTML.webp\" alt=\"\" /></p>\n<p>Fig (c) :This is in part caused by two-target perturbations using CRISPRa in that dataset: targeting the same gene with two single guides increases the chances of causing a considerable change in the transcript profile.</p>\n<p>The E-distance can also be used to quantify similarity between different perturbations.<br />\nFig (e): 观察 unperturbed 和其它的分布可以看出对于不同的 E-test 值可以明显区分出来。对于 CEBPA 和 KLF1+CEBPA 重叠的区域 is captured by a low E-distance:cells affected by these two perturbations are closer to each other than they are to unperturbed cells or to those from other perturbations.</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/41592_2023_2144_Fig4_HTML.webp\" alt=\"\" /></p>\n<p>这段话主要在说明：<strong>如何利用 E-distance（能量距离）分析扰动数据集中不同基因扰动之间的相似性，并验证其在免疫信号通路中的生物学一致性。</strong></p>\n<hr />\n<h3 id=\"具体讲了什么\"><a class=\"anchor\" href=\"#具体讲了什么\">#</a> 📌 具体讲了什么？</h3>\n<ol>\n<li>\n<p><strong>分析背景与数据集来源</strong></p>\n<ul>\n<li>研究选用了一个关于免疫抑制检查点的扰动数据集（见 Fig. 4），该数据集使用 <strong>CRISPR-Cas9</strong> 对多个调控 <strong>PD-L1 表达</strong> 的基因进行扰动（参考文献 [9]）。</li>\n</ul>\n</li>\n<li>\n<p><strong>方法：E-distance 计算扰动间的相似性</strong></p>\n<ul>\n<li>计算了所有基因扰动对之间的 <strong>两两 E-distance</strong>，即它们诱导的细胞状态差异有多大。</li>\n<li>然后对这个距离矩阵进行了<strong>层次聚类（hierarchical clustering）</strong>，发现出现了两个显著不同的扰动子群（clusters）。</li>\n</ul>\n</li>\n<li>\n<p><strong>观察与解释：形成一个具有相似表型的基因群</strong></p>\n<ul>\n<li>其中一个扰动群体（IFNGR1、IFNGR2、JAK2、STAT1）之间的 E-distance 较小，说明它们产生了<strong>相似的细胞转录组响应</strong>。</li>\n<li>而它们与 “未扰动对照组” 之间的 E-distance 较大，说明这些扰动引起了显著变化。</li>\n</ul>\n</li>\n<li>\n<p><strong>生物学一致性验证</strong></p>\n<ul>\n<li>\n<p>这组基因（IFNGR1, IFNGR2, JAK2, STAT1）正好都位于 <strong>IFNγ（干扰素 -γ）信号通路</strong>中，属于同一个上游 / 下游调控链条：</p>\n<ul>\n<li>它们都在 <strong>IFNγ → IRF1 → PD-L1 表达</strong> 的通路中起作用（参考文献 [50]）。</li>\n</ul>\n</li>\n<li>\n<p>因此扰动这些基因会引发相似的表型改变，是<strong>功能一致性的体现</strong>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<hr />\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/41592_2023_2144_Fig5_HTML.webp\" alt=\"\" /></p>\n<p>这段话讲的是：<strong>作者通过子采样（subsampling）实验系统评估了 E-distance 和 E-test 对样本数量变化的敏感性和鲁棒性（稳定性），并给出合理使用它们的建议。</strong></p>\n<hr />\n<h3 id=\"具体讲了什么-2\"><a class=\"anchor\" href=\"#具体讲了什么-2\">#</a> 📌 具体讲了什么？</h3>\n<h4 id=\"1-研究目的\"><a class=\"anchor\" href=\"#1-研究目的\">#</a> ✅ 1. <strong>研究目的</strong></h4>\n<ul>\n<li>使用 scPerturb 提供的统一注释的单细胞扰动数据集，评估 <strong>E-distance（用于量化扰动差异）和 E-test（用于显著性检验）</strong> 对实验设计和数据处理参数的鲁棒性（尤其是细胞数目的影响）。</li>\n</ul>\n<h4 id=\"2-实验方法人为减少细胞数进行测试\"><a class=\"anchor\" href=\"#2-实验方法人为减少细胞数进行测试\">#</a> ✅ 2. <strong>实验方法：人为减少细胞数进行测试</strong></h4>\n<ul>\n<li>人为<strong>下采样每个扰动条件中的细胞数</strong>，模拟 “小样本” 场景，观察这时 E-distance 和 E-test 分数如何变化。</li>\n</ul>\n<h4 id=\"3-偏差修正bias-correction\"><a class=\"anchor\" href=\"#3-偏差修正bias-correction\">#</a> ✅ 3. <strong>偏差修正（bias correction）</strong></h4>\n<ul>\n<li>提出了一种<strong> E-distance 的偏差修正方法</strong>，以提高在小样本条件下的准确性（详见补充材料第 1 节）。</li>\n</ul>\n<h4 id=\"4-发现-1即使修正后e-distance-在细胞数减少时仍上升\"><a class=\"anchor\" href=\"#4-发现-1即使修正后e-distance-在细胞数减少时仍上升\">#</a> ✅ 4. <strong>发现 1：即使修正后，E-distance 在细胞数减少时仍上升</strong></h4>\n<ul>\n<li>\n<p>即使使用了偏差修正，在<strong>每个扰动下的细胞数减少时，E-distance 仍会人为变大</strong>，这说明：</p>\n<ul>\n<li><strong>计算 E-distance 前需要对每个扰动的细胞数进行标准化</strong>（例如统一抽取相同数量的细胞），否则可能引入比较偏差。</li>\n<li>原因在于：<strong>PCA 在小样本情况下不能很好表示高维数据结构</strong>，从而扭曲了距离估计。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-发现-2显著性检验结果随着样本数下降而自然减少\"><a class=\"anchor\" href=\"#5-发现-2显著性检验结果随着样本数下降而自然减少\">#</a> ✅ 5. <strong>发现 2：显著性检验结果随着样本数下降而自然减少</strong></h4>\n<ul>\n<li>当细胞数下降时，能被识别为显著扰动的基因数量减少，这是符合预期的：样本越少，统计功效越低。</li>\n<li>同时观察到，并非所有数据集在 “全部细胞数” 时都达到了扰动检测的饱和状态（即：进一步增加细胞数可能还会发现新扰动）。</li>\n</ul>\n<h4 id=\"6-影响因素扰动强度与数据异质性\"><a class=\"anchor\" href=\"#6-影响因素扰动强度与数据异质性\">#</a> ✅ 6. <strong>影响因素：扰动强度与数据异质性</strong></h4>\n<ul>\n<li>\n<p>检测 “饱和点”（saturation point）取决于：</p>\n<ul>\n<li><strong>扰动的效应强度（effect size）</strong>：强效扰动易被发现，弱效扰动需要更多细胞。</li>\n<li><strong>数据集的异质性（heterogeneity）</strong>：如果细胞彼此非常相似，则较少样本就足以捕捉扰动的平均效应。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<p>这段话主要讲的是：<strong>评估单位细胞内的测序深度（即 UMI 数量）对扰动分析结果的影响，并提出实际实验设计的参考建议。</strong></p>\n<hr />\n<h3 id=\"具体内容逐句解析\"><a class=\"anchor\" href=\"#具体内容逐句解析\">#</a> 📌 具体内容逐句解析：</h3>\n<h4 id=\"1-umi-数越多e-distance-越大\"><a class=\"anchor\" href=\"#1-umi-数越多e-distance-越大\">#</a> ✅ 1. <strong>UMI 数越多，E-distance 越大</strong></h4>\n<blockquote>\n<p>“We subset the number of UMIs per cell, finding that E-distance increases as the UMI count per cell increases (Fig. 5c).”</p>\n</blockquote>\n<ul>\n<li>\n<p>作者控制变量，只改变每个细胞的 UMI 数（模拟不同测序深度）：</p>\n<ul>\n<li>结果发现：<strong>随着每个细胞的 UMI 数增加，E-distance（能量距离）也增加</strong>。</li>\n<li>原因可能是：高 UMI 会暴露出更多细微的扰动效应，使得扰动组与对照组在表达空间中的距离拉大。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-但-e-test-的显著性结果在-~500-umi-就饱和了\"><a class=\"anchor\" href=\"#2-但-e-test-的显著性结果在-~500-umi-就饱和了\">#</a> ✅ 2. <strong>但 E-test 的显著性结果在～500 UMI 就饱和了</strong></h4>\n<blockquote>\n<p>“The number of significant perturbations under the E-test, however, saturates at around 500 UMIs per cell...”</p>\n</blockquote>\n<ul>\n<li>\n<p>虽然 E-distance 随深度增加而变化，但用于判断扰动是否显著的 <strong>E-test（统计检验）</strong> 在 UMI 达到 500 左右时，显著性结果就趋于稳定（饱和）：</p>\n<ul>\n<li><strong>也就是说：即使 UMI 较少，统计显著的扰动大多数依然能被检测到</strong>。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-说明-e-test-更稳定-更实用\"><a class=\"anchor\" href=\"#3-说明-e-test-更稳定-更实用\">#</a> ✅ 3. <strong>说明 E-test 更稳定、更实用</strong></h4>\n<blockquote>\n<p>“The stability of E-test results... demonstrates the necessity of the E-test... as the appropriate statistical measure...”</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>E-test 比 E-distance 更稳健、不那么依赖测序深度</strong>，因为：</p>\n<ul>\n<li>它使用了 <strong>随机化对照（permutation control）</strong>，可以抵消一部分数据量波动带来的影响。</li>\n<li>所以在实际分析中，<strong>E-test 是更适合用来判断扰动是否有效的统计工具</strong>。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-实验设计建议干货\"><a class=\"anchor\" href=\"#4-实验设计建议干货\">#</a> ✅ 4. <strong>实验设计建议（干货！）</strong></h4>\n<blockquote>\n<p>“we suggest at least 200–500 cells per perturbation and an average of 1,000 UMIs per cell...”</p>\n</blockquote>\n<ul>\n<li>\n<p>综合分析后，作者给出一个<strong>推荐标准</strong>，用于指导单细胞扰动实验设计：</p>\n<ul>\n<li><strong>每个扰动条件下建议至少测序 200–500 个细胞</strong></li>\n<li><strong>每个细胞建议测出平均 1,000 个 UMI</strong></li>\n<li>这两个条件基本能保证对多数 “显著扰动” 的稳定检测。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-但最佳测序深度还要看任务\"><a class=\"anchor\" href=\"#5-但最佳测序深度还要看任务\">#</a> ✅ 5. <strong>但最佳测序深度还要看任务</strong></h4>\n<blockquote>\n<p>“The optimal lower bounds... depend on downstream specific modeling tasks...”</p>\n</blockquote>\n<ul>\n<li>\n<p>注意：这个 “推荐标准” 是用于 “检测扰动是否显著” 的一般性指导；</p>\n<ul>\n<li>若下游任务更复杂（如预测建模、轨迹分析等），所需的测序深度和细胞数可能更高。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h1 id=\"methods\"><a class=\"anchor\" href=\"#methods\">#</a> Methods</h1>\n<p>终于到方法的部分了。</p>\n<h2 id=\"scatac-seq\"><a class=\"anchor\" href=\"#scatac-seq\">#</a> scATAC-seq</h2>\n<p>scATAC-seq is a biomolecular technique to assess chromatin accessibility in single cells.</p>\n<p>这段话主要讲的是：<strong>作者如何处理 scATAC-seq 数据以提取标准化的特征，用于分析单细胞染色质可及性信息。</strong></p>\n<hr />\n<h3 id=\"逐句解释如下\"><a class=\"anchor\" href=\"#逐句解释如下\">#</a> 📌 逐句解释如下：</h3>\n<h4 id=\"1-技术背景\"><a class=\"anchor\" href=\"#1-技术背景\">#</a> ✅ 1. 技术背景</h4>\n<blockquote>\n<p><em>“scATAC-seq is a biomolecular technique to assess chromatin accessibility in single cells.”</em></p>\n</blockquote>\n<ul>\n<li><strong>scATAC-seq 是一种单细胞分辨率的技术</strong>，用于检测染色质的开放程度，即哪些 DNA 区域对转录因子等蛋白 “可及”（accessible）。</li>\n</ul>\n<hr />\n<h4 id=\"2-数据输入格式\"><a class=\"anchor\" href=\"#2-数据输入格式\">#</a> ✅ 2. 数据输入格式</h4>\n<blockquote>\n<p><em>“The starting point of our data processing pipeline is BED-like tabular fragment files...”</em></p>\n</blockquote>\n<ul>\n<li>数据处理流程的起点是类似 <strong>BED 格式的片段文件</strong>（tab-delimited），每一行代表一个被测序捕获到的 <strong>ATAC 片段（fragment）</strong>，包含它所在的基因组位置和对应的<strong>细胞条形码（cell barcode）</strong>。</li>\n</ul>\n<hr />\n<h4 id=\"3-数据处理目标\"><a class=\"anchor\" href=\"#3-数据处理目标\">#</a> ✅ 3. 数据处理目标</h4>\n<blockquote>\n<p><em>“The goal... is to extract standardized features from this information.”</em></p>\n</blockquote>\n<ul>\n<li>目标是从这些原始片段信息中提取出一系列<strong>标准化的、可用于分析的特征</strong>。</li>\n</ul>\n<hr />\n<h4 id=\"4-提取的五类特征如下\"><a class=\"anchor\" href=\"#4-提取的五类特征如下\">#</a> ✅ 4. 提取的五类特征如下：</h4>\n<ol>\n<li>\n<p><strong>LSI Embeddings（低维嵌入）</strong></p>\n<blockquote>\n<p><em>“embeddings derived from latent-semantic-indexing (LSI) with 30 dimensions...”</em></p>\n</blockquote>\n<ul>\n<li>使用 <strong>潜在语义索引（LSI）</strong> 方法将高维稀疏的 ATAC-seq 数据降维成每个细胞一个 <strong>30 维向量</strong>，适合稀疏性强的单细胞 ATAC 数据。</li>\n</ul>\n</li>\n<li>\n<p><strong>Gene Scores（基因开放性得分）</strong></p>\n<blockquote>\n<p><em>“gene scores that measure the chromatin accessibility around each gene...”</em></p>\n</blockquote>\n<ul>\n<li>每个细胞对每个基因，计算其 <strong>转录起始位点（TSS）邻近区域的开放程度加权和</strong>，即基因周围的染色质可及性，距离越远的片段权重越低。</li>\n</ul>\n</li>\n<li>\n<p><strong>Peak–Barcode Matrix（峰 × 细胞矩阵）</strong></p>\n<blockquote>\n<p><em>“a peak–barcode matrix that quantifies the chromatin accessibility at consensus peaks...”</em></p>\n</blockquote>\n<ul>\n<li>构建一个 <strong>细胞 × 共识峰（peaks）</strong> 的矩阵，用于表示各细胞在特定基因组区域（peaks）上的染色质开放强度。</li>\n</ul>\n</li>\n<li>\n<p><strong>chromVAR Scores（转录因子活性分数）</strong></p>\n<blockquote>\n<p><em>“chromVAR scores, which quantify the activity of a set of transcription factors...”</em></p>\n</blockquote>\n<ul>\n<li>利用 <strong>chromVAR 工具</strong> 计算每个细胞中一组转录因子对应的 DNA footprint 区域的活性变化，用来反映转录因子的功能活性水平。</li>\n</ul>\n</li>\n<li>\n<p><strong>Marker Peaks（扰动标志峰）</strong></p>\n<blockquote>\n<p><em>“marker-peaks per perturbation target, which quantifies the differential regulation...”</em></p>\n</blockquote>\n<ul>\n<li>对每种扰动条件，识别出<strong>差异化活跃的高变峰（highly variable peaks）</strong>，作为该扰动的 “标志性染色质调控区域”。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h2 id=\"scrna-seq\"><a class=\"anchor\" href=\"#scrna-seq\">#</a> scRNA-seq</h2>\n<p>这段话讲的是：<strong>作者如何处理和标准化各个原始单细胞扰动数据集，以便进行统一分析。</strong></p>\n<p>下面是逐句解释：</p>\n<hr />\n<h3 id=\"1-起始数据来源与处理方式\"><a class=\"anchor\" href=\"#1-起始数据来源与处理方式\">#</a> 📌 1. <strong>起始数据来源与处理方式</strong></h3>\n<blockquote>\n<p><em>“Analysis was initiated using unfiltered, unnormalized cell-by-gene matrices as provided by source papers.”</em></p>\n</blockquote>\n<ul>\n<li>分析从<strong>原始文献提供的 cell-by-gene 矩阵</strong>（即细胞 × 基因的表达矩阵）开始；</li>\n<li>使用的是<strong>未经过滤或归一化的原始版本</strong>，确保保留最大的信息量，便于统一处理。</li>\n</ul>\n<hr />\n<h3 id=\"2-针对缺少处理后的数据集\"><a class=\"anchor\" href=\"#2-针对缺少处理后的数据集\">#</a> 📌 2. <strong>针对缺少处理后的数据集</strong></h3>\n<blockquote>\n<p><em>“For one dataset, preprocessed cell-by-gene matrices were unavailable...”</em></p>\n</blockquote>\n<ul>\n<li>有一个数据集并未公开处理好的表达矩阵；</li>\n<li>作者就<strong>按照原论文中描述的流程</strong>，<strong>使用原作者提供的代码</strong>自行进行预处理。</li>\n</ul>\n<hr />\n<h3 id=\"3-细胞条形码barcode处理\"><a class=\"anchor\" href=\"#3-细胞条形码barcode处理\">#</a> 📌 3. <strong>细胞条形码（barcode）处理</strong></h3>\n<blockquote>\n<p><em>“For datasets with cell barcodes, barcode assignments for cells were taken from the original paper when available...”</em></p>\n</blockquote>\n<ul>\n<li>\n<p>对于包含细胞条形码（即识别每个细胞身份）的数据集：</p>\n<ul>\n<li>如果原论文提供了 barcode 到细胞的映射，作者就<strong>直接采用原始提供的数据</strong>；</li>\n<li>如果没提供，就<strong>按原论文方法部分自行分配 barcode（详见方法部分）</strong>。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"4-处理同一细胞含多个引导序列guide的情况\"><a class=\"anchor\" href=\"#4-处理同一细胞含多个引导序列guide的情况\">#</a> 📌 4. <strong>处理同一细胞含多个引导序列（guide）的情况</strong></h3>\n<blockquote>\n<p><em>“If multiple guides were assigned to the same cell...”</em></p>\n</blockquote>\n<ul>\n<li>\n<p>如果一个细胞中检测到多个干预（例如多个 CRISPR guide RNA）：</p>\n<ul>\n<li>作者将这些 guide 按照<strong>计数从高到低的顺序排列</strong>，记录在最终的分析对象中；</li>\n<li>这样可以保留 “主要扰动” 的信息，同时也不完全丢失次要扰动。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"5-代码开放性\"><a class=\"anchor\" href=\"#5-代码开放性\">#</a> 📌 5. <strong>代码开放性</strong></h3>\n<blockquote>\n<p><em>“The code used to process each individual dataset... is available in our code repository.”</em></p>\n</blockquote>\n<ul>\n<li>作者将所有数据处理过程的代码（包括 barcode 分配）<strong>公开在他们的代码仓库中</strong>，确保透明和可复现。</li>\n</ul>\n<hr />\n<h2 id=\"e-distance\"><a class=\"anchor\" href=\"#e-distance\">#</a> E-distance</h2>\n<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo>∈</mo><msup><mi mathvariant=\"double-struck\">R</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">x_1,...,x_N \\in \\R^d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msub><mi>y</mi><mi>M</mi></msub><mo>∈</mo><msup><mi mathvariant=\"double-struck\">R</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">y_1,...,y_M \\in \\R^d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span> be samples from two distributions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X,Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, corresponding to two sets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> cells, respectively.</p>\n<p>We define :</p>\n\\begin{equation}\n\\delta_{XY} = \\frac{1}{NM}\\sum^N_{i=1}\\sum^M_{j=1}{||x_i-y_j||}\n\\end{equation}\n\\begin{equation}\n\\sigma_X =  \\frac{1}{N^2}\\sum^N_{i=1}\\sum^M_{j=1}{||x_i-y_j||}\n\\end{equation}\n<p>and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mi>Y</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">Y</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> defined accordingly.</p>\n<p>Intuitively, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>X</mi><mi>Y</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\delta_{XY}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the mean distance between cells from the two distributions, while <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> describes the mean distance between a cell from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> to another cell from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. The energy distance between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is defined as:</p>\n\\begin{equation}\nE(X,Y):=2\\delta_{XY}-\\sigma_X-\\sigma_Y \n\\end{equation}\n<p>For the bias-corrected energy distance, we define</p>\n\\begin{equation}\n\\sigma_X =  \\frac{1}{N(N-1)}\\sum^N_{i=1}\\sum^M_{j=1}{||x_i-y_j||}\n\\end{equation}\n<p>这比原来的 $\\frac<ruby>1}{N<rp>(</rp><rt>2</rt><rp>)</rp></ruby>，因为：</p>\n<p>原公式包含了自己和自己的距离<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">||x_i-x_i||=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span></p>\n<p>而修正版本只考虑不同的样本对，避免了系统性低估组内变异性；</p>\n<p>修正后更适用于小样本（如每个扰动只有几十或几百个细胞）的情况。</p>\n<h2 id=\"e-test-calculation\"><a class=\"anchor\" href=\"#e-test-calculation\">#</a> E-test calculation</h2>\n<p>E 检验（E-test）作为一种 Monte Carlo 置换检验，以能量距离（E-distance）作为检验统计量进行实施。对于每个数据集中的每一个扰动条件，我们将该扰动组的细胞与未扰动对照组的细胞合并，然后随机打乱扰动标签，将细胞重新分为两组，并计算这两组之间的 E-distance。我们将这一过程重复 10,000 次。在这 10,000 次中，打乱标签后计算得到的 E-distance 大于原始未打乱标签所得到的 E-distance 的次数，除以 10,000，即得到了对应的 P 值，该值表示一个 单边检验（one-sided test） 的显著性水平。我们为本资源中几乎所有的数据集都报告了该检验的结果（见补充表 3）。</p>\n<p>对于每个数据集中的多重假设检验，我们采用 Holm–Sidak 方法 进行多重比较校正。</p>\n",
            "tags": [
                "论文",
                "生物",
                "学习笔记类",
                "算法"
            ]
        },
        {
            "id": "http://amentiraz.github.io/other/2025-4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/",
            "url": "http://amentiraz.github.io/other/2025-4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/",
            "title": "2025-4工作总结",
            "date_published": "2025-05-06T06:36:14.000Z",
            "content_html": "<p>对 2025 年 4 月的工作进行总结</p>\n<span id=\"more\"></span>\n<p>本月主要在完成毕业设计论文，部分文章的阅读与复现，系统学习生物信息学涉及到的一些 python 库。以下是具体的情况。</p>\n<p>一、 完成毕业设计论文<br />\n在完成毕业设计论文的过程中，对于部分概念以及部分数据集进行了梳理。</p>\n<p>首先针对我阅读过的文章，例如 BayesSpace、SpaGCN、STAGATE 等文章对于研究背景以及空间域的概念进行了梳理归纳并且整理成了文档，方便论文书写过程资料的收集与获取。其次对于这些论文具体的方法进行了回顾与归纳，明晰了之前阅读比较粗浅的在 BayesSpace 这篇论文中的概念，并重新对方法进行了认识。并且对于 BayesSpace、SpaGCN、STAGATE 这三篇论文的方法在论文中进行了总结。同时我也学习了对于 Leiden 和 Louvain 算法它们的具体实现方法和原理，并针对已有的数据集完成了复现。此外，对于评价指标也更深入的进行了了解。</p>\n<p>在数据方面，我对于各类数据集进行了更深入的了解，理解了各个数据集所代表的空间技术是什么，怎么去查看他们的样本数量、基因数量以及计算它们的稀疏性。特别的，对于小鼠嗅球数据进行了收集，并且学习了它的组织结构并且初步对于它的空间域划分结合组织学图像进行了描述；同时收集了 BARISTAseq 数据，这个数据集在各个模型上表现都不错，以后可以使用。</p>\n<p>二、 文章的阅读与复现<br />\n本月主要是对于 ENSDD 这篇论文进行了阅读与复现，收集了它对应的 Human Breast Cancer 数据并以此做了复现。了解了 R 语言中调用 Python 库的操作，并且深入了解了它的代码实验原理并且做了总结，汇总成文档。</p>\n<p>特别的对于这篇论文的核心函数，我进行了推到，粗浅的理解了在线性代数中对于矩阵求偏导的流程，并且对其进行了总结，同时对照代码进行了验证。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/2025-4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%931.png\" alt=\"\" /><br />\n目前复现的进展接近尾声，对于基因相关的 tutorial 还需要理解。</p>\n<p>三、 系统学习生物信息学涉及到的一些 python 库</p>\n<p>由于认识到自身对于 python 代码的书写还处于一种零散的，不成系统的情况，所以去系统学习了 Numpy、pandas 和 Anndata 相关库的函数和操作，并且汇总成了文档以便查阅。具体而言针对 AnnData 数据，我系统的了解了它的各个模块的结构，如何利用 pandas 和 numpy 的函数对其操作，并且学习了例如如何处理大规模数据，如何创建稀疏矩阵等操作。</p>\n<p>四、 后面工作的安排</p>\n<p>（1）阅读整理完 EnSDD 这篇文章，并且在组会前完成 ppt 等相关工作的整理。<br />\n（2）阅读其它的文献，例如《scPerturb: harmonized single-cell perturbation data》并且结合自身情况继续阅读其它文献<br />\n（3）继续整理 python 相关的操作，并且可以适当回顾以前文章是怎么利用这些操作形成方法的。<br />\n（4）完成毕业设计相关内容。</p>\n",
            "tags": [
                "其它",
                "工作总结",
                "工作总结",
                "生物信息学"
            ]
        },
        {
            "id": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python4/",
            "url": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python4/",
            "title": "系统学习python（四）对于Scanpy的整理",
            "date_published": "2025-05-05T03:20:06.000Z",
            "content_html": "<p>接着上文继续学习 Scanpy 的相关语法 ，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zY2FucHktdHV0b3JpYWxzLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC9iYXNpYy1zY3JuYS10dXRvcmlhbC5odG1s\">参考网页</span></p>\n<span id=\"more\"></span>\n<h1 id=\"preprocessing-and-clustering\"><a class=\"anchor\" href=\"#preprocessing-and-clustering\">#</a> Preprocessing and clustering</h1>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scanpy <span class=\"keyword\">as</span> sc</span><br><span class=\"line\"><span class=\"keyword\">import</span> anndata <span class=\"keyword\">as</span> ad</span><br><span class=\"line\"></span><br><span class=\"line\">sc.settings.set_figure_params(dpi=<span class=\"number\">50</span>, facecolor=<span class=\"string\">&quot;white&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># EXAMPLE_DATA = pooch.create(</span></span><br><span class=\"line\"><span class=\"comment\">#    path=pooch.os_cache(&quot;scverse_tutorials&quot;),</span></span><br><span class=\"line\"><span class=\"comment\">#    base_url=&quot;doi:10.6084/m9.figshare.22716739.v1/&quot;,</span></span><br><span class=\"line\"><span class=\"comment\"># )</span></span><br><span class=\"line\"><span class=\"comment\"># EXAMPLE_DATA.load_registry_from_doi()</span></span><br><span class=\"line\"></span><br><span class=\"line\">samples = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;s1d1&quot;</span>: <span class=\"string\">&quot;D:\\\\articleCode\\\\research\\\\s1d1_filtered_feature_bc_matrix.h5&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;s1d3&quot;</span>: <span class=\"string\">&quot;D:\\\\articleCode\\\\research\\\\s1d3_filtered_feature_bc_matrix.h5&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">adatas = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> sample_id, path <span class=\"keyword\">in</span> samples.items():</span><br><span class=\"line\">    sample_adata = sc.read_10x_h5(path)</span><br><span class=\"line\">    sample_adata.var_names_make_unique()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(sample_adata)</span><br><span class=\"line\">    adatas[sample_id] = sample_adata</span><br><span class=\"line\"></span><br><span class=\"line\">adata = ad.concat(adatas, label=<span class=\"string\">&quot;sample&quot;</span>)</span><br><span class=\"line\">adata.obs_names_make_unique()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata.obs[<span class=\"string\">&quot;sample&quot;</span>].value_counts())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata)</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "代码",
                "python",
                "学习笔记",
                "python"
            ]
        },
        {
            "id": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python3/",
            "url": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python3/",
            "title": "系统学习python（三）对于Anndata的整理",
            "date_published": "2025-05-04T08:51:40.000Z",
            "content_html": "<p>接着上文继续学习 Anndata 的相关语法，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbm5kYXRhLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC90dXRvcmlhbHMvbm90ZWJvb2tzL2dldHRpbmctc3RhcnRlZC5odG1s\"> 参考网页</span></p>\n<span id=\"more\"></span>\n<p><code>AnnData</code>  is specifically designed for matrix-like data. By this we mean that we have  <code>n</code> observations, each of which can be represented as  <code>d</code> -dimensional vectors, where each dimension corresponds to a variable or feature. Both the rows and columns of this <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>×</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">n \\times d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> matrix are special in the sense that they are indexed.</p>\n<p>For instance, in scRNA-seq data, each row corresponds to a cell with a barcode, and each column corresponds to a gene with a gene id. Furthermore, for each cell and each gene we might have additional metadata, like (1) donor information for each cell, or (2) alternative gene symbols for each gene.</p>\n<h1 id=\"initializing-anndata\"><a class=\"anchor\" href=\"#initializing-anndata\">#</a> Initializing AnnData</h1>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">counts = csr_matrix(np.random.poisson(<span class=\"number\">1</span>, size=(<span class=\"number\">100</span>, <span class=\"number\">2000</span>)), dtype=np.float32)</span><br><span class=\"line\"><span class=\"comment\"># 生成一个参数为1的泊松分布的稀疏矩阵</span></span><br><span class=\"line\">adata = ad.AnnData(counts)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata)</span><br><span class=\"line\"></span><br><span class=\"line\">adata.obs_names = [<span class=\"string\">f&quot;Cell_<span class=\"subst\">&#123;i:d&#125;</span>&quot;</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(adata.n_obs)]</span><br><span class=\"line\">adata.var_names = [<span class=\"string\">f&quot;Gene_<span class=\"subst\">&#123;i:d&#125;</span>&quot;</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(adata.n_vars)]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata.obs_names)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata[[<span class=\"string\">&quot;Cell_1&quot;</span>, <span class=\"string\">&quot;Cell_10&quot;</span>], [<span class=\"string\">&quot;Gene_5&quot;</span>, <span class=\"string\">&quot;Gene_1900&quot;</span>]])</span><br></pre></td></tr></table></figure>\n<h1 id=\"adding-aligned-metadata\"><a class=\"anchor\" href=\"#adding-aligned-metadata\">#</a> Adding aligned metadata</h1>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ct = np.random.choice([<span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;T&quot;</span>, <span class=\"string\">&quot;Monocyte&quot;</span>], size=(adata.n_obs))</span><br><span class=\"line\">adata.obs[<span class=\"string\">&quot;cell_type&quot;</span>] = pd.Categorical(ct)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata.obs)</span><br><span class=\"line\"></span><br><span class=\"line\">bdata = adata[adata.obs.cell_type == <span class=\"string\">&quot;B&quot;</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(bdata)</span><br></pre></td></tr></table></figure>\n<h1 id=\"observation-variable-level-matrices\"><a class=\"anchor\" href=\"#observation-variable-level-matrices\">#</a> Observation / variable-level matrices</h1>\n<p>We might also have metadata at either level that has many dimensions to it, such as a  <code>UMAP</code>  embedding of the data. For this type of metadata, AnnData has the  <code>.obsm/.varm</code>  attributes. We use keys to identify the different matrices we insert. The restriction of  <code>.obsm/.varm</code>  are that  <code>.obsm</code>  matrices must length equal to the number of observations as .n_obs and  <code>.varm</code>  matrices must length equal to  <code>.n_vars</code> . They can each independently have different number of dimensions.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata.obsm[<span class=\"string\">&quot;X_umap&quot;</span>] = np.random.normal(<span class=\"number\">0</span>,<span class=\"number\">1</span>,size=(adata.n_obs,<span class=\"number\">2</span>))</span><br><span class=\"line\">adata.varm[<span class=\"string\">&quot;gene_stuff&quot;</span>] = np.random.normal(<span class=\"number\">0</span>,<span class=\"number\">1</span>,size=(adata.n_vars,<span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata)</span><br></pre></td></tr></table></figure>\n<p>A few more notes about  <code>.obsm/.varm</code></p>\n<ul>\n<li>\n<p>The “array-like” metadata can originate from a Pandas DataFrame, scipy sparse matrix, or numpy dense array.</p>\n</li>\n<li>\n<p>When using scanpy, their values (columns) are not easily plotted, where instead items from .obs are easily plotted on, e.g., UMAP plots.</p>\n</li>\n</ul>\n<h1 id=\"unstructured-metadata\"><a class=\"anchor\" href=\"#unstructured-metadata\">#</a> Unstructured metadata</h1>\n<p>AnnData has  <code>.uns</code> , which allows for any unstructured metadata. This can be anything, like a list or a dictionary with some general information that was useful in the analysis of our data.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata.uns[<span class=\"string\">&quot;random&quot;</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">adata.uns</span><br></pre></td></tr></table></figure>\n<h1 id=\"layers\"><a class=\"anchor\" href=\"#layers\">#</a> Layers</h1>\n<p>Finally, we may have different forms of our original core data, perhaps one that is normalized and one that is not. These can be stored in different layers in AnnData. For example, let’s log transform the original data and store it in a layer:</p>\n<h1 id=\"conversion-to-dataframe\"><a class=\"anchor\" href=\"#conversion-to-dataframe\">#</a> Conversion to DataFrame</h1>\n<p>We can also ask AnnData to return us a DataFrame from one of the layers:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata.to_df(layer=<span class=\"string\">&quot;log_transformed&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>We see that the .obs_names/.var_names are used in the creation of this Pandas object.</p>\n<h1 id=\"writing-the-results-to-disk\"><a class=\"anchor\" href=\"#writing-the-results-to-disk\">#</a> Writing the results to disk</h1>\n<p>AnnData comes with its own persistent HDF5-based file format: h5ad. If string columns with small number of categories aren’t yet categoricals, AnnData will auto-transform to categoricals.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata.write(<span class=\"string\">&#x27;my_results.h5ad&#x27;</span>, compression=<span class=\"string\">&quot;gzip&quot;</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"views-and-copies\"><a class=\"anchor\" href=\"#views-and-copies\">#</a> Views and copies</h1>\n<p>Imagine that the observations come from instruments characterizing 10 readouts in a multi-year study with samples taken from different subjects at different sites. We’d typically get that information in some format and then store it in a DataFrame:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obs_meta = pd.DataFrame(&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;time_yr&#x27;</span>: np.random.choice([<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>], adata.n_obs),</span><br><span class=\"line\">        <span class=\"string\">&#x27;subject_id&#x27;</span>: np.random.choice([<span class=\"string\">&#x27;subject 1&#x27;</span>, <span class=\"string\">&#x27;subject 2&#x27;</span>, <span class=\"string\">&#x27;subject 4&#x27;</span>, <span class=\"string\">&#x27;subject 8&#x27;</span>], adata.n_obs),</span><br><span class=\"line\">        <span class=\"string\">&#x27;instrument_type&#x27;</span>: np.random.choice([<span class=\"string\">&#x27;type a&#x27;</span>, <span class=\"string\">&#x27;type b&#x27;</span>], adata.n_obs),</span><br><span class=\"line\">        <span class=\"string\">&#x27;site&#x27;</span>: np.random.choice([<span class=\"string\">&#x27;site x&#x27;</span>, <span class=\"string\">&#x27;site y&#x27;</span>], adata.n_obs),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    index=adata.obs.index,    <span class=\"comment\"># these are the same IDs of observations as above!</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>This is how we join the readout data with the metadata. Of course, the first argument of the following call for X could also just be a DataFrame.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata = ad.AnnData(adata.X, obs=obs_meta, var=adata.var)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># View</span></span><br><span class=\"line\">adata[:<span class=\"number\">5</span>, [<span class=\"string\">&quot;Gene_1&quot;</span>, <span class=\"string\">&quot;Gene_3&quot;</span>]]</span><br><span class=\"line\"><span class=\"comment\"># .toarray()表示转换为稠密的 NumPy数组，.tolist()表示转换成Python列表，方便查看</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata[:<span class=\"number\">3</span>, <span class=\"string\">&quot;Gene_1&quot;</span>].X.toarray().tolist())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata[:<span class=\"number\">3</span>, <span class=\"string\">&quot;Gene_1&quot;</span>].X.toarray())</span><br><span class=\"line\">adata[:<span class=\"number\">3</span>, <span class=\"string\">&quot;Gene_1&quot;</span>].X = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata[:<span class=\"number\">3</span>, <span class=\"string\">&quot;Gene_1&quot;</span>].X.toarray().tolist())</span><br><span class=\"line\"><span class=\"comment\"># Copy</span></span><br><span class=\"line\">adata_subset = adata[:<span class=\"number\">5</span>, [<span class=\"string\">&quot;Gene_1&quot;</span>, <span class=\"string\">&quot;Gene_3&quot;</span>]].copy()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"partial-reading-of-large-data\"><a class=\"anchor\" href=\"#partial-reading-of-large-data\">#</a> Partial reading of large data</h1>\n<p>If a single  <code>.h5ad</code>  is very large, you can partially read it into memory by using backed mode:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata = ad.read(<span class=\"string\">&#x27;my_results.h5ad&#x27;</span>, backed=<span class=\"string\">&#x27;r&#x27;</span>)</span><br><span class=\"line\">adata.isbacked</span><br></pre></td></tr></table></figure>\n<p>If you do this, you’ll need to remember that the AnnData object has an open connection to the file used for reading:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata.filename</span><br><span class=\"line\">PosixPath(<span class=\"string\">&#x27;my_results.h5ad&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>As we’re using it in read-only mode, we can’t damage anything. To proceed with this tutorial, we still need to explicitly close it:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata.file.close()</span><br></pre></td></tr></table></figure>\n<p>As usual, you should rather use with statements to avoid dangling open files (up-coming feature).</p>\n<p>Manipulating the object on disk is possible, but experimental for sparse data. Hence, we leave it out of this tutorial.</p>\n<p>上面包含了一些非常基础的操作，考虑到时间关系和后面的内容有些难，我先去学习一下 scanpy 的操作流程</p>\n",
            "tags": [
                "代码",
                "python",
                "学习笔记",
                "python"
            ]
        },
        {
            "id": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python2/",
            "url": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python2/",
            "title": "系统学习python（二）对于pandas的整理",
            "date_published": "2025-05-03T10:15:08.000Z",
            "content_html": "<p>接着上文继续学习 pandas 的相关语法</p>\n<span id=\"more\"></span>\n<p>简单的 pandas 实例</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个简单的 DataFrame</span></span><br><span class=\"line\">data = &#123;<span class=\"string\">&#x27;Name&#x27;</span>: [<span class=\"string\">&#x27;Google&#x27;</span>, <span class=\"string\">&#x27;Runoob&#x27;</span>, <span class=\"string\">&#x27;Taobao&#x27;</span>], <span class=\"string\">&#x27;Age&#x27;</span>: [<span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>]&#125;</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 DataFrame</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df)</span><br></pre></td></tr></table></figure>\n<p>可以使用 pd.Series () 构造函数创建一个 Series 对象，传递一个数据数组（可以是列表、NumPy 数组等）和一个可选的索引数组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pandas.Series(data=<span class=\"literal\">None</span>, index=<span class=\"literal\">None</span>, dtype=<span class=\"literal\">None</span>, name=<span class=\"literal\">None</span>, copy=<span class=\"literal\">False</span>, fastpath=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>data：Series 的数据部分，可以是列表、数组、字典、标量值等。如果不提供此参数，则创建一个空的 Series。</li>\n<li>index：Series 的索引部分，用于对数据进行标记。可以是列表、数组、索引对象等。如果不提供此参数，则创建一个默认的整数索引。</li>\n<li>dtype：指定 Series 的数据类型。可以是 NumPy 的数据类型，例如 np.int64、np.float64 等。如果不提供此参数，则根据数据自动推断数据类型。</li>\n<li>name：Series 的名称，用于标识 Series 对象。如果提供了此参数，则创建的 Series 对象将具有指定的名称。</li>\n<li>copy：是否复制数据。默认为 False，表示不复制数据。如果设置为 True，则复制输入的数据。</li>\n<li>fastpath：是否启用快速路径。默认为 False。启用快速路径可能会在某些情况下提高性能。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series = pd.Series([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], name=<span class=\"string\">&quot;A&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(series)</span><br><span class=\"line\"></span><br><span class=\"line\">custom_index = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">series_with_index = pd.Series([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], index=custom_index, name=<span class=\"string\">&quot;A&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(series_with_index)</span><br><span class=\"line\"></span><br><span class=\"line\">myvar = pd.Series([<span class=\"string\">&quot;Google&quot;</span>,<span class=\"string\">&quot;Runoob&quot;</span>,<span class=\"string\">&quot;Wiki&quot;</span>],index=[<span class=\"string\">&#x27;x&#x27;</span>,<span class=\"string\">&#x27;y&#x27;</span>,<span class=\"string\">&#x27;z&#x27;</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(myvar[<span class=\"string\">&#x27;x&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">sites = &#123;<span class=\"number\">1</span>:<span class=\"string\">&quot;Google&quot;</span>,<span class=\"number\">2</span>:<span class=\"string\">&quot;Runoob&quot;</span>,<span class=\"number\">3</span>:<span class=\"string\">&quot;Wiki&quot;</span>&#125;</span><br><span class=\"line\">myvar = pd.Series(sites)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(myvar)</span><br></pre></td></tr></table></figure>\n<p>下面是 Series 常用的方法：</p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>index</td>\n<td>获取 Series 的索引</td>\n</tr>\n<tr>\n<td>values</td>\n<td>获取 Series 的数据部分（返回 NumPy 数组）</td>\n</tr>\n<tr>\n<td>head(n)</td>\n<td>返回 Series 的前 n 行（默认为 5）</td>\n</tr>\n<tr>\n<td>tail(n)</td>\n<td>返回 Series 的后 n 行（默认为 5）</td>\n</tr>\n<tr>\n<td>dtype</td>\n<td>返回 Series 中数据的类型</td>\n</tr>\n<tr>\n<td>shape</td>\n<td>返回 Series 的形状（行数）</td>\n</tr>\n<tr>\n<td>describe()</td>\n<td>返回 Series 的统计描述（如均值、标准差、最小值等）</td>\n</tr>\n<tr>\n<td>isnull()</td>\n<td>返回一个布尔 Series，表示每个元素是否为 NaN</td>\n</tr>\n<tr>\n<td>notnull()</td>\n<td>返回一个布尔 Series，表示每个元素是否不是 NaN</td>\n</tr>\n<tr>\n<td>unique()</td>\n<td>返回 Series 中的唯一值（去重）</td>\n</tr>\n<tr>\n<td>value_counts()</td>\n<td>返回 Series 中每个唯一值的出现次数</td>\n</tr>\n<tr>\n<td>map(func)</td>\n<td>将指定函数应用于 Series 中的每个元素</td>\n</tr>\n<tr>\n<td>apply(func)</td>\n<td>将指定函数应用于 Series 中的每个元素，常用于自定义操作</td>\n</tr>\n<tr>\n<td>astype(dtype)</td>\n<td>将 Series 转换为指定的类型</td>\n</tr>\n<tr>\n<td>sort_values()</td>\n<td>对 Series 中的元素进行排序（按值排序）</td>\n</tr>\n<tr>\n<td>sort_index()</td>\n<td>对 Series 的索引进行排序</td>\n</tr>\n<tr>\n<td>dropna()</td>\n<td>删除 Series 中的缺失值（NaN）</td>\n</tr>\n<tr>\n<td>fillna(value)</td>\n<td>填充 Series 中的缺失值（NaN）</td>\n</tr>\n<tr>\n<td>replace(to_replace, value)</td>\n<td>替换 Series 中指定的值</td>\n</tr>\n<tr>\n<td>cumsum()</td>\n<td>返回 Series 的累计求和</td>\n</tr>\n<tr>\n<td>cumprod()</td>\n<td>返回 Series 的累计乘积</td>\n</tr>\n<tr>\n<td>shift(periods)</td>\n<td>将 Series 中的元素按指定的步数进行位移</td>\n</tr>\n<tr>\n<td>rank()</td>\n<td>返回 Series 中元素的排名</td>\n</tr>\n<tr>\n<td>corr(other)</td>\n<td>计算 Series 与另一个 Series 的相关性（皮尔逊相关系数）</td>\n</tr>\n<tr>\n<td>cov(other)</td>\n<td>计算 Series 与另一个 Series 的协方差</td>\n</tr>\n<tr>\n<td>to_list()</td>\n<td>将 Series 转换为 Python 列表</td>\n</tr>\n<tr>\n<td>to_frame()</td>\n<td>将 Series 转换为 DataFrame</td>\n</tr>\n<tr>\n<td>iloc[]</td>\n<td>通过位置索引来选择数据</td>\n</tr>\n<tr>\n<td>loc[]</td>\n<td>通过标签索引来选择数据</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建 Series</span></span><br><span class=\"line\">data = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\">index = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;f&#x27;</span>]</span><br><span class=\"line\">s = pd.Series(data, index=index)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看基本信息</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;索引：&quot;</span>, s.index)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数据：&quot;</span>, s.values)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数据类型：&quot;</span>, s.dtype)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;前两行数据：&quot;</span>, s.head(<span class=\"number\">2</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 map 函数将每个元素加倍</span></span><br><span class=\"line\">s_doubled = s.<span class=\"built_in\">map</span>(<span class=\"keyword\">lambda</span> x: x * <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;元素加倍后：&quot;</span>, s_doubled)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算累计和</span></span><br><span class=\"line\">cumsum_s = s.cumsum()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;累计求和：&quot;</span>, cumsum_s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查找缺失值（这里没有缺失值，所以返回的全是 False）</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;缺失值判断：&quot;</span>, s.isnull())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 排序</span></span><br><span class=\"line\">sorted_s = s.sort_values()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;排序后的 Series：&quot;</span>, sorted_s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用列表创建 Series</span></span><br><span class=\"line\">s = pd.Series([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 NumPy 数组创建 Series</span></span><br><span class=\"line\">s = pd.Series(np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用字典创建 Series</span></span><br><span class=\"line\">s = pd.Series(&#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"number\">2</span>, <span class=\"string\">&#x27;c&#x27;</span>: <span class=\"number\">3</span>, <span class=\"string\">&#x27;d&#x27;</span>: <span class=\"number\">4</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 算术运算</span></span><br><span class=\"line\">result = series * <span class=\"number\">2</span>  <span class=\"comment\"># 所有元素乘以2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 过滤</span></span><br><span class=\"line\">filtered_series = series[series &gt; <span class=\"number\">2</span>]  <span class=\"comment\"># 选择大于2的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 数学函数</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\">result = np.sqrt(series)  <span class=\"comment\"># 对每个元素取平方根</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.<span class=\"built_in\">sum</span>())  <span class=\"comment\"># 输出 Series 的总和</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.mean())  <span class=\"comment\"># 输出 Series 的平均值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.<span class=\"built_in\">max</span>())  <span class=\"comment\"># 输出 Series 的最大值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.<span class=\"built_in\">min</span>())  <span class=\"comment\"># 输出 Series 的最小值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.std())  <span class=\"comment\"># 输出 Series 的标准差</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取索引</span></span><br><span class=\"line\">index = s.index</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取值数组</span></span><br><span class=\"line\">values = s.values</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取描述统计信息</span></span><br><span class=\"line\">stats = s.describe()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取最大值和最小值的索引</span></span><br><span class=\"line\">max_index = s.idxmax()</span><br><span class=\"line\">min_index = s.idxmin()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 其他属性和方法</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.dtype)   <span class=\"comment\"># 数据类型</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.shape)   <span class=\"comment\"># 形状</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.size)    <span class=\"comment\"># 元素个数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.head())  <span class=\"comment\"># 前几个元素，默认是前 5 个</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.tail())  <span class=\"comment\"># 后几个元素，默认是后 5 个</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.<span class=\"built_in\">sum</span>())   <span class=\"comment\"># 求和</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.mean())  <span class=\"comment\"># 平均值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.std())   <span class=\"comment\"># 标准差</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.<span class=\"built_in\">min</span>())   <span class=\"comment\"># 最小值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.<span class=\"built_in\">max</span>())   <span class=\"comment\"># 最大值</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"dataframe\"><a class=\"anchor\" href=\"#dataframe\">#</a> DataFrame</h1>\n<p>DataFrame 的构造方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pandas.DataFrame(data=<span class=\"literal\">None</span>, index=<span class=\"literal\">None</span>, columns=<span class=\"literal\">None</span>, dtype=<span class=\"literal\">None</span>, copy=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>data：DataFrame 的数据部分，可以是字典、二维数组、Series、DataFrame 或其他可转换为 DataFrame 的对象。如果不提供此参数，则创建一个空的 DataFrame。</li>\n<li>index：DataFrame 的行索引，用于标识每行数据。可以是列表、数组、索引对象等。如果不提供此参数，则创建一个默认的整数索引。</li>\n<li>columns：DataFrame 的列索引，用于标识每列数据。可以是列表、数组、索引对象等。如果不提供此参数，则创建一个默认的整数索引。</li>\n<li>dtype：指定 DataFrame 的数据类型。可以是 NumPy 的数据类型，例如 np.int64、np.float64 等。如果不提供此参数，则根据数据自动推断数据类型。</li>\n<li>copy：是否复制数据。默认为 False，表示不复制数据。如果设置为 True，则复制输入的数据。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\">data = &#123;<span class=\"string\">&#x27;Site&#x27;</span>:[<span class=\"string\">&#x27;Google&#x27;</span>, <span class=\"string\">&#x27;Runoob&#x27;</span>, <span class=\"string\">&#x27;Wiki&#x27;</span>], <span class=\"string\">&#x27;Age&#x27;</span>:[<span class=\"number\">10</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>]&#125;</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (df)<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\">data = [[<span class=\"string\">&#x27;Google&#x27;</span>, <span class=\"number\">10</span>], [<span class=\"string\">&#x27;Runoob&#x27;</span>, <span class=\"number\">12</span>], [<span class=\"string\">&#x27;Wiki&#x27;</span>, <span class=\"number\">13</span>]]</span><br><span class=\"line\"><span class=\"comment\"># 创建DataFrame</span></span><br><span class=\"line\">df = pd.DataFrame(data, columns=[<span class=\"string\">&#x27;Site&#x27;</span>, <span class=\"string\">&#x27;Age&#x27;</span>])</span><br><span class=\"line\"><span class=\"comment\"># 使用astype方法设置每列的数据类型</span></span><br><span class=\"line\">df[<span class=\"string\">&#x27;Site&#x27;</span>] = df[<span class=\"string\">&#x27;Site&#x27;</span>].astype(<span class=\"built_in\">str</span>)</span><br><span class=\"line\">df[<span class=\"string\">&#x27;Age&#x27;</span>] = df[<span class=\"string\">&#x27;Age&#x27;</span>].astype(<span class=\"built_in\">float</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(df)</span><br><span class=\"line\"></span><br><span class=\"line\">data = &#123;<span class=\"string\">&#x27;Site&#x27;</span>:[<span class=\"string\">&#x27;Google&#x27;</span>, <span class=\"string\">&#x27;Runoob&#x27;</span>, <span class=\"string\">&#x27;Wiki&#x27;</span>], <span class=\"string\">&#x27;Age&#x27;</span>:[<span class=\"number\">10</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>]&#125;</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (df)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个包含网站和年龄的二维ndarray</span></span><br><span class=\"line\">ndarray_data = np.array([</span><br><span class=\"line\">    [<span class=\"string\">&#x27;Google&#x27;</span>, <span class=\"number\">10</span>],</span><br><span class=\"line\">    [<span class=\"string\">&#x27;Runoob&#x27;</span>, <span class=\"number\">12</span>],</span><br><span class=\"line\">    [<span class=\"string\">&#x27;Wiki&#x27;</span>, <span class=\"number\">13</span>]</span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"comment\"># 使用DataFrame构造函数创建数据帧</span></span><br><span class=\"line\">df = pd.DataFrame(ndarray_data, columns=[<span class=\"string\">&#x27;Site&#x27;</span>, <span class=\"string\">&#x27;Age&#x27;</span>])</span><br><span class=\"line\"><span class=\"comment\"># 打印数据帧</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df)</span><br><span class=\"line\">data = [&#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"number\">2</span>&#125;,&#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">5</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"number\">10</span>, <span class=\"string\">&#x27;c&#x27;</span>: <span class=\"number\">20</span>&#125;]</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (df)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;calories&quot;</span>: [<span class=\"number\">420</span>, <span class=\"number\">380</span>, <span class=\"number\">390</span>],</span><br><span class=\"line\">  <span class=\"string\">&quot;duration&quot;</span>: [<span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">45</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 数据载入到 DataFrame 对象</span></span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"><span class=\"comment\"># 返回第一行和第二行</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.loc[[<span class=\"number\">0</span>, <span class=\"number\">1</span>]])</span><br></pre></td></tr></table></figure>\n<p>DataFrame 的常用操作和方法如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>head(n)</td>\n<td>返回 DataFrame 的前 n 行数据（默认前 5 行）</td>\n</tr>\n<tr>\n<td>tail(n)</td>\n<td>返回 DataFrame 的后 n 行数据（默认后 5 行）</td>\n</tr>\n<tr>\n<td>info()</td>\n<td>显示 DataFrame 的简要信息，包括列名、数据类型、非空值数量等</td>\n</tr>\n<tr>\n<td>describe()</td>\n<td>返回 DataFrame 数值列的统计信息，如均值、标准差、最小值等</td>\n</tr>\n<tr>\n<td>shape</td>\n<td>返回 DataFrame 的行数和列数（行数，列数）</td>\n</tr>\n<tr>\n<td>columns</td>\n<td>返回 DataFrame 的所有列名</td>\n</tr>\n<tr>\n<td>index</td>\n<td>返回 DataFrame 的行索引</td>\n</tr>\n<tr>\n<td>dtypes</td>\n<td>返回每一列的数值数据类型</td>\n</tr>\n<tr>\n<td>sort_values(by)</td>\n<td>按照指定列排序</td>\n</tr>\n<tr>\n<td>sort_index()</td>\n<td>按行索引排序</td>\n</tr>\n<tr>\n<td>dropna()</td>\n<td>删除含有缺失值（NaN）的行或列</td>\n</tr>\n<tr>\n<td>fillna(value)</td>\n<td>用指定的值填充缺失值</td>\n</tr>\n<tr>\n<td>isnull()</td>\n<td>判断缺失值，返回一个布尔值 DataFrame</td>\n</tr>\n<tr>\n<td>notnull()</td>\n<td>判断非缺失值，返回一个布尔值 DataFrame</td>\n</tr>\n<tr>\n<td>loc[]</td>\n<td>按标签索引选择数据</td>\n</tr>\n<tr>\n<td>iloc[]</td>\n<td>按位置索引选择数据</td>\n</tr>\n<tr>\n<td>at[]</td>\n<td>访问 DataFrame 中单个元素（比 loc [] 更高效）</td>\n</tr>\n<tr>\n<td>iat[]</td>\n<td>访问 DataFrame 中单个元素（比 iloc [] 更高效）</td>\n</tr>\n<tr>\n<td>apply(func)</td>\n<td>对 DataFrame 或 Series 应用一个函数</td>\n</tr>\n<tr>\n<td>applymap(func)</td>\n<td>对 DataFrame 的每个元素应用函数（仅对 DataFrame）</td>\n</tr>\n<tr>\n<td>groupby(by)</td>\n<td>分组操作，用于按某一列分组进行汇总统计</td>\n</tr>\n<tr>\n<td>pivot_table()</td>\n<td>创建透视表</td>\n</tr>\n<tr>\n<td>merge()</td>\n<td>合并多个 DataFrame（类似 SQL 的 JOIN 操作）</td>\n</tr>\n<tr>\n<td>concat()</td>\n<td>按行或按列连接多个 DataFrame</td>\n</tr>\n<tr>\n<td>to_csv()</td>\n<td>将 DataFrame 导出为 CSV 文件</td>\n</tr>\n<tr>\n<td>to_excel()</td>\n<td>将 DataFrame 导出为 Excel 文件</td>\n</tr>\n<tr>\n<td>to_json()</td>\n<td>将 DataFrame 导出为 JSON 格式</td>\n</tr>\n<tr>\n<td>to_sql()</td>\n<td>将 DataFrame 导出为 SQL 数据库</td>\n</tr>\n<tr>\n<td>query()</td>\n<td>使用 SQL 风格的语法查询 DataFrame</td>\n</tr>\n<tr>\n<td>duplicated()</td>\n<td>返回布尔值 DataFrame，指示每行是否是重复的</td>\n</tr>\n<tr>\n<td>drop_duplicates()</td>\n<td>删除重复的行</td>\n</tr>\n<tr>\n<td>set_index()</td>\n<td>设置 DataFrame 的索引</td>\n</tr>\n<tr>\n<td>reset_index()</td>\n<td>重置 DataFrame 的索引</td>\n</tr>\n<tr>\n<td>transpose()</td>\n<td>转置 DataFrame（行列交换）</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建 DataFrame</span></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;Name&#x27;</span>: [<span class=\"string\">&#x27;Alice&#x27;</span>, <span class=\"string\">&#x27;Bob&#x27;</span>, <span class=\"string\">&#x27;Charlie&#x27;</span>, <span class=\"string\">&#x27;David&#x27;</span>],</span><br><span class=\"line\">    <span class=\"string\">&#x27;Age&#x27;</span>: [<span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>],</span><br><span class=\"line\">    <span class=\"string\">&#x27;City&#x27;</span>: [<span class=\"string\">&#x27;New York&#x27;</span>, <span class=\"string\">&#x27;Los Angeles&#x27;</span>, <span class=\"string\">&#x27;Chicago&#x27;</span>, <span class=\"string\">&#x27;Houston&#x27;</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看前两行数据</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.head(<span class=\"number\">2</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 DataFrame 的基本信息</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.info())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取描述统计信息</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.describe())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按年龄排序</span></span><br><span class=\"line\">df_sorted = df.sort_values(by=<span class=\"string\">&#x27;Age&#x27;</span>, ascending=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(df_sorted)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 选择指定列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df[[<span class=\"string\">&#x27;Name&#x27;</span>, <span class=\"string\">&#x27;Age&#x27;</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按索引选择行</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.iloc[<span class=\"number\">1</span>:<span class=\"number\">3</span>])  <span class=\"comment\"># 选择第二到第三行（按位置）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按标签选择行</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.loc[<span class=\"number\">1</span>:<span class=\"number\">2</span>])  <span class=\"comment\"># 选择第二到第三行（按标签）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算分组统计（按城市分组，计算平均年龄）</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.groupby(<span class=\"string\">&#x27;City&#x27;</span>)[<span class=\"string\">&#x27;Age&#x27;</span>].mean())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 处理缺失值（填充缺失值）</span></span><br><span class=\"line\">df[<span class=\"string\">&#x27;Age&#x27;</span>] = df[<span class=\"string\">&#x27;Age&#x27;</span>].fillna(<span class=\"number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导出为 CSV 文件</span></span><br><span class=\"line\">df.to_csv(<span class=\"string\">&#x27;output.csv&#x27;</span>, index=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>创建 DataFrame</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过字典创建 DataFrame</span></span><br><span class=\"line\">df = pd.DataFrame(&#123;<span class=\"string\">&#x27;Column1&#x27;</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"string\">&#x27;Column2&#x27;</span>: [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]&#125;)</span><br><span class=\"line\">df = pd.DataFrame([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]],</span><br><span class=\"line\">                  columns=[<span class=\"string\">&#x27;Column1&#x27;</span>, <span class=\"string\">&#x27;Column2&#x27;</span>, <span class=\"string\">&#x27;Column3&#x27;</span>])</span><br><span class=\"line\"><span class=\"comment\"># 通过 NumPy 数组创建 DataFrame</span></span><br><span class=\"line\">df = pd.DataFrame(np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]]))</span><br><span class=\"line\">s1 = pd.Series([<span class=\"string\">&#x27;Alice&#x27;</span>, <span class=\"string\">&#x27;Bob&#x27;</span>, <span class=\"string\">&#x27;Charlie&#x27;</span>])</span><br><span class=\"line\">s2 = pd.Series([<span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>])</span><br><span class=\"line\">s3 = pd.Series([<span class=\"string\">&#x27;New York&#x27;</span>, <span class=\"string\">&#x27;Los Angeles&#x27;</span>, <span class=\"string\">&#x27;Chicago&#x27;</span>])</span><br><span class=\"line\">df = pd.DataFrame(&#123;<span class=\"string\">&#x27;Name&#x27;</span>: s1, <span class=\"string\">&#x27;Age&#x27;</span>: s2, <span class=\"string\">&#x27;City&#x27;</span>: s3&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># DataFrame 的属性和方法</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.shape)     <span class=\"comment\"># 形状</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.columns)   <span class=\"comment\"># 列名</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.index)     <span class=\"comment\"># 索引</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.head())    <span class=\"comment\"># 前几行数据，默认是前 5 行</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.tail())    <span class=\"comment\"># 后几行数据，默认是后 5 行</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.info())    <span class=\"comment\"># 数据信息</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.describe())<span class=\"comment\"># 描述统计信息</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.mean())    <span class=\"comment\"># 求平均值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.<span class=\"built_in\">sum</span>())     <span class=\"comment\"># 求和</span></span><br><span class=\"line\"><span class=\"comment\"># 通过列名访问</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df[<span class=\"string\">&#x27;Column1&#x27;</span>])</span><br><span class=\"line\"><span class=\"comment\"># 通过属性访问</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.Name)     </span><br><span class=\"line\"><span class=\"comment\"># 通过 .loc[] 访问</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.loc[:, <span class=\"string\">&#x27;Column1&#x27;</span>])</span><br><span class=\"line\"><span class=\"comment\"># 通过 .iloc[] 访问</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.iloc[:, <span class=\"number\">0</span>])  <span class=\"comment\"># 假设 &#x27;Column1&#x27; 是第一列</span></span><br><span class=\"line\"><span class=\"comment\"># 访问单个元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df[<span class=\"string\">&#x27;Name&#x27;</span>][<span class=\"number\">0</span>])</span><br><span class=\"line\"><span class=\"comment\"># 通过行标签访问</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.loc[<span class=\"number\">0</span>, <span class=\"string\">&#x27;Column1&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 loc 为特定索引添加新行</span></span><br><span class=\"line\">df.loc[<span class=\"number\">3</span>] = [<span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>]</span><br><span class=\"line\"><span class=\"comment\"># 使用 append 添加新行到末尾</span></span><br><span class=\"line\">new_row = &#123;<span class=\"string\">&#x27;Column1&#x27;</span>: <span class=\"number\">13</span>, <span class=\"string\">&#x27;Column2&#x27;</span>: <span class=\"number\">14</span>, <span class=\"string\">&#x27;NewColumn&#x27;</span>: <span class=\"number\">16</span>&#125;</span><br><span class=\"line\">df = df.append(new_row, ignore_index=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"comment\"># 使用concat添加新行</span></span><br><span class=\"line\">new_row = pd.DataFrame([[<span class=\"number\">4</span>, <span class=\"number\">7</span>]], columns=[<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>])  <span class=\"comment\"># 创建一个只包含新行的DataFrame</span></span><br><span class=\"line\">df = pd.concat([df, new_row], ignore_index=<span class=\"literal\">True</span>)  <span class=\"comment\"># 将新行添加到原始DataFrame</span></span><br><span class=\"line\">df_dropped = df.drop(<span class=\"string\">&#x27;Column1&#x27;</span>, axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">df_dropped = df.drop(<span class=\"number\">0</span>)  <span class=\"comment\"># 删除索引为 0 的行</span></span><br><span class=\"line\">df.describe()</span><br><span class=\"line\">df[<span class=\"string\">&#x27;Column1&#x27;</span>].<span class=\"built_in\">sum</span>()</span><br><span class=\"line\">df.mean()</span><br><span class=\"line\">df_reset = df.reset_index(drop=<span class=\"literal\">True</span>)</span><br><span class=\"line\">df_set = df.set_index(<span class=\"string\">&#x27;Column1&#x27;</span>)</span><br><span class=\"line\">df[df[<span class=\"string\">&#x27;Column1&#x27;</span>] &gt; <span class=\"number\">2</span>]</span><br><span class=\"line\">df.dtypes</span><br><span class=\"line\">df[<span class=\"string\">&#x27;Column1&#x27;</span>] = df[<span class=\"string\">&#x27;Column1&#x27;</span>].astype(<span class=\"string\">&#x27;float64&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 纵向合并</span></span><br><span class=\"line\">pd.concat([df1, df2], ignore_index=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"comment\"># 横向合并</span></span><br><span class=\"line\">pd.merge(df1, df2, on=<span class=\"string\">&#x27;Column1&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 索引和切片</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df[[<span class=\"string\">&#x27;Name&#x27;</span>, <span class=\"string\">&#x27;Age&#x27;</span>]])  <span class=\"comment\"># 提取多列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df[<span class=\"number\">1</span>:<span class=\"number\">3</span>])               <span class=\"comment\"># 切片行</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.loc[:, <span class=\"string\">&#x27;Name&#x27;</span>])     <span class=\"comment\"># 提取单列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.loc[<span class=\"number\">1</span>:<span class=\"number\">2</span>, [<span class=\"string\">&#x27;Name&#x27;</span>, <span class=\"string\">&#x27;Age&#x27;</span>]])  <span class=\"comment\"># 标签索引提取指定行列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.iloc[:, <span class=\"number\">1</span>:])        <span class=\"comment\"># 位置索引提取指定列</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"csv\"><a class=\"anchor\" href=\"#csv\">#</a> CSV</h1>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>功能描述</th>\n<th>常用参数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pd.read_csv()</td>\n<td>从 CSV 文件读取数据并加载为 DataFrame</td>\n<td>filepath_or_buffer (路径或文件对象)，sep (分隔符)，header (行标题)，names (自定义列名)，dtype (数据类型)，index_col (索引列)</td>\n</tr>\n<tr>\n<td>DataFrame.to_csv()</td>\n<td>将 DataFrame 写入到 CSV 文件</td>\n<td>path_or_buffer (目标路径或文件对象)，sep (分隔符)，index (是否写入索引)，columns (指定列)，header (是否写入列名)，mode (写入模式)</td>\n</tr>\n</tbody>\n</table>\n<p>read_csv 常用参数:</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>filepath_or_buffer</td>\n<td>CSV 文件的路径或文件对象（支持 URL、文件路径、文件对象等）</td>\n<td>必需参数</td>\n</tr>\n<tr>\n<td>sep</td>\n<td>定义字段分隔符，默认是逗号（,），可以改为其他字符，如制表符（\\t）</td>\n<td>','</td>\n</tr>\n<tr>\n<td>header</td>\n<td>指定行号作为列标题，默认为 0（表示第一行），或者设置为 None 没有标题</td>\n<td>0</td>\n</tr>\n<tr>\n<td>names</td>\n<td>自定义列名，传入列名列表</td>\n<td>None</td>\n</tr>\n<tr>\n<td>index_col</td>\n<td>用作行索引的列的列号或列名</td>\n<td>None</td>\n</tr>\n<tr>\n<td>usecols</td>\n<td>读取指定的列，可以是列的名称或列的索引</td>\n<td>None</td>\n</tr>\n<tr>\n<td>dtype</td>\n<td>强制将列转换为指定的数据类型</td>\n<td>None</td>\n</tr>\n<tr>\n<td>skiprows</td>\n<td>跳过文件开头的指定行数，或者传入一个行号的列表</td>\n<td>None</td>\n</tr>\n<tr>\n<td>nrows</td>\n<td>读取前 N 行数据</td>\n<td>None</td>\n</tr>\n<tr>\n<td>na_values</td>\n<td>指定哪些值应视为缺失值（NaN）</td>\n<td>None</td>\n</tr>\n<tr>\n<td>skipfooter</td>\n<td>跳过文件结尾的指定行数</td>\n<td>0</td>\n</tr>\n<tr>\n<td>encoding</td>\n<td>文件的编码格式（如 utf-8，latin1 等）</td>\n<td>None</td>\n</tr>\n</tbody>\n</table>\n<p>to_csv 常用参数</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>path_or_buffer</td>\n<td>CSV 文件的路径或文件对象（支持文件路径、文件对象）</td>\n<td>必需参数</td>\n</tr>\n<tr>\n<td>sep</td>\n<td>定义字段分隔符，默认是逗号（,），可以改为其他字符，如制表符（\\t）</td>\n<td>','</td>\n</tr>\n<tr>\n<td>index</td>\n<td>是否写入行索引，默认 True 表示写入索引</td>\n<td>True</td>\n</tr>\n<tr>\n<td>columns</td>\n<td>指定写入的列，可以是列的名称列表</td>\n<td>None</td>\n</tr>\n<tr>\n<td>header</td>\n<td>是否写入列名，默认 True 表示写入列名，设置为 False 表示不写列名</td>\n<td>True</td>\n</tr>\n<tr>\n<td>mode</td>\n<td>写入文件的模式，默认是 w（写模式），可以设置为 a（追加模式）</td>\n<td>'w'</td>\n</tr>\n<tr>\n<td>encoding</td>\n<td>文件的编码格式，如 utf-8，latin1 等</td>\n<td>None</td>\n</tr>\n<tr>\n<td>line_terminator</td>\n<td>定义行结束符，默认为 \\n</td>\n<td>None</td>\n</tr>\n<tr>\n<td>quoting</td>\n<td>设置如何对文件中的数据进行引号处理（0-3，具体引用方式可查文档）</td>\n<td>None</td>\n</tr>\n<tr>\n<td>quotechar</td>\n<td>设置用于引用的字符，默认为双引号 &quot;</td>\n<td>'&quot;'</td>\n</tr>\n<tr>\n<td>date_format</td>\n<td>自定义日期格式，如果列包含日期数据，则可以使用此参数指定日期格式</td>\n<td>None</td>\n</tr>\n<tr>\n<td>doublequote</td>\n<td>如果为 True，则在写入时会将包含引号的文本使用双引号括起来</td>\n<td>True</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"excel\"><a class=\"anchor\" href=\"#excel\">#</a> Excel</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pandas.read_excel(io, sheet_name=<span class=\"number\">0</span>, *, header=<span class=\"number\">0</span>, names=<span class=\"literal\">None</span>, index_col=<span class=\"literal\">None</span>, usecols=<span class=\"literal\">None</span>, dtype=<span class=\"literal\">None</span>, engine=<span class=\"literal\">None</span>, converters=<span class=\"literal\">None</span>, true_values=<span class=\"literal\">None</span>, false_values=<span class=\"literal\">None</span>, skiprows=<span class=\"literal\">None</span>, nrows=<span class=\"literal\">None</span>, na_values=<span class=\"literal\">None</span>, keep_default_na=<span class=\"literal\">True</span>, na_filter=<span class=\"literal\">True</span>, verbose=<span class=\"literal\">False</span>, parse_dates=<span class=\"literal\">False</span>, date_parser=&lt;no_default&gt;, date_format=<span class=\"literal\">None</span>, thousands=<span class=\"literal\">None</span>, decimal=<span class=\"string\">&#x27;.&#x27;</span>, comment=<span class=\"literal\">None</span>, skipfooter=<span class=\"number\">0</span>, storage_options=<span class=\"literal\">None</span>, dtype_backend=&lt;no_default&gt;, engine_kwargs=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>io</td>\n<td>这是必需的参数，指定了要读取的 Excel 文件的路径或文件对象。</td>\n<td>必需参数</td>\n</tr>\n<tr>\n<td>sheet_name</td>\n<td>指定要读取的工作表名称或索引。默认为 0，即第一个工作表。</td>\n<td>0</td>\n</tr>\n<tr>\n<td>header</td>\n<td>指定用作列名的行。默认为 0，即第一行。</td>\n<td>0</td>\n</tr>\n<tr>\n<td>names</td>\n<td>用于指定列名的列表。如果提供，将覆盖文件中的列名。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>index_col</td>\n<td>指定用作行索引的列。可以是列的名称或数字。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>usecols</td>\n<td>指定要读取的列。可以是列名的列表或列索引的列表。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>dtype</td>\n<td>指定列的数据类型。可以是字典格式，键为列名，值为数据类型。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>engine</td>\n<td>指定解析引擎。默认为 None，pandas 会自动选择。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>converters</td>\n<td>用于转换数据的函数字典。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>true_values</td>\n<td>指定应该被视为布尔值 True 的值。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>false_values</td>\n<td>指定应该被视为布尔值 False 的值。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>skiprows</td>\n<td>指定要跳过的行数或要跳过的行的列表。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>nrows</td>\n<td>指定要读取的行数。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>na_values</td>\n<td>指定应该被视为缺失值的值。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>keep_default_na</td>\n<td>指定是否要将默认的缺失值（例如 NaN）解析为 NA。</td>\n<td>True</td>\n</tr>\n<tr>\n<td>na_filter</td>\n<td>指定是否要将数据转换为 NA。</td>\n<td>True</td>\n</tr>\n<tr>\n<td>verbose</td>\n<td>指定是否要输出详细的进度信息。</td>\n<td>False</td>\n</tr>\n<tr>\n<td>parse_dates</td>\n<td>指定是否要解析日期。</td>\n<td>False</td>\n</tr>\n<tr>\n<td>date_parser</td>\n<td>用于解析日期的函数。</td>\n<td><code>&lt;no_default&gt;</code></td>\n</tr>\n<tr>\n<td>date_format</td>\n<td>指定日期的格式。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>thousands</td>\n<td>指定千位分隔符。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>decimal</td>\n<td>指定小数点字符。</td>\n<td>'.'</td>\n</tr>\n<tr>\n<td>comment</td>\n<td>指定注释字符。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>skipfooter</td>\n<td>指定要跳过的文件末尾的行数。</td>\n<td>0</td>\n</tr>\n<tr>\n<td>storage_options</td>\n<td>用于云存储的参数字典。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>dtype_backend</td>\n<td>指定数据类型后端。</td>\n<td><code>&lt;no_default&gt;</code></td>\n</tr>\n<tr>\n<td>engine_kwargs</td>\n<td>传递给引擎的额外参数字典。</td>\n<td>None</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"数据清洗\"><a class=\"anchor\" href=\"#数据清洗\">#</a> 数据清洗</h2>\n<p>如果我们要删除包含空字段的行，可以使用 dropna () 方法:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DataFrame.dropna(axis=<span class=\"number\">0</span>, how=<span class=\"string\">&#x27;any&#x27;</span>, thresh=<span class=\"literal\">None</span>, subset=<span class=\"literal\">None</span>, inplace=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>axis：默认为 0，表示逢空值剔除整行，如果设置参数 axis＝1 表示逢空值去掉整列。</li>\n<li>how：默认为 'any' 如果一行（或一列）里任何一个数据有出现 NA 就去掉整行，如果设置 how='all' 一行（或列）都是 NA 才去掉这整行。</li>\n<li>thresh：设置需要多少非空值的数据才可以保留下来的。</li>\n<li>subset：设置想要检查的列。如果是多个列，可以使用列名的 list 作为参数。</li>\n<li>inplace：如果设置 True，将计算得到的值直接覆盖之前的值并返回 None，修改的是源数据。</li>\n</ul>\n<p>我们可以通过 isnull () 判断各个单元格是否为空。</p>\n<p>我们也可以 fillna () 方法来替换一些空字段： <code>df.fillna(12345, inplace = True)</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\">df = pd.read_csv(<span class=\"string\">&#x27;property-data.csv&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">x = df[<span class=\"string\">&quot;ST_NUM&quot;</span>].mean()</span><br><span class=\"line\"></span><br><span class=\"line\">df[<span class=\"string\">&quot;ST_NUM&quot;</span>].fillna(x, inplace = <span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.to_string())</span><br></pre></td></tr></table></figure>\n<p>Pandas 使用 mean ()、median () 和 mode () 方法计算列的均值（所有值加起来的平均值）、中位数值（排序后排在中间的数）和众数（出现频率最高的数）。</p>\n<p>如果我们要清洗重复数据，可以使用 duplicated () 和 drop_duplicates () 方法。</p>\n<p>如果对应的数据是重复的，duplicated () 会返回 True，否则返回 False。</p>\n<h1 id=\"数据预处理操作汇总\"><a class=\"anchor\" href=\"#数据预处理操作汇总\">#</a> 数据预处理操作汇总</h1>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>方法 / 步骤</th>\n<th>说明</th>\n<th>常用函数 / 方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>缺失值处理</td>\n<td>填充缺失值</td>\n<td>使用指定的值（如均值、中位数、众数等）填充缺失值。</td>\n<td><code>df.fillna(value)</code></td>\n</tr>\n<tr>\n<td></td>\n<td>删除缺失值</td>\n<td>删除包含缺失值的行或列。</td>\n<td><code>df.dropna()</code></td>\n</tr>\n<tr>\n<td>重复数据处理</td>\n<td>删除重复数据</td>\n<td>删除 DataFrame 中的重复行。</td>\n<td><code>df.drop_duplicates()</code></td>\n</tr>\n<tr>\n<td>异常值处理</td>\n<td>异常值检测（基于统计方法）</td>\n<td>通过 Z-score 或 IQR 方法识别并处理异常值。</td>\n<td>自定义函数（如基于 Z-score 或 IQR）</td>\n</tr>\n<tr>\n<td></td>\n<td>替换异常值</td>\n<td>使用合适的值（如均值或中位数）替换异常值。</td>\n<td>自定义函数（如替换异常值）</td>\n</tr>\n<tr>\n<td>数据格式转换</td>\n<td>转换数据类型</td>\n<td>将数据类型从一个类型转换为另一个类型，如将字符串转换为日期。</td>\n<td><code>df.astype()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>日期时间格式转换</td>\n<td>转换字符串或数字为日期时间类型。</td>\n<td><code>pd.to_datetime()</code></td>\n</tr>\n<tr>\n<td>标准化与归一化</td>\n<td>标准化</td>\n<td>将数据转换为均值为 0，标准差为 1 的分布。</td>\n<td><code>StandardScaler()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>归一化</td>\n<td>将数据缩放到指定的范围（如 [0, 1]）。</td>\n<td><code>MinMaxScaler()</code></td>\n</tr>\n<tr>\n<td>类别数据编码</td>\n<td>标签编码</td>\n<td>将类别变量转换为整数形式。</td>\n<td><code>LabelEncoder()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>独热编码（One-Hot Encoding）</td>\n<td>将每个类别转换为一个新的二进制特征。</td>\n<td><code>pd.get_dummies()</code></td>\n</tr>\n<tr>\n<td>文本数据处理</td>\n<td>去除停用词</td>\n<td>从文本中去除无关紧要的词，如 &quot;the&quot; 、 &quot;is&quot; 等。</td>\n<td>自定义函数（基于  <code>nltk</code>  或  <code>spaCy</code> ）</td>\n</tr>\n<tr>\n<td></td>\n<td>词干化与词形还原</td>\n<td>提取词干或恢复单词的基本形式。</td>\n<td><code>nltk.stem.PorterStemmer()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>分词</td>\n<td>将文本分割成单词或子词。</td>\n<td><code>nltk.word_tokenize()</code></td>\n</tr>\n<tr>\n<td>数据抽样</td>\n<td>随机抽样</td>\n<td>从数据中随机抽取一定比例的样本。</td>\n<td><code>df.sample()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>上采样与下采样</td>\n<td>通过过采样或欠采样来平衡数据集中的类别分布。</td>\n<td><code>SMOTE()</code> （上采样）； <code>RandomUnderSampler()</code> （下采样）</td>\n</tr>\n<tr>\n<td>特征工程</td>\n<td>特征选择</td>\n<td>选择对目标变量有影响的特征，去除冗余或无关特征。</td>\n<td><code>SelectKBest()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>特征提取</td>\n<td>从原始数据中创建新的特征，提升模型的预测能力。</td>\n<td><code>PolynomialFeatures()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>特征缩放</td>\n<td>对数值特征进行缩放，使其具有相同的量级。</td>\n<td><code>MinMaxScaler()</code> 、 <code>StandardScaler()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>类别特征映射</td>\n<td>将类别变量映射为对应的数字编码。</td>\n<td>自定义映射函数</td>\n</tr>\n<tr>\n<td>数据合并与连接</td>\n<td>合并数据</td>\n<td>将多个 DataFrame 按照某些列合并在一起，支持内连接、外连接、左连接、右连接等。</td>\n<td><code>pd.merge()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>连接数据</td>\n<td>将多个 DataFrame 进行行或列拼接。</td>\n<td><code>pd.concat()</code></td>\n</tr>\n<tr>\n<td>数据重塑</td>\n<td>数据透视表</td>\n<td>将数据根据某些维度进行分组并计算聚合结果。</td>\n<td><code>pd.pivot_table()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>数据变形</td>\n<td>改变数据的形状，如从长格式转为宽格式或从宽格式转为长格式。</td>\n<td><code>df.melt()</code> 、 <code>df.pivot()</code></td>\n</tr>\n<tr>\n<td>数据类型转换与处理</td>\n<td>字符串处理</td>\n<td>对字符串数据进行处理，如去除空格、转换大小写等。</td>\n<td><code>str.replace()</code> 、 <code>str.upper()</code>  等</td>\n</tr>\n<tr>\n<td>分组计算</td>\n<td></td>\n<td>按照某个特征分组后进行聚合计算。</td>\n<td><code>df.groupby()</code></td>\n</tr>\n<tr>\n<td>缺失值预测填充</td>\n<td>使用模型预测填充缺失值</td>\n<td>使用机器学习模型（如回归模型）预测缺失值，并填充缺失数据。</td>\n<td>自定义模型（如  <code>sklearn.linear_model.LinearRegression</code> ）</td>\n</tr>\n<tr>\n<td>时间序列处理</td>\n<td>时间序列缺失值填充</td>\n<td>使用时间序列的方法（如前向填充、后向填充）填充缺失值。</td>\n<td><code>df.fillna(method='ffill')</code></td>\n</tr>\n<tr>\n<td></td>\n<td>滚动窗口计算</td>\n<td>使用滑动窗口进行时间序列数据的统计计算（如均值、标准差等）。</td>\n<td><code>df.rolling(window=5).mean()</code></td>\n</tr>\n<tr>\n<td>数据转换与映射</td>\n<td>数据映射与替换</td>\n<td>将数据中的某些值替换为其他值。</td>\n<td><code>df.replace()</code></td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.preprocessing <span class=\"keyword\">import</span> StandardScaler</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例数据</span></span><br><span class=\"line\">data = &#123;<span class=\"string\">&#x27;Age&#x27;</span>: [<span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">45</span>],</span><br><span class=\"line\">        <span class=\"string\">&#x27;Salary&#x27;</span>: [<span class=\"number\">50000</span>, <span class=\"number\">60000</span>, <span class=\"number\">70000</span>, <span class=\"number\">80000</span>, <span class=\"number\">90000</span>]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 标准化数据</span></span><br><span class=\"line\">scaler = StandardScaler()</span><br><span class=\"line\">df_scaled = scaler.fit_transform(df)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df_scaled)</span><br></pre></td></tr></table></figure>\n<h2 id=\"相关性分析\"><a class=\"anchor\" href=\"#相关性分析\">#</a> 相关性分析</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">df.corr(method=<span class=\"string\">&#x27;pearson&#x27;</span>, min_periods=<span class=\"number\">1</span>)</span><br><span class=\"line\">spearman_correlation = df.corr(method=<span class=\"string\">&#x27;spearman&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 计算肯德尔秩相关系数</span></span><br><span class=\"line\">kendall_correlation = df.corr(method=<span class=\"string\">&#x27;kendall&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 计算相关性矩阵</span></span><br><span class=\"line\">correlation_matrix = df.corr()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 绘制相关性热图</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">8</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">sns.heatmap(df.corr(), annot=<span class=\"literal\">True</span>, cmap=<span class=\"string\">&#x27;coolwarm&#x27;</span>, fmt=<span class=\"string\">&#x27;.2f&#x27;</span>, vmin=-<span class=\"number\">1</span>, vmax=<span class=\"number\">1</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Correlation Heatmap&#x27;</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>apply () — 应用函数到 DataFrame 或 Series 上<br />\n apply () 方法允许在 DataFrame 或 Series 上应用自定义函数，支持对行或列进行操作。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例数据</span></span><br><span class=\"line\">df = pd.DataFrame(&#123;<span class=\"string\">&#x27;A&#x27;</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"string\">&#x27;B&#x27;</span>: [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>]&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义自定义函数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">custom_func</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在列上应用函数</span></span><br><span class=\"line\">df[<span class=\"string\">&#x27;A&#x27;</span>] = df[<span class=\"string\">&#x27;A&#x27;</span>].apply(custom_func)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(df)</span><br></pre></td></tr></table></figure>\n<p>对于具有重复值的字符串列，可以使用 category 类型来减少内存消耗。category 类型在内存中存储的是整数索引，而不是字符串本身。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 示例数据</span></span><br><span class=\"line\">df = pd.DataFrame(&#123;<span class=\"string\">&#x27;Category&#x27;</span>: [<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>]&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 category 类型</span></span><br><span class=\"line\">df[<span class=\"string\">&#x27;Category&#x27;</span>] = df[<span class=\"string\">&#x27;Category&#x27;</span>].astype(<span class=\"string\">&#x27;category&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.dtypes)</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "代码",
                "python",
                "学习笔记",
                "python"
            ]
        },
        {
            "id": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python/",
            "url": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python/",
            "title": "系统学习python(一）对于NumPy的整理",
            "date_published": "2025-05-02T07:59:00.000Z",
            "content_html": "<p>重新系统学习一下 python</p>\n<span id=\"more\"></span>\n<p>首先我们对于 AnnData 的结构进行回顾</p>\n<h3 id=\"1-anndata-的结构\"><a class=\"anchor\" href=\"#1-anndata-的结构\">#</a> <strong>1.  <code>AnnData</code>  的结构</strong></h3>\n<p><code>AnnData</code>  是一种基于矩阵的数据结构，专为处理大规模高维数据设计。它将表达矩阵和注释信息结合起来，支持存储和处理实验数据的多个层面。</p>\n<p><strong>核心组成部分：</strong></p>\n<ul>\n<li>\n<p><strong> <code>X</code>  (主矩阵)</strong>：存储主要的数据，例如基因表达矩阵。</p>\n<ul>\n<li>数据类型：通常是 NumPy 数组 ( <code>numpy.ndarray</code> ) 或稀疏矩阵 ( <code>scipy.sparse</code> )，以节省内存。</li>\n<li>维度：形状为  <code>(n_obs, n_vars)</code> ，即细胞数 × 基因数。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>obs</code>  (观测样本注释)</strong>：存储细胞的元数据。</p>\n<ul>\n<li>类型： <code>pandas.DataFrame</code></li>\n<li>行：对应细胞，列：存储细胞的注释信息（如细胞类型、实验条件等）。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>var</code>  (变量注释)</strong>：存储基因的元数据。</p>\n<ul>\n<li>类型： <code>pandas.DataFrame</code></li>\n<li>行：对应基因，列：存储基因的注释信息（如基因名称、功能分类等）。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>obsm</code>  (观测样本多维数据)</strong>：存储额外的细胞数据，例如降维结果（如 PCA、t-SNE 或 UMAP）。</p>\n<ul>\n<li>类型：字典，值通常是 NumPy 数组或稀疏矩阵。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>varm</code>  (变量多维数据)</strong>：存储额外的基因数据，例如 PCA 的基因负载矩阵。</p>\n<ul>\n<li>类型：字典。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>uns</code>  (未分类信息)</strong>：存储任意未分类的附加信息，例如绘图参数或聚类结果的元数据。</p>\n<ul>\n<li>类型：字典。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>layers</code> </strong>：支持存储多个版本的主矩阵  <code>X</code> ，例如原始数据、归一化数据、去噪数据等。</p>\n<ul>\n<li>类型：字典，键为层的名称，值为矩阵。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"numpy\"><a class=\"anchor\" href=\"#numpy\">#</a> NumPy</h1>\n<p>然后我们发现我们并没有系统的学习过 Numpy 是个什么东西，这里我们补充一下相关的知识。</p>\n<p>这里我们根据 RUNOOB 上的教程进行补充学习。</p>\n<h2 id=\"numpy-ndarray对象\"><a class=\"anchor\" href=\"#numpy-ndarray对象\">#</a> NumPy ndarray 对象</h2>\n<p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。</p>\n<p>ndarray 对象是用于存放同类型元素的多维数组。</p>\n<p>ndarray 中的每个元素在内存中都有相同存储大小的区域。</p>\n<p>ndarray 内部由以下内容组成：</p>\n<p>一个指向数据（内存或内存映射文件中的一块数据）的指针。</p>\n<p>数据类型或 dtype，描述在数组中的固定大小值的格子。</p>\n<p>一个表示数组形状（shape）的元组，表示各维度大小的元组。</p>\n<p>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要 &quot;跨过&quot; 的字节数。</p>\n<p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>object 表示数组或嵌套的数列</li>\n<li>dtype 表示数组元素的数据类型</li>\n<li>copy 表示对象是否需要复制</li>\n<li>order 表示创建数组的样式，C 为行方向，F 为列方向，A 为任意方向 (默认)</li>\n<li>subok 默认返回一个与积累类型一致的数组</li>\n<li>ndmin 指定生成数组的最小维度</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\">b = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"></span><br><span class=\"line\">c = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], ndmin=<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"></span><br><span class=\"line\">d = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], dtype=<span class=\"built_in\">complex</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(d)</span><br></pre></td></tr></table></figure>\n<h2 id=\"numpy-数据类型\"><a class=\"anchor\" href=\"#numpy-数据类型\">#</a> NumPy 数据类型</h2>\n<p>下表列举了常用的 NumPy 的基本类型</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bool</td>\n<td>略</td>\n</tr>\n<tr>\n<td>int</td>\n<td>...</td>\n</tr>\n<tr>\n<td>float</td>\n<td>...</td>\n</tr>\n<tr>\n<td>complex</td>\n<td>...</td>\n</tr>\n</tbody>\n</table>\n<p>数据类型对象（numpy.dtype 类的实例）用来描述与数组对应的内存区域是如何使用，它描述了数据的以下几个方面：：</p>\n<p>数据的类型（整数，浮点数或者 Python 对象）<br />\n数据的大小（例如， 整数使用多少个字节存储）<br />\n数据的字节顺序（小端法或大端法）<br />\n在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分<br />\n如果数据类型是子数组，那么它的形状和数据类型是什么。<br />\n字节顺序是通过对数据类型预先设定 &lt;或&gt; 来决定的。 &lt; 意味着小端法 (最小值存储在最小的地址，即低位组放在最前面)。&gt; 意味着大端法 (最重要的字节存储在最小的地址，即高位组放在最前面)。</p>\n<p>dtype 对象是使用以下语法构造的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.dtype(<span class=\"built_in\">object</span>, align, copy)</span><br></pre></td></tr></table></figure>\n<p>object - 要转换为的数据类型对象<br />\n align - 如果为 true，填充字段使其类似 C 的结构体。<br />\ncopy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">dt = np.dtype(np.int8)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(dt)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结构化数据类型</span></span><br><span class=\"line\">dt = np.dtype([(<span class=\"string\">&quot;age&quot;</span>, np.int8)])</span><br><span class=\"line\">a = np.array([(<span class=\"number\">10</span>,), (<span class=\"number\">20</span>,), (<span class=\"number\">30</span>,)], dtype=dt)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[<span class=\"string\">&quot;age&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">student = np.dtype([(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;S20&quot;</span>), (<span class=\"string\">&quot;age&quot;</span>, <span class=\"string\">&quot;i4&quot;</span>), (<span class=\"string\">&quot;marks&quot;</span>, <span class=\"string\">&quot;f4&quot;</span>)])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(student)</span><br><span class=\"line\">b = np.array([(<span class=\"string\">&quot;abc&quot;</span>, <span class=\"number\">21</span>, <span class=\"number\">50</span>), (<span class=\"string\">&quot;xyz&quot;</span>, <span class=\"number\">18</span>, <span class=\"number\">75</span>)], dtype=student)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>对应类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b</td>\n<td>布尔型</td>\n</tr>\n<tr>\n<td>i</td>\n<td>有符号整形</td>\n</tr>\n<tr>\n<td>u</td>\n<td>无符号整形 integer</td>\n</tr>\n<tr>\n<td>f</td>\n<td>浮点型</td>\n</tr>\n<tr>\n<td>c</td>\n<td>复数浮点型</td>\n</tr>\n<tr>\n<td>m</td>\n<td>timedelta</td>\n</tr>\n<tr>\n<td>M</td>\n<td>datatime</td>\n</tr>\n<tr>\n<td>O</td>\n<td>（python）对象</td>\n</tr>\n<tr>\n<td>S，a</td>\n<td>（byte-）字符串</td>\n</tr>\n<tr>\n<td>U</td>\n<td>Unicode</td>\n</tr>\n<tr>\n<td>V</td>\n<td>原始数据（void)</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"数组属性\"><a class=\"anchor\" href=\"#数组属性\">#</a> 数组属性</h1>\n<p>NumPy 数组的维数称为秩（rank），秩就是轴的数量，即数组的维度，一维数组的秩为 1，二维数组的秩为 2，以此类推。</p>\n<p>在 NumPy 中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量 —— 秩，就是数组的维数。</p>\n<p>很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第 1 轴进行操作，即对每一行进行操作。</p>\n<p>NumPy 的数组中比较重要 ndarray 对象属性有：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ndarray.ndim</td>\n<td>数组的秩（rank），即数组的维度数量或轴的数量。</td>\n</tr>\n<tr>\n<td>ndarray.shape</td>\n<td>数组的维度，表示数组在每个轴上的大小。对于二维数组（矩阵），表示其行数和列数。</td>\n</tr>\n<tr>\n<td>ndarray.size</td>\n<td>数组中元素的总个数，等于 ndarray.shape 中各个轴上大小的乘积。</td>\n</tr>\n<tr>\n<td>ndarray.dtype</td>\n<td>数组中元素的数据类型。</td>\n</tr>\n<tr>\n<td>ndarray.itemsize</td>\n<td>数组中每个元素的大小，以字节为单位。</td>\n</tr>\n<tr>\n<td>ndarray.flags</td>\n<td>包含有关内存布局的信息，如是否为 C 或 Fortran 连续存储，是否为只读等。</td>\n</tr>\n<tr>\n<td>ndarray.real</td>\n<td>数组中每个元素的实部（如果元素类型为复数）。</td>\n</tr>\n<tr>\n<td>ndarray.imag</td>\n<td>数组中每个元素的虚部（如果元素类型为复数）。</td>\n</tr>\n<tr>\n<td>ndarray.data</td>\n<td>实际存储数组元素的缓冲区，一般通过索引访问元素，不直接使用该属性。</td>\n</tr>\n</tbody>\n</table>\n<p>ndarray.flags 返回 ndarray 对象的内存信息，包含以下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C_CONTIGUOUS (C)</td>\n<td>数据是在一个单一的 C 风格的连续段中</td>\n</tr>\n<tr>\n<td>F_CONTIGUOUS (F)</td>\n<td>数据是在一个单一的 Fortran 风格的连续段中</td>\n</tr>\n<tr>\n<td>OWNDATA (O)</td>\n<td>数组拥有它所使用的内存或从另一个对象中借用它</td>\n</tr>\n<tr>\n<td>WRITEABLE (W)</td>\n<td>数据区域可以被写入，将该值设置为 False，则数据为只读</td>\n</tr>\n<tr>\n<td>ALIGNED (A)</td>\n<td>数据和所有元素都适当地对齐到硬件上</td>\n</tr>\n<tr>\n<td>UPDATEIFCOPY (U)</td>\n<td>这个数组是其它数组的一个副本，当这个数组被释放时，原数组的内容将被更新</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">24</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.ndim)</span><br><span class=\"line\">b = a.reshape(<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b.ndim)</span><br><span class=\"line\"></span><br><span class=\"line\">c = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c.shape)</span><br><span class=\"line\"></span><br><span class=\"line\">d = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\">d.shape = (<span class=\"number\">3</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(d)</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], dtype=np.int8)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x.itemsize)</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x.flags)</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建数组\"><a class=\"anchor\" href=\"#创建数组\">#</a> 创建数组</h2>\n<p>numpy.empty 方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.empty(shape, dtype = <span class=\"built_in\">float</span>, order = <span class=\"string\">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\">x = np.empty([<span class=\"number\">3</span>,<span class=\"number\">2</span>], dtype = <span class=\"built_in\">int</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span> (x)</span><br></pre></td></tr></table></figure>\n<p>numpy.zeros<br />\n 创建指定大小的数组，数组元素以 0 来填充：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.zeros(shape, dtype = <span class=\"built_in\">float</span>, order = <span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">```numpy.ones_like</span><br><span class=\"line\">numpy.ones_like 用于创建一个与给定数组具有相同形状的数组，数组元素以 <span class=\"number\">1</span> 来填充。</span><br><span class=\"line\"></span><br><span class=\"line\">numpy.ones 和 numpy.ones_like 都是用于创建一个指定形状的数组，其中所有元素都是 <span class=\"number\">1</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">它们之间的区别在于：numpy.ones 可以直接指定要创建的数组的形状，而 numpy.ones_like 则是创建一个与给定数组具有相同形状的数组。</span><br><span class=\"line\"></span><br><span class=\"line\">numpy.ones</span><br><span class=\"line\">创建指定形状的数组，数组元素以 <span class=\"number\">1</span> 来填充：</span><br><span class=\"line\"></span><br><span class=\"line\">```python</span><br><span class=\"line\">numpy.ones(shape, dtype = <span class=\"literal\">None</span>, order = <span class=\"string\">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>numpy.zeros_like 用于创建一个与给定数组具有相同形状的数组，数组元素以 0 来填充。</p>\n<p>numpy.zeros 和 numpy.zeros_like 都是用于创建一个指定形状的数组，其中所有元素都是 0。</p>\n<p>它们之间的区别在于：numpy.zeros 可以直接指定要创建的数组的形状，而 numpy.zeros_like 则是创建一个与给定数组具有相同形状的数组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.zeros_like(a, dtype=<span class=\"literal\">None</span>, order=<span class=\"string\">&#x27;K&#x27;</span>, subok=<span class=\"literal\">True</span>, shape=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<p>numpy.ones_like<br />\nnumpy.ones_like 用于创建一个与给定数组具有相同形状的数组，数组元素以 1 来填充。</p>\n<p>numpy.ones 和 numpy.ones_like 都是用于创建一个指定形状的数组，其中所有元素都是 1。</p>\n<p>它们之间的区别在于：numpy.ones 可以直接指定要创建的数组的形状，而 numpy.ones_like 则是创建一个与给定数组具有相同形状的数组。</p>\n<h2 id=\"从数值范围创建数组\"><a class=\"anchor\" href=\"#从数值范围创建数组\">#</a> 从数值范围创建数组</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.arange(start, stop, step, dtype)</span><br></pre></td></tr></table></figure>\n<p>numpy.linspace 函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.linspace(start, stop, num=<span class=\"number\">50</span>, endpoint=<span class=\"literal\">True</span>, retstep=<span class=\"literal\">False</span>, dtype=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>start</td>\n<td>序列的起始值</td>\n</tr>\n<tr>\n<td>stop</td>\n<td>序列的终止值，如果 endpoint 为 true，该值包含于数列中</td>\n</tr>\n<tr>\n<td>num</td>\n<td>要生成的等步长的样本数量，默认为 50</td>\n</tr>\n<tr>\n<td>endpoint</td>\n<td>该值为 true 时，数列中包含 stop 值，反之不包含，默认是 True。</td>\n</tr>\n<tr>\n<td>retstep</td>\n<td>如果为 True 时，生成的数组中会显示间距，反之不显示。</td>\n</tr>\n<tr>\n<td>dtype</td>\n<td>ndarray 的数据类型</td>\n</tr>\n</tbody>\n</table>\n<p>numpy.logspace 函数用于创建一个于等比数列。格式如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.logspace(start, stop, num=<span class=\"number\">50</span>, endpoint=<span class=\"literal\">True</span>, base=<span class=\"number\">10.0</span>, dtype=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<p>base 参数意思是取对数的时候 log 的下标。</p>\n<h2 id=\"引索与切片\"><a class=\"anchor\" href=\"#引索与切片\">#</a> 引索与切片</h2>\n<p>冒号：的解释：如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 [2:7]，那么则提取两个索引 (不包括停止索引) 之间的项。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">10</span>)</span><br><span class=\"line\">s = <span class=\"built_in\">slice</span>(<span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[s])</span><br><span class=\"line\"></span><br><span class=\"line\">b = np.arange(<span class=\"number\">10</span>)</span><br><span class=\"line\">c = b[<span class=\"number\">2</span>:<span class=\"number\">7</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"></span><br><span class=\"line\">d = np.arange(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(d[<span class=\"number\">2</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\">e = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(e)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;从数组引索a[1:]处开始切割&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(e[<span class=\"number\">1</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\">f = e.copy()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(f)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(f[..., <span class=\"number\">1</span>])  <span class=\"comment\"># 第二列元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(f[<span class=\"number\">1</span>, ...])  <span class=\"comment\"># 第二列元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(f[..., <span class=\"number\">1</span>:])</span><br></pre></td></tr></table></figure>\n<h2 id=\"高级引索\"><a class=\"anchor\" href=\"#高级引索\">#</a> 高级引索</h2>\n<p>整数数组索引是指使用一个数组来访问另一个数组的元素。这个数组中的每个元素都是目标数组中某个维度上的索引值。</p>\n<p>以下实例获取数组中 (0,0)，(1,1) 和 (2,0) 位置处的元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">x = np.array([[<span class=\"number\">1</span>,  <span class=\"number\">2</span>],  [<span class=\"number\">3</span>,  <span class=\"number\">4</span>],  [<span class=\"number\">5</span>,  <span class=\"number\">6</span>]]) </span><br><span class=\"line\">y = x[[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>],  [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>]]  </span><br><span class=\"line\"><span class=\"built_in\">print</span> (y)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>], [<span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\">y = x[[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>]]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.array([[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>], [<span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">rows = np.array([[<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">3</span>, <span class=\"number\">3</span>]])</span><br><span class=\"line\">cols = np.array([[<span class=\"number\">0</span>, <span class=\"number\">2</span>], [<span class=\"number\">0</span>, <span class=\"number\">2</span>]])</span><br><span class=\"line\">y = x[rows, cols]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]])</span><br><span class=\"line\">b = a[<span class=\"number\">1</span>:<span class=\"number\">3</span>, <span class=\"number\">1</span>:<span class=\"number\">3</span>]</span><br><span class=\"line\">c = a[<span class=\"number\">1</span>:<span class=\"number\">3</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]]</span><br><span class=\"line\">d = a[..., <span class=\"number\">1</span>:]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(d)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">x = np.array([[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>], [<span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x&gt;5&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x[x &gt; <span class=\"number\">5</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([np.nan, <span class=\"number\">1</span>, <span class=\"number\">2</span>, np.nan, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[~np.isnan(a)])</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span> + <span class=\"number\">6j</span>, <span class=\"number\">5</span>, <span class=\"number\">3.5</span> + <span class=\"number\">5j</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[np.iscomplex(a)])</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.arange(<span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\">x2 = x[[<span class=\"number\">0</span>, <span class=\"number\">6</span>]]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x2)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x2[<span class=\"number\">0</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x2[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.arange(<span class=\"number\">32</span>).reshape((<span class=\"number\">8</span>, <span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;读取下标对应的行&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x[[<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;倒序索引&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x[[-<span class=\"number\">4</span>, -<span class=\"number\">2</span>, -<span class=\"number\">1</span>, -<span class=\"number\">7</span>]])</span><br></pre></td></tr></table></figure>\n<h2 id=\"广播\"><a class=\"anchor\" href=\"#广播\">#</a> 广播</h2>\n<p>广播 (Broadcast) 是 numpy 对不同形状 (shape) 的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p>\n<p>如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">a = np.array([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]) </span><br><span class=\"line\">b = np.array([<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>,<span class=\"number\">40</span>]) </span><br><span class=\"line\">c = a * b </span><br><span class=\"line\"><span class=\"built_in\">print</span> (c)</span><br></pre></td></tr></table></figure>\n<p>输出结果： <code>[ 10  40  90 160]</code> <br />\n 当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">a = np.array([[ <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">           [<span class=\"number\">10</span>,<span class=\"number\">10</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">           [<span class=\"number\">20</span>,<span class=\"number\">20</span>,<span class=\"number\">20</span>],</span><br><span class=\"line\">           [<span class=\"number\">30</span>,<span class=\"number\">30</span>,<span class=\"number\">30</span>]])</span><br><span class=\"line\">b = np.array([<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a + b)</span><br></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[ 0  1  2]</span><br><span class=\"line\"> [10 11 12]</span><br><span class=\"line\"> [20 21 22]</span><br><span class=\"line\"> [30 31 32]]</span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代数组\"><a class=\"anchor\" href=\"#迭代数组\">#</a> 迭代数组</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">6</span>).reshape(<span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;迭代输出元素：&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> np.nditer(a):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(x, end=<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> np.nditer(a.T):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(x, end=<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> np.nditer(a.T.copy(order=<span class=\"string\">&quot;C&quot;</span>)):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(x, end=<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># output</span></span><br><span class=\"line\"><span class=\"comment\"># 0, 1, 2, 3, 4, 5,</span></span><br><span class=\"line\"><span class=\"comment\"># 0, 3, 1, 4, 2, 5,</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># for x in np.nditer(a, order=&#x27;F&#x27;):Fortran order，即是列序优先；</span></span><br><span class=\"line\"><span class=\"comment\"># for x in np.nditer(a.T, order=&#x27;C&#x27;):C order，即是行序优先；</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">0</span>, <span class=\"number\">60</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">a = a.reshape(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原始数组是：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;以 C 风格顺序排序：&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> np.nditer(a, order=<span class=\"string\">&quot;C&quot;</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(x, end=<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;以 F 风格顺序排序：&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> np.nditer(a, order=<span class=\"string\">&quot;F&quot;</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(x, end=<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># nditer 对象有另一个可选参数 op_flags。 默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值的修改，必须指定 readwrite 或者 writeonly 的模式。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">0</span>, <span class=\"number\">60</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">a = a.reshape(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原始数组是：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># for x in np.nditer(a, op_flags=[&quot;readwrite&quot;]):</span></span><br><span class=\"line\"><span class=\"comment\">#    x[...] = 2 * x</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;修改后的数组是：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">0</span>, <span class=\"number\">60</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">a = a.reshape(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第一个数组为：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第二个数组为：&quot;</span>)</span><br><span class=\"line\">b = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], dtype=<span class=\"built_in\">int</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;修改后的数组为：&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> np.nditer([a, b]):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;%d:%d&quot;</span> % (x, y), end=<span class=\"string\">&quot;, &quot;</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组操作\"><a class=\"anchor\" href=\"#数组操作\">#</a> 数组操作</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原始数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\">b = a.reshape(<span class=\"number\">4</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;修改后的数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">9</span>).reshape((<span class=\"number\">3</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原始数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> a:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(row)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;迭代后的数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> a.flat:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(element)</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">8</span>).reshape(<span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;展开后的数组:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.flatten())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;以F风格顺序展开的数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.flatten(order=<span class=\"string\">&quot;F&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.ravel() 展平的数组元素，顺序通常是&quot;C风格&quot;，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">8</span>).reshape(<span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用 ravel 函数之后：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.ravel())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;以 F 风格顺序调用 ravel 函数之后：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.ravel(order=<span class=\"string\">&quot;F&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">12</span>).reshape(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.transpose(a))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.T)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建了三维的 ndarray</span></span><br><span class=\"line\">a = np.arange(<span class=\"number\">8</span>).reshape(<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;获取数组中一个值：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.where(a == <span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>])  <span class=\"comment\"># 为 6</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将轴 2 滚动到轴 0（宽度到深度）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用 rollaxis 函数：&quot;</span>)</span><br><span class=\"line\">b = np.rollaxis(a, <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"comment\"># 查看元素 a[1,1,0]，即 6 的坐标，变成 [0, 1, 1]</span></span><br><span class=\"line\"><span class=\"comment\"># 最后一个 0 移动到最前面</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.where(b == <span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将轴 2 滚动到轴 1：（宽度到高度）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用 rollaxis 函数：&quot;</span>)</span><br><span class=\"line\">c = np.rollaxis(a, <span class=\"number\">2</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"><span class=\"comment\"># 查看元素 a[1,1,0]，即 6 的坐标，变成 [1, 0, 1]</span></span><br><span class=\"line\"><span class=\"comment\"># 最后的 0 和 它前面的 1 对换位置</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.where(c == <span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建了三维的 ndarray</span></span><br><span class=\"line\">a = np.arange(<span class=\"number\">8</span>).reshape(<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 现在交换轴 0（深度方向）到轴 2（宽度方向）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用 swapaxes 函数后的数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.swapaxes(a, <span class=\"number\">2</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.broadcast_to 函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">4</span>).reshape(<span class=\"number\">1</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用 broadcast_to 函数之后：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.broadcast_to(a, (<span class=\"number\">4</span>, <span class=\"number\">4</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.expand_dims 函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下:</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">x = np.array(([<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数组 x：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">y = np.expand_dims(x, axis=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数组 y：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数组 x 和 y 的形状：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x.shape, y.shape)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 在位置 1 插入轴</span></span><br><span class=\"line\">y = np.expand_dims(x, axis=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;在位置 1 插入轴之后的数组 y：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x.ndim 和 y.ndim：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x.ndim, y.ndim)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x.shape 和 y.shape：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x.shape, y.shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.squeeze 函数从给定数组的形状中删除一维的条目，函数格式如下：</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">x = np.arange(<span class=\"number\">9</span>).reshape(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数组 x：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">y = np.squeeze(x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数组 y：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数组 x 和 y 的形状：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x.shape, y.shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.concatenate 函数用于沿指定轴连接相同形状的两个或多个数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\">b = np.array([[<span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;沿着轴0链接两个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.concatenate((a, b)))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;沿着轴1链接两个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.concatenate((a, b), axis=<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.concatenate((a, b), axis=<span class=\"number\">1</span>).shape)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.stack 函数用于沿新轴连接数组序列</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第一个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">b = np.array([[<span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第二个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;沿轴 0 堆叠两个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.stack((a, b), <span class=\"number\">0</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;沿轴 1 堆叠两个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.stack((a, b), <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.stack((a, b), <span class=\"number\">0</span>).shape)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.stack((a, b), <span class=\"number\">1</span>).shape)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>数组及操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>split</td>\n<td>将一个数组分割为多个子数组</td>\n</tr>\n<tr>\n<td>hsplit</td>\n<td>将一个数组水平分割为多个子数组（按列）</td>\n</tr>\n<tr>\n<td>vsplit</td>\n<td>将一个数组垂直分割为多个子数组（按行）</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第一个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;将数组分为三个大小相等的数组:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.split(a, <span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;标明位置的分割：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.split(a, [<span class=\"number\">4</span>, <span class=\"number\">7</span>]))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;rest&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.split(a, <span class=\"number\">3</span>)[<span class=\"number\">2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">16</span>).reshape(<span class=\"number\">4</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;第一个数组：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;默认分割（0轴）：&#x27;</span>)</span><br><span class=\"line\">b = np.split(a,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;沿水平方向分割：&#x27;</span>)</span><br><span class=\"line\">c = np.split(a,<span class=\"number\">2</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;沿水平方向分割：&#x27;</span>)</span><br><span class=\"line\">d= np.hsplit(a,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(d)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"数组元素的添加与删除\"><a class=\"anchor\" href=\"#数组元素的添加与删除\">#</a> 数组元素的添加与删除</h2>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>元素及描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>resize</td>\n<td>返回指定形状的新数组</td>\n</tr>\n<tr>\n<td>append</td>\n<td>将值添加到数组末尾</td>\n</tr>\n<tr>\n<td>insert</td>\n<td>沿指定轴将值插入到指定下标之前</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>删掉某个轴的子数组，并返回删除后的新数组</td>\n</tr>\n<tr>\n<td>unique</td>\n<td>查找数组内的唯一元素</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\">b = np.resize(a, (<span class=\"number\">3</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">c = np.resize(a, (<span class=\"number\">4</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;b:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;c:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.append(a, [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.append(a, [[<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]], axis=<span class=\"number\">0</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.append(a, [[<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]], axis=<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>], [<span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;未传递Axis参数，在删除之前输入数组会被展开&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.insert(a, <span class=\"number\">3</span>, [<span class=\"number\">11</span>, <span class=\"number\">12</span>]))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;未传递Axis参数，会广播值数组来匹配输入数组&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.insert(a, <span class=\"number\">1</span>, <span class=\"number\">11</span>, axis=<span class=\"number\">0</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.insert(a, <span class=\"number\">1</span>, <span class=\"number\">11</span>, axis=<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">12</span>).reshape(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;未传递Axis参数，在删除之前输入数组会被展开&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.delete(a, <span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;删除第二列：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.delete(a, <span class=\"number\">1</span>, axis=<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;包含从数组中删除的替代值的切片：&quot;</span>)</span><br><span class=\"line\">a = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.delete(a, np.s_[::<span class=\"number\">2</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第一个数组的去重值：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.unique(a))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;去重数组的索引数组：&quot;</span>)</span><br><span class=\"line\">u, indices = np.unique(a, return_index=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(indices)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;去重数组的下标：&quot;</span>)</span><br><span class=\"line\">u, indices = np.unique(a, return_inverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(indices)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(u[indices])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;返回去重元素的重复数量：&quot;</span>)</span><br><span class=\"line\">u, indices = np.unique(a, return_counts=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(u)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(indices)</span><br></pre></td></tr></table></figure>\n<h2 id=\"位运算\"><a class=\"anchor\" href=\"#位运算\">#</a> 位运算</h2>\n<p>略</p>\n<h2 id=\"字符串函数\"><a class=\"anchor\" href=\"#字符串函数\">#</a> 字符串函数</h2>\n<p>虽然似乎用不上（主要是看累了），但还是把表列出来</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add()</td>\n<td>对两个数组的逐个字符串元素进行连接</td>\n</tr>\n<tr>\n<td>multiply()</td>\n<td>返回按元素多重连接后的字符串</td>\n</tr>\n<tr>\n<td>center()</td>\n<td>居中字符串</td>\n</tr>\n<tr>\n<td>capitalize()</td>\n<td>将字符串第一个字母转换为大写</td>\n</tr>\n<tr>\n<td>title()</td>\n<td>将字符串的每个单词的第一个字母转换为大写</td>\n</tr>\n<tr>\n<td>lower()</td>\n<td>数组元素转换为小写</td>\n</tr>\n<tr>\n<td>upper()</td>\n<td>数组元素转换为大写</td>\n</tr>\n<tr>\n<td>split()</td>\n<td>指定分隔符对字符串进行分割，并返回数组列表</td>\n</tr>\n<tr>\n<td>splitlines()</td>\n<td>返回元素中的行列表，以换行符分割</td>\n</tr>\n<tr>\n<td>strip()</td>\n<td>移除元素开头或者结尾处的特定字符</td>\n</tr>\n<tr>\n<td>join()</td>\n<td>通过指定分隔符来连接数组中的元素</td>\n</tr>\n<tr>\n<td>replace()</td>\n<td>使用新字符串替换字符串中的所有子字符串</td>\n</tr>\n<tr>\n<td>decode()</td>\n<td>数组元素依次调用 str.decode</td>\n</tr>\n<tr>\n<td>encode()</td>\n<td>数组元素依次调用 str.encode</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;连接两个字符串：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.char.add([<span class=\"string\">&quot;hello&quot;</span>], [<span class=\"string\">&quot; xyz&quot;</span>]))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;连接示例：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.char.add([<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;hi&quot;</span>], [<span class=\"string\">&quot; abc&quot;</span>, <span class=\"string\">&quot; xyz&quot;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.char.multiply(<span class=\"string\">&quot;Runoob &quot;</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分隔符默认为空格</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.char.split(<span class=\"string\">&quot;i love you&quot;</span>))</span><br><span class=\"line\"><span class=\"comment\"># 分隔符指定</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.char.split(<span class=\"string\">&quot;www.baidu.com&quot;</span>, sep=<span class=\"string\">&quot;.&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.char.splitlines() 函数以换行符作为分隔符来分割字符串，并返回数组。</span></span><br><span class=\"line\"><span class=\"comment\"># 换行符 \\n</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.char.splitlines(<span class=\"string\">&#x27;i\\nlike runoob?&#x27;</span>)) </span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.char.splitlines(<span class=\"string\">&#x27;i\\rlike runoob?&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 操作字符串</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.char.join(<span class=\"string\">&#x27;:&#x27;</span>,<span class=\"string\">&#x27;runoob&#x27;</span>))</span><br><span class=\"line\"><span class=\"comment\"># 指定多个分隔符操作数组元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.char.join([<span class=\"string\">&#x27;:&#x27;</span>,<span class=\"string\">&#x27;-&#x27;</span>],[<span class=\"string\">&#x27;runoob&#x27;</span>,<span class=\"string\">&#x27;google&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.char.replace (<span class=\"string\">&#x27;i like runoob&#x27;</span>, <span class=\"string\">&#x27;oo&#x27;</span>, <span class=\"string\">&#x27;cc&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"数学函数\"><a class=\"anchor\" href=\"#数学函数\">#</a> 数学函数</h2>\n<ul>\n<li>np.sin()</li>\n<li>np.cos()</li>\n<li>np.tan()</li>\n<li>np.around () 四舍五入</li>\n<li>np.floor()</li>\n<li>np.ceil()</li>\n</ul>\n<h2 id=\"算术函数\"><a class=\"anchor\" href=\"#算术函数\">#</a> 算术函数</h2>\n<ul>\n<li>np.add()</li>\n<li>np.subtract()</li>\n<li>np.multiply()</li>\n<li>np.divide()</li>\n<li>np.reciprocal () 求倒数</li>\n<li>np.power () 幂函数</li>\n<li>np.mod () 取模</li>\n</ul>\n<h2 id=\"统计函数\"><a class=\"anchor\" href=\"#统计函数\">#</a> 统计函数</h2>\n<p>numpy.amin () 用于计算数组中的元素沿指定轴的最小值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.amin(a, axis=<span class=\"literal\">None</span>, out=<span class=\"literal\">None</span>, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</span><br></pre></td></tr></table></figure>\n<p>numpy.amax () 用于计算数组中的元素沿指定轴的最大值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.amax(a, axis=<span class=\"literal\">None</span>, out=<span class=\"literal\">None</span>, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li>a: 输入的数组，可以是一个 NumPy 数组或类似数组的对象。</li>\n<li>axis: 可选参数，用于指定在哪个轴上计算最小值。如果不提供此参数，则返回整个数组的最小值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴。</li>\n<li>out: 可选参数，用于指定结果的存储位置。</li>\n<li>keepdims: 可选参数，如果为 True，将保持结果数组的维度数目与输入数组相同。如果为 False（默认值），则会去除计算后维度为 1 的轴。</li>\n<li>initial: 可选参数，用于指定一个初始值，然后在数组的元素上计算最小值。</li>\n<li>where: 可选参数，一个布尔数组，用于指定仅考虑满足条件的元素。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">a = np.array([[<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">5</span>],[<span class=\"number\">8</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>]])  </span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;我们的数组是：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (a)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;调用 amin() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.amin(a,<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;再次调用 amin() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.amin(a,<span class=\"number\">0</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;调用 amax() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.amax(a))</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;再次调用 amax() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.amax(a, axis =  <span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure>\n<p>numpy.ptp () 函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.ptp(a, axis=<span class=\"literal\">None</span>, out=<span class=\"literal\">None</span>, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</span><br></pre></td></tr></table></figure>\n<p>numpy.percentile()<br />\n 百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数 numpy.percentile () 接受以下参数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.percentile(a, q, axis)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">a = np.array([[<span class=\"number\">10</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>], [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;我们的数组是：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (a)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;调用 percentile() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 50% 的分位数，就是 a 里排序之后的中位数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.percentile(a, <span class=\"number\">50</span>)) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># axis 为 0，在纵列上求</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.percentile(a, <span class=\"number\">50</span>, axis=<span class=\"number\">0</span>)) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># axis 为 1，在横行上求</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.percentile(a, <span class=\"number\">50</span>, axis=<span class=\"number\">1</span>)) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 保持维度不变</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.percentile(a, <span class=\"number\">50</span>, axis=<span class=\"number\">1</span>, keepdims=<span class=\"literal\">True</span>))</span><br></pre></td></tr></table></figure>\n<p>numpy.median () 函数用于计算数组 a 中元素的中位数（中值）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.median(a, axis=<span class=\"literal\">None</span>, out=<span class=\"literal\">None</span>, overwrite_input=<span class=\"literal\">False</span>, keepdims=&lt;no value&gt;)</span><br></pre></td></tr></table></figure>\n<p>numpy.mean () 函数返回数组中元素的算术平均值，如果提供了轴，则沿其计算。</p>\n<p>算术平均值是沿轴的元素的总和除以元素的数量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.mean(a, axis=<span class=\"literal\">None</span>, dtype=<span class=\"literal\">None</span>, out=<span class=\"literal\">None</span>, keepdims=&lt;no value&gt;)</span><br></pre></td></tr></table></figure>\n<p>numpy.average () 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。</p>\n<p>该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。</p>\n<p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。</p>\n<p>考虑数组 [1,2,3,4] 和相应的权重 [4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.average(a, axis=<span class=\"literal\">None</span>, weights=<span class=\"literal\">None</span>, returned=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">a = np.array([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>])  </span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;我们的数组是：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (a)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;调用 average() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.average(a))</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 不指定权重时相当于 mean 函数</span></span><br><span class=\"line\">wts = np.array([<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>])  </span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;再次调用 average() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.average(a,weights = wts))</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 如果 returned 参数设为 true，则返回权重的和  </span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;权重的和：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.average([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,  <span class=\"number\">4</span>],weights =  [<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>], returned =  <span class=\"literal\">True</span>))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>标准差：np.std ()<br />\n 方差：np.var ()</p>\n<h2 id=\"排序-条件筛选函数\"><a class=\"anchor\" href=\"#排序-条件筛选函数\">#</a> 排序、条件筛选函数</h2>\n<table>\n<thead>\n<tr>\n<th>种类</th>\n<th>速度</th>\n<th>最坏情况</th>\n<th>工作空间</th>\n<th>稳定性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>'quicksort'（快速排序）</td>\n<td>1</td>\n<td>O(n^2)</td>\n<td>0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>'mergesort'（归并排序）</td>\n<td>2</td>\n<td>O(n*log(n))</td>\n<td>~n/2</td>\n<td>是</td>\n</tr>\n<tr>\n<td>'heapsort'（堆排序）</td>\n<td>3</td>\n<td>O(n*log(n))</td>\n<td>0</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.sort(a, axis, kind, order)</span><br></pre></td></tr></table></figure>\n<p>numpy.argsort () 函数返回的是数组值从小到大的索引值。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>msort(a)</td>\n<td>数组按第一个轴排序，返回排序后的数组副本。np.msort (a) 相等于 np.sort (a, axis=0)。</td>\n</tr>\n<tr>\n<td>sort_complex(a)</td>\n<td>对复数按照先实部后虚部的顺序进行排序。</td>\n</tr>\n<tr>\n<td>partition(a, kth[, axis, kind, order])</td>\n<td>指定一个数，对数组进行分区</td>\n</tr>\n<tr>\n<td>argpartition(a, kth[, axis, kind, order])</td>\n<td>可以通过关键字 kind 指定算法沿着指定轴对数组进行分区</td>\n</tr>\n</tbody>\n</table>\n<p>numpy.argmax () 和 numpy.argmin () 函数分别沿给定轴返回最大和最小元素的索引。</p>\n<p>numpy.nonzero () 函数返回输入数组中非零元素的索引。</p>\n<p>numpy.where () 函数返回输入数组中满足给定条件的元素的索引。</p>\n<p>numpy.extract () 函数根据某个条件从数组中抽取元素，返回满条件的元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">x = np.arange(<span class=\"number\">9.</span>).reshape(<span class=\"number\">3</span>,  <span class=\"number\">3</span>)  </span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;我们的数组是：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (x)</span><br><span class=\"line\"><span class=\"comment\"># 定义条件, 选择偶数元素</span></span><br><span class=\"line\">condition = np.mod(x,<span class=\"number\">2</span>)  ==  <span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;按元素的条件值：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (condition)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;使用条件提取元素：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.extract(condition, x))</span><br></pre></td></tr></table></figure>\n<h2 id=\"矩阵库npmatlib\"><a class=\"anchor\" href=\"#矩阵库npmatlib\">#</a> 矩阵库 np.matlib</h2>\n<ul>\n<li>matlib.empty () 函数返回一个新的矩阵</li>\n<li>numpy.matlib.zeros () 函数创建一个以 0 填充的矩阵。</li>\n<li>numpy.matlib.ones () 函数创建一个以 1 填充的矩阵。</li>\n<li>numpy.matlib.eye () 函数返回一个矩阵，对角线元素为 1，其他位置为零。</li>\n<li>numpy.matlib.identity () 函数返回给定大小的单位矩阵。</li>\n<li>numpy.matlib.rand () 函数创建一个给定大小的矩阵，数据是随机填充的。</li>\n</ul>\n<h2 id=\"线性代数\"><a class=\"anchor\" href=\"#线性代数\">#</a> 线性代数</h2>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dot</td>\n<td>两个数组的点积，即元素对应相乘。</td>\n</tr>\n<tr>\n<td>vdot</td>\n<td>两个向量的点积</td>\n</tr>\n<tr>\n<td>inner</td>\n<td>两个数组的内积</td>\n</tr>\n<tr>\n<td>matmul</td>\n<td>两个数组的矩阵积</td>\n</tr>\n<tr>\n<td>determinant</td>\n<td>数组的行列式</td>\n</tr>\n<tr>\n<td>solve</td>\n<td>求解线性矩阵方程</td>\n</tr>\n<tr>\n<td>inv</td>\n<td>计算矩阵的乘法逆矩阵</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"io\"><a class=\"anchor\" href=\"#io\">#</a> IO</h2>\n<p>savetxt () 函数是以简单的文本文件格式存储数据，对应的使用 loadtxt () 函数来获取数据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.loadtxt(FILENAME, dtype=<span class=\"built_in\">int</span>, delimiter=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">np.savetxt(FILENAME, a, fmt=<span class=\"string\">&quot;%d&quot;</span>, delimiter=<span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">a=np.arange(<span class=\"number\">0</span>,<span class=\"number\">10</span>,<span class=\"number\">0.5</span>).reshape(<span class=\"number\">4</span>,-<span class=\"number\">1</span>)</span><br><span class=\"line\">np.savetxt(<span class=\"string\">&quot;out.txt&quot;</span>,a,fmt=<span class=\"string\">&quot;%d&quot;</span>,delimiter=<span class=\"string\">&quot;,&quot;</span>) <span class=\"comment\"># 改为保存为整数，以逗号分隔</span></span><br><span class=\"line\">b = np.loadtxt(<span class=\"string\">&quot;out.txt&quot;</span>,delimiter=<span class=\"string\">&quot;,&quot;</span>) <span class=\"comment\"># load 时也要指定为逗号分隔</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br></pre></td></tr></table></figure>\n<h2 id=\"matlibplot\"><a class=\"anchor\" href=\"#matlibplot\">#</a> matlibPlot</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt </span><br><span class=\"line\"> </span><br><span class=\"line\">x = np.arange(<span class=\"number\">1</span>,<span class=\"number\">11</span>) </span><br><span class=\"line\">y =  <span class=\"number\">2</span>  * x +  <span class=\"number\">5</span> </span><br><span class=\"line\">plt.title(<span class=\"string\">&quot;Matplotlib demo&quot;</span>) </span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&quot;x axis caption&quot;</span>) </span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&quot;y axis caption&quot;</span>) </span><br><span class=\"line\">plt.plot(x,y) </span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt </span><br><span class=\"line\"><span class=\"comment\"># 计算正弦和余弦曲线上的点的 x 和 y 坐标 </span></span><br><span class=\"line\">x = np.arange(<span class=\"number\">0</span>,  <span class=\"number\">3</span>  * np.pi,  <span class=\"number\">0.1</span>) </span><br><span class=\"line\">y_sin = np.sin(x) </span><br><span class=\"line\">y_cos = np.cos(x)  </span><br><span class=\"line\"><span class=\"comment\"># 建立 subplot 网格，高为 2，宽为 1  </span></span><br><span class=\"line\"><span class=\"comment\"># 激活第一个 subplot</span></span><br><span class=\"line\">plt.subplot(<span class=\"number\">2</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>)  </span><br><span class=\"line\"><span class=\"comment\"># 绘制第一个图像 </span></span><br><span class=\"line\">plt.plot(x, y_sin) </span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Sine&#x27;</span>)  </span><br><span class=\"line\"><span class=\"comment\"># 将第二个 subplot 激活，并绘制第二个图像</span></span><br><span class=\"line\">plt.subplot(<span class=\"number\">2</span>,  <span class=\"number\">1</span>,  <span class=\"number\">2</span>) </span><br><span class=\"line\">plt.plot(x, y_cos) </span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Cosine&#x27;</span>)  </span><br><span class=\"line\"><span class=\"comment\"># 展示图像</span></span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"><span class=\"comment\"># pyplot 子模块提供 bar() 函数来生成条形图。</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt </span><br><span class=\"line\">x =  [<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>] </span><br><span class=\"line\">y =  [<span class=\"number\">12</span>,<span class=\"number\">16</span>,<span class=\"number\">6</span>] </span><br><span class=\"line\">x2 =  [<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">11</span>] </span><br><span class=\"line\">y2 =  [<span class=\"number\">6</span>,<span class=\"number\">15</span>,<span class=\"number\">7</span>] </span><br><span class=\"line\">plt.bar(x, y, align =  <span class=\"string\">&#x27;center&#x27;</span>) </span><br><span class=\"line\">plt.bar(x2, y2, color =  <span class=\"string\">&#x27;g&#x27;</span>, align =  <span class=\"string\">&#x27;center&#x27;</span>) </span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Bar graph&#x27;</span>) </span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&#x27;Y axis&#x27;</span>) </span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&#x27;X axis&#x27;</span>) </span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "代码",
                "python",
                "学习笔记",
                "python"
            ]
        },
        {
            "id": "http://amentiraz.github.io/life/MeetingJazz2025-04-26/",
            "url": "http://amentiraz.github.io/life/MeetingJazz2025-04-26/",
            "title": "MeetingJazz2025-04-26",
            "date_published": "2025-04-26T09:26:02.000Z",
            "content_html": "<p>不仅是第一次来爵士酒吧，也是第一次来酒吧，有吧台，有调酒师，舞台上面摆着乐器，总共有 60、70 个观众的席位，意外的是座位基本都是满的，可能是周日晚上大家都来最后的放纵了吧。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/MeetingJazz2025-04-26-1.jpg\" alt=\"\" /><br />\n先说酒，点的 “古典”（old fashion），外表上看，在酒吧内昏暗的灯光下散发着橘子皮的光芒，里面融着一块冰块，冰块上点缀着柠檬皮。第一口下去没怎么注意，喝的稍许偏多，且没怎么过舌头的味蕾。酒水在口腔中荡漾时不知是不是冰的原因，显得十分润滑且没品出酒味，直到酒水过到喉咙里味道才绽放出来。第一反应是很润滑，感觉酒水是粘稠在一起的，伴随而来的便是一阵苦涩的味道来对酒味进行中和，而这苦味也显得很合适，刚好在酸味中和的差不多时便随之消散。酒味并没有那么冲，直到酒水入肚，酒气才慢慢上到头脑，整体来说还是很不错的。等喝着差不多一半的时候，那种又冰所带来的润滑的感觉逐渐消散了，苦味占据了高地，喝下去虽然没有那种涩的感觉，而且苦味消散的也很快，但确实是缺少了最开始粘稠的感觉。喝到最后的时候，得益于冰的融化，甜味重新占领了味觉，不知是不是柠檬的原因，口感十分的清爽。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/MeetingJazz2025-04-26-2.jpg\" alt=\"\" /><br />\n来的时候我并不知道演出的内容是什么，表演者是两位男士，也没有什么预热，直接便开始了演奏。一位负责弹奏电子琴，另一位则负责 voicing 的部分。第一首曲子是十分经典的《Autumn Leaves》。说实话，一开始我并没有听出来，最开始的旋律比起《Autumn Leaves》更像是《贝加尔湖畔》，正当我困惑的时候，也不是因为旋律很明显，反倒是因为和弦走向比较熟悉，很快便意识到了他们在弹什么。他们也没有背稿，很明显就是全程的即兴。虽然我听不出来他们弹的是什么音阶，但是很多地方都很有个人的色彩，例如钢琴师总是不舒舒服服的去解决和弦，而是留有一些余地就紧接着下面的乐句了。人声部分主要是那个人在哼哼，利用人声去模拟 Bass 或者吉他的那种弹 solo 的感觉。That's True Music。我目前的音乐鉴赏水平来说，或者说我的音乐审美来说，我是比较排斥人声的。音乐难道不就是音高、音响和音色的组合吗，为什么非要假如歌词这种其它形式的类似诗词的东西进来。在我看来，虽然歌词能够辅助人去理解音乐，但就像人透过语言去了解一个人一样，虽然门槛降低了，这难道不也是一种对事物本身的一种阉割吗？当然可能是我偏激了。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/MeetingJazz2025-04-26-3.png\" alt=\"\" /><br />\n虽说有 60 多个观众，但大部分人目测是没怎么接触过爵士的，更多是来作为一个清净的，看起来还很高雅的地方来供人们社交。也有能看出来是冲着爵士来的，最前面有一位男大学生，一个人来的，坐的笔直；坐在我们右边的应该是一对俄罗斯夫妇，当演奏出现那种很有意思的段子的时候他们发自内心的笑容也让人感到音乐的魅力。还有一对情侣一个外国男生和一个中国女生，看起来那个外国男生比较拘束，但不时和女生在聊演奏的内容。坐的靠远的地方是 5、6 位男大学生，有一位卖弄地向他的朋友说着曲子。</p>\n<p>我只听了四首歌，从 8：30 开始的演奏听到 10：40 实在熬不住便先行离开了。中间除了开始的《Autumn Leaves》，中间的两首歌都没有听出来是什么标准曲，这里面其中一首是 voicing 报幕时坦言自己很喜欢的曲目，他演奏起来也是十分的惬意，和钢琴手相互呼应，你哼一段乐句，我对上一段 solo，炫技成分很高但大家都玩的开心，观众也看得开心。最后一首是《All of Me》，由于我也没听太多的爵士曲，险些没有听出来，虽然都是标准曲，也都是即兴的演奏，但也挺不错的了。</p>\n<p>以后应该还会来，下次挑一场有吉他的学学技术。综合评价来说能给到 7 分。</p>\n",
            "tags": [
                "生活",
                "演奏会",
                "生活",
                "音乐"
            ]
        },
        {
            "id": "http://amentiraz.github.io/code/NeoVim%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/",
            "url": "http://amentiraz.github.io/code/NeoVim%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/",
            "title": "LazyVim学习笔记-安装LazyVim",
            "date_published": "2025-04-24T06:33:12.000Z",
            "content_html": "<p>感觉这个东西配起来十分的恶心，我打算按照<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sYXp5dmltLWFtYml0aW91cy1kZXZzLnBoaWxsaXBzLmNvZGVzL2NvdXJzZS9jaGFwdGVyLTEvI19pbnN0YWxsX2xhenl2aW0=\">官方</span>的操作来做一遍。</p>\n<p>一方面自己大四闲的要死，找点事做总是好的，另一方面网络上确实关于 lazyvim 的教程要么收费，要么浅尝辄止没有深入或系统的指导，所以我自己开个坑，希望能系统而全面的介绍在 windows 系统下的对于 LazyVim 和 NeoVim 的使用和书写方法。</p>\n<p>当然我也没学过 lua，若有不够严谨的地方多多包涵。</p>\n<h1 id=\"windows-terminal\"><a class=\"anchor\" href=\"#windows-terminal\">#</a> Windows Terminal</h1>\n<p>首先我们参考官方推荐的在 Windows 使用的终端。</p>\n<p>推荐安装 Windows Terminal，然后再打开系统自带的 PowerShell，这里可以直接在<em>开始菜单</em>搜索 Power Shell，效果如下：</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim1.png\" alt=\"neovim1\" /></p>\n<p>然后可以去<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmVyZGZvbnRzLmNvbS9mb250LWRvd25sb2Fkcw==\"> Nerd Font</span> 中下载自己感兴趣的字体，这里我使用的是<em> JetBrainsMono Nerd Font</em>, 解压安装包，双击其中一个 ttf 文件，点击安装。然后重新打开 PowerShell，点击上方的倒三角，点击设置，即可设置字体。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim2.png\" alt=\"\" /></p>\n<h1 id=\"neovim安装\"><a class=\"anchor\" href=\"#neovim安装\">#</a> NeoVim 安装</h1>\n<p>去<span class=\"exturl\" data-url=\"aHR0cHM6Ly9uZW92aW0uaW8v\">官网</span>安装。<br />\n我的 Windows 杂七杂八安装了太多东西，例如 WSL，所以有的问题可能我没遇到但是作者提及了。</p>\n<blockquote>\n<p>在 Windows 上，我建议使用 Windows Linux 子系统 (WSL) 并在其中进行所有开发。WSL 远远超出了本书的讨论范围，但微软和许多在线教程都对它进行了详尽的说明。选择兼容 WSL 的 Linux 发行版、进行设置并在所选终端中运行后，即可按照以下 Linux 说明安装 Neovim。</p>\n<p>如果您有理由（或偏好）在原生 Windows 上进行开发，最简单的方法是从 GitHub 上的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25lb3ZpbS9uZW92aW0v\"> neovim/neovim</span> 存储库的发布部分获取 MSI 安装程序。</p>\n<p>如果您已经使用 Winget、Chocolatey 或 Scoop 来管理 Windows 机器上的包，那么它们每个中都有一个 Neovim 包。</p>\n<p>请注意，如果您使用的 Windows 系统没有 WSL，则还需要安装 C 编译器才能获得 treesitter 支持（这基本上意味着更好的语法高亮和代码导航支持）。遗憾的是，这并非易事。相关文档已记录在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL252aW0tdHJlZXNpdHRlci9udmltLXRyZWVzaXR0ZXI=\">nvim-treesitter/nvim-treesitter</span> GitHub 仓库中，因此我在此不再赘述。</p>\n</blockquote>\n<p>这里可以先跳过这个所谓的 C 语言编译的板块，后面遇到了再做处理。</p>\n<h1 id=\"安装lazyvim\"><a class=\"anchor\" href=\"#安装lazyvim\">#</a> 安装 LazyVim</h1>\n<p>一般我们涉及到的文件夹是在  <code>C:\\Users\\你的名字\\AppData\\Local</code>  下的 nvim (自己创建的) 和 nvim-data 文件夹，这里先对它们进行清空。<br />\n然后我们便可以克隆 LazyVim 的启动模板，然后删除.git 文件夹（要是 powershell 内删不了直接手动定位过去删除一样的）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/LazyVim/starter <span class=\"variable\">$env</span>:LOCALAPPDATA\\nvim</span><br><span class=\"line\">Remove-Item <span class=\"variable\">$env</span>:LOCALAPPDATA\\nvim\\.git -Recurse -Force</span><br></pre></td></tr></table></figure>\n<p>在 PowerShell 中输入 nvim 回车，等待它下载。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim3.png\" alt=\"\" /><br />\n然后就进入到 LazyVim 界面了<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim4.png\" alt=\"\" /></p>\n<p>按 l 键可以进入插件管理界面，Lazy.nvim 拥有众多实用功能，其中最引人注目的是仅在需要时加载插件（因此得名 “Lazy”），这样你的编辑器启动速度就能飞快。它还拥有一个美观的用户界面，方便管理插件的安装和更新。如下图所示</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim5.png\" alt=\"\" /></p>\n<h1 id=\"插件的安装\"><a class=\"anchor\" href=\"#插件的安装\">#</a> 插件的安装</h1>\n<h2 id=\"markdown-preview\"><a class=\"anchor\" href=\"#markdown-preview\">#</a> markdown-preview</h2>\n<p>我自己有写日志的习惯，所以我首先安装了对于 Markdown 的相关配置<br />\n我在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3RmeWxlLmNvbS9uZW92aW0vcGx1Z2lucy90cmVuZGluZw==\">这个网站</span>搜索 markdown，并选择了 markdown-preview 插件，然后我们可以看到它提供的相关代码：</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim6.png\" alt=\"\" /></p>\n<p>接下来我们可以在./lua/plugins/ 下创建 markdown-preview.lua 文件，并在文件中写入 return 加上大括号里面的内容即可。同时我们也可以进入它提供的 github 的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lhbWNjby9tYXJrZG93bi1wcmV2aWV3Lm52aW0=\">官网</span>。在 MarkdownPreview Config 中可以看到它默认的配置和相关的键位。这里我认为 MarkdownPreview 指令太长了，于是我改了一下键位，并且设置了不自动预览和当离开 markdown buffer 时 Zion 给关闭浏览器预览。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;iamcco/markdown-preview.nvim&quot;</span>,</span><br><span class=\"line\">  build = <span class=\"string\">&quot;cd app &amp;&amp; npm install&quot;</span>,</span><br><span class=\"line\">  ft = &#123; <span class=\"string\">&quot;markdown&quot;</span> &#125;,</span><br><span class=\"line\">  cmd = &#123; <span class=\"string\">&quot;MarkdownPreview&quot;</span>, <span class=\"string\">&quot;MarkdownPreviewStop&quot;</span>, <span class=\"string\">&quot;MarkdownPreviewToggle&quot;</span> &#125;,</span><br><span class=\"line\">  init = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    vim.g.mkdp_auto_start = <span class=\"number\">0</span></span><br><span class=\"line\">    vim.g.mkdp_auto_close = <span class=\"number\">1</span></span><br><span class=\"line\">    vim.g.mkdp_refresh_slow = <span class=\"number\">0</span></span><br><span class=\"line\">    vim.g.mkdp_open_to_the_world = <span class=\"literal\">false</span></span><br><span class=\"line\">    vim.g.mkdp_browser = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    vim.g.mkdp_theme = <span class=\"string\">&quot;dark&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span>,</span><br><span class=\"line\">  keys = &#123;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;&lt;leader&gt;mp&quot;</span>, <span class=\"string\">&quot;&lt;cmd&gt;MarkdownPreviewToggle&lt;cr&gt;&quot;</span>, desc = <span class=\"string\">&quot;Toggle Markdown Preview&quot;</span> &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中文标红的解决\"><a class=\"anchor\" href=\"#中文标红的解决\">#</a> 中文标红的解决</h2>\n<p>在写 markdown 文档时我发现中文的字符往往由于拼写检查标红了。我又添加了拼写检查英文、中日韩都合法的操作，完整的代码如下</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;iamcco/markdown-preview.nvim&quot;</span>,</span><br><span class=\"line\">  build = <span class=\"string\">&quot;cd app &amp;&amp; npm install&quot;</span>,</span><br><span class=\"line\">  ft = &#123; <span class=\"string\">&quot;markdown&quot;</span> &#125;,</span><br><span class=\"line\">  cmd = &#123; <span class=\"string\">&quot;MarkdownPreview&quot;</span>, <span class=\"string\">&quot;MarkdownPreviewStop&quot;</span>, <span class=\"string\">&quot;MarkdownPreviewToggle&quot;</span> &#125;,</span><br><span class=\"line\">  init = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    vim.g.mkdp_auto_start = <span class=\"number\">0</span></span><br><span class=\"line\">    vim.g.mkdp_auto_close = <span class=\"number\">1</span></span><br><span class=\"line\">    vim.g.mkdp_refresh_slow =  <span class=\"number\">0</span></span><br><span class=\"line\">    vim.g.mkdp_open_to_the_world = <span class=\"literal\">false</span></span><br><span class=\"line\">    vim.g.mkdp_browser = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    vim.g.mkdp_theme = <span class=\"string\">&quot;dark&quot;</span></span><br><span class=\"line\">    vim.api.nvim_create_autocmd(<span class=\"string\">&quot;FileType&quot;</span>, &#123;</span><br><span class=\"line\">      pattern = <span class=\"string\">&quot;markdown&quot;</span>,</span><br><span class=\"line\">      callback = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">        vim.opt.spell = <span class=\"literal\">true</span></span><br><span class=\"line\">        vim.opt.spelllang = &#123; <span class=\"string\">&quot;en&quot;</span>, <span class=\"string\">&quot;cjk&quot;</span> &#125;</span><br><span class=\"line\">      <span class=\"keyword\">end</span>,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>,</span><br><span class=\"line\">  keys = &#123;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;&lt;leader&gt;mp&quot;</span>, <span class=\"string\">&quot;&lt;cmd&gt;\\begin&#123;figure&#125;</span></span><br><span class=\"line\"><span class=\"string\">    \\centering</span></span><br><span class=\"line\"><span class=\"string\">    \\includegraphics[width=1\\linewidth]&#123;bioPic.png&#125;</span></span><br><span class=\"line\"><span class=\"string\">    \\caption&#123;Human Liver和Stereo-seq的空间域划分&#125;</span></span><br><span class=\"line\"><span class=\"string\">    \\label&#123;fig:enter-label&#125;</span></span><br><span class=\"line\"><span class=\"string\">\\end&#123;figure&#125;MarkdownPreviewToggle&lt;cr&gt;&quot;</span>, desc = <span class=\"string\">&quot;Toggle Markdown Preview&quot;</span> &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;\\begin&#123;figure&#125;</span><br><span class=\"line\">    \\centering</span><br><span class=\"line\">    \\includegraphics[width=<span class=\"number\">1</span>\\linewidth]&#123;bioPic.png&#125;</span><br><span class=\"line\">    \\caption&#123;Human Liver和Stereo-seq的空间域划分&#125;</span><br><span class=\"line\">    \\label&#123;fig:enter-label&#125;</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置ai\"><a class=\"anchor\" href=\"#配置ai\">#</a> 配置 AI</h2>\n<p>在 PowerShell 中输入 nvim 回车，输入 x 进入 Lazy Extras，然后找到 copilot，定位到对应的位置输入 x 启用。重新进入 nvim。输入 <code>:Copilot auth</code>  启用账户并按照提示操作，具体是找到对应的弹窗，进入它提示的网址，输入弹窗给出的验证码进入 github 进行验证。验证完毕后即可使用。具体操作我简单试了一下 Copilot-bot，应该还具有代码补全的操作：</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim7.png\" alt=\"\" /></p>\n<h1 id=\"个性化的一些设置\"><a class=\"anchor\" href=\"#个性化的一些设置\">#</a> 个性化的一些设置</h1>\n<h2 id=\"打开terminal时自动定位到当前文件夹\"><a class=\"anchor\" href=\"#打开terminal时自动定位到当前文件夹\">#</a> 打开 terminal 时自动定位到当前文件夹</h2>\n<p>考虑到跑 python 代码时，重新 ding</p>\n",
            "tags": [
                "代码",
                "NeoVim",
                "代码",
                "neoVim",
                "LazyVim"
            ]
        },
        {
            "id": "http://amentiraz.github.io/article/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%B1%87%E6%80%BB/",
            "url": "http://amentiraz.github.io/article/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%B1%87%E6%80%BB/",
            "title": "毕业设计文档汇总",
            "date_published": "2025-04-11T06:43:37.000Z",
            "content_html": "<p>毕业设计相关内容在此处留档，避免在网页中编辑丢失数据</p>\n<h1 id=\"摘要\"><a class=\"anchor\" href=\"#摘要\">#</a> 摘要</h1>\n<p>空间域是指在基因表达和组织结构上具有空间相关性的区域，对其识别对于理解组织结构和细胞间相互作用具有重要意义。随着空间转录组学技术的迅速发展，各类空间数据不断涌现，相关的空间域识别方法也层出不穷。</p>\n<p>本文聚焦于空间域建模方法，梳理了空间域的定义及其潜在的生物学功能，分析了常见的空间转录组学数据类型。在此基础上，选取了五种具有代表性的空间域建模方法（包括两种非空间聚类算法），在九种不同类型的空间转录组学数据上进行了系统的对比评估。实验结果表明，不同方法在不同数据集上性能存在差异，但总体而言，空间聚类算法在准确性与空间一致性方面普遍优于非空间聚类方法。</p>\n<p>进一步地，本文从模型的准确性、空间连续性、基因表达一致性及可扩展性等方面设计了 11 项量化指标，对各类方法进行了全面评估。结果显示，在 MERFISH 数据集上，STAGATE 在准确性方面表现突出，但在空间连续性上存在不足。</p>\n<p>此外，本文还对空间域识别结果的生物学意义进行了实证分析。以人体背外侧前额叶皮层（DLPFC）为例，BayesSpace 和 STAGATE 均能够清晰识别连续的空间区域，特别是在白质层的边界上具有良好的区分能力。</p>\n<p>综上所述，本文系统地评估了主流空间域建模方法在多种数据集下的性能差异，并从多个维度对其建模能力进行了深入分析，为空间转录组数据的下游分析与空间组织结构的研究提供了重要参考。</p>\n<h1 id=\"abstract\"><a class=\"anchor\" href=\"#abstract\">#</a> Abstract</h1>\n<p>Spatial domains refer to regions with spatially correlated gene expression and tissue structures. Accurate identification of spatial domains plays a crucial role in understanding tissue architecture and cell–cell interactions. With the rapid development of spatially resolved transcriptomics technologies, diverse types of spatial transcriptomic data have become available, giving rise to a wide range of spatial domain identification methods.</p>\n<p>This study focuses on spatial domain modeling approaches. We first review the definition and biological significance of spatial domains and analyze commonly used spatial transcriptomic datasets. Based on an extensive literature survey, we select five representative modeling methods—including two non-spatial clustering algorithms—and perform comparative evaluations on nine different spatial transcriptomic datasets. Experimental results show that while performance varies across datasets, spatial clustering algorithms generally outperform non-spatial methods in terms of accuracy and spatial coherence.</p>\n<p>To enable a comprehensive assessment, we further introduce eleven quantitative metrics covering accuracy, spatial continuity, gene expression consistency, and model scalability. The results demonstrate that different models excel in different aspects. Notably, STAGATE achieves superior accuracy on the MERFISH dataset, though its spatial continuity is relatively suboptimal.</p>\n<p>In addition, we conduct biological analyses of the identified spatial domains. Using human dorsolateral prefrontal cortex (DLPFC) data as a case study, we find that both BayesSpace and STAGATE successfully identify coherent spatial domains and delineate the white matter region with high precision.</p>\n<p>Overall, this work provides a systematic evaluation of spatial domain modeling methods across multiple datasets and offers valuable insights for downstream analysis of spatial transcriptomic data and the study of tissue spatial organization.</p>\n<p float=\"\">\\documentclass{xduugthesis}<br />\n\\usepackage{booktabs}<br />\n\\usepackage{siunitx}<br />\n\\usepackage{amsmath}<br />\n\\usepackage</p>\n<p>\\xdusetup{<br />\nstyle = {<br />\ncjk-font = fandol,<br />\nlatin-font = tac<br />\n},<br />\ninfo = {<br />\nbib-resource=reference.bib,<br />\ntitle = {基于统计及表示学习建模的空间域 \\ 识别算法比较},<br />\nauthor = {李澍},<br />\ndepartment = {计算机科学与技术学院},<br />\nmajor = {计算机科学与技术},<br />\nclass-id = {2103016},<br />\nstudent-id = {21009200542},<br />\nsupervisor = {高琳},<br />\nabstract = {chapters/abstract-zh.tex},<br />\nabstract* = {chapters/abstract-en.tex},<br />\nkeywords = {空间域，空间转录组学，模型评估，聚类算法},<br />\nkeywords* = {Spatial Domain , Spatial Transcriptomics , Model Evaluation, Clustering Method},<br />\nacknowledgements = {chapters/acknowledgements.tex}<br />\n}<br />\n}</p>\n<p document=\"\">\\begin</p>\n<p 研究背景与意义=\"\">\\chapter {引言}<br />\n\\section</p>\n<p>在生物组织中，不同类型细胞的空间排列与相互作用构成了复杂而精细的组织结构 \\cite {asp2020spatially}，对理解其生理功能与病理状态具有重要意义 \\cite {armingol2021deciphering}。传统的 RNA 测序技术虽然能够准确测量细胞层面的基因表达，但由于缺乏空间定位信息，难以揭示组织内部细胞的空间异质性与交互机制。近年来，空间转录组学技术（Spatially Resolved Transcriptomics, SRT）迅速发展，代表性平台如 10x Visium\\cite {ji2020multimodal}、MERFISH\\cite {moffitt2018molecular}、osmFISH\\cite {codeluppi2018spatial} 和 Slide-seq\\cite {rodriques2019slide} 等，能够在保留空间结构的基础上进行高通量基因表达测量，为研究基因表达与组织形态之间的关联提供了强有力的技术支持。</p>\n<p>在 SRT 数据分析中，空间域（spatial domain）的识别是一个关键步骤。空间域指的是在空间上相邻、基因表达模式相似的区域，其准确识别不仅有助于刻画组织的功能分区，还为下游的空间可变基因分析 \\cite {li2022cell}、组织异质性研究、细胞通信网络构建 \\cite {cable2022cell} 以及疾病机制解析 \\cite {yuan2022sotip} 等提供了基础支撑。随着空间组技术的不断进步和大规模公开数据集的涌现，研究者亟需系统、稳定且可扩展的算法模型来对空间域进行高效识别。<br />\n\\section {国内外研究现状}<br />\n 目前，空间域识别方法大致可分为两类：非空间聚类方法与空间聚类方法。前者如 K-means、Louvain 和 Leiden\\cite {blondel2008fast} 等传统聚类算法，仅基于基因表达谱进行建模，忽略了空间坐标信息，容易产生空间上不连续、缺乏生物学解释的聚类结果。部分方法尝试通过单细胞 RNA 测序数据对空间数据中的 spot 进行解卷积 \\cite {elosua2021spotlight}，但这类方法不适用于细胞或亚细胞分辨率的空间转录组数据。</p>\n<p>为了充分利用空间信息，近年来涌现出大量将空间坐标纳入建模过程的空间聚类方法。SRT 数据中每个 spot（或细胞）天然具备空间位置和高维表达特征，这一结构可被视为带属性的图结构，其中节点表示细胞或 spot，节点特征为基因表达值。在此基础上，形成了两大主流的建模范式：图神经网络（GNN, Graph Neural Network） 和 贝叶斯网络（BN, Bayesian Network）。前者如 SpaGCN\\cite {hu2021spagcn}、STAGATE\\cite {dong2022deciphering}、CCST\\cite {li2022cell} 与 SpaceFlow\\cite {ren2022identifying} 等，通过深度图学习框架建模空间依赖性，具备良好的可扩展性与运行效率，尤其在 GPU 加速下表现出色，并能输出用于后续分析的上下文表示。然而，这类方法在结果稳定性与可解释性方面存在天然劣势，是深度学习模型的共性问题 \\cite {yuan2024mender}。</p>\n<p>相比之下，BN 方法如 BayesSpace\\cite {zhao2021spatial}、BASS\\cite {li2022bass}、SpatialPCA\\cite {shang2022spatially} 和 SOTIP\\cite {yuan2022sotip} 等则在稳定性与解释性方面更具优势，因其建立在明确的概率模型和变量依赖结构之上。但 BN 方法通常难以处理大规模数据集，运行时间较长，且多数方法无法提供细胞上下文嵌入表示（SpatialPCA 为例外）。此外，部分研究如 SpaGCN\\cite {hu2021spagcn}、stLearn\\cite {pham2023robust}、SiGra\\cite {tang2023sigra} 和 spaVAE\\cite {tian2024dependency} 等进一步将空间坐标与组织学图像等多模态数据融合，提升了模型对组织形态结构的感知能力，实现了更符合生物结构的空间域划分。</p>\n<p 论文结构安排=\"\">尽管当前空间域识别方法不断推陈出新，但在面对实际数据中常见的大规模、多切片、多模态等挑战时，仍缺乏统一而稳健的评估体系，方法选择亦缺乏系统指导。因此，有必要对现有主流方法进行系统性比较与综合评价，以发现其优劣和适用范围，进一步推动该领域的算法发展与实际应用。<br />\n\\section</p>\n<p>本文研究不同的空间域建模方法并通过不同的实验数据对这些建模方法对于空间域识别的性能进行分析评估与比较，提供了在不同情况下选择建模方法的准则。</p>\n<p>第一章，我们介绍了空间聚类模型的研究背景与意义，并针对国内外研究现状进行了全面系统的介绍。</p>\n<p>第二章，我们介绍了空间域及相关的生物功能，明确了实验对象与生物学意义。介绍了实验采用的在准确性、连续性、基因表达模式和可扩展性四个方面的评价指标。</p>\n<p>第三章，我们介绍了 5 种本文使用的空间域建模方法（包括两种非空间方法与三种空间聚类方法），重点针对三种空间聚类方法的模型构建部分进行了介绍，并对比分析了各个模型的特点。</p>\n<p>第四章，我们对于本文选取的五种具有代表性的空间域建模方法，在九个公开的空间转录组数据集上开展系统评估。我们从聚类准确性、空间连续性、基因表达一致性与模型可扩展性等多个维度设计了十一项量化指标，全面对比了不同方法的性能差异与适用场景。同时结合人类肝脏组织与小鼠嗅球组织两个数据集，我们进一步探讨了空间域识别结果的生物学解释力，验证了各方法在真实组织结构解析中的应用潜力与实用价值。</p>\n<p>第五章，我们对全文工作进行了总结，概括了本研究的主要成果与贡献，指出当前工作的局限性，并提出未来可进一步深入研究的方向，为空间域划分领域的发展提供思路和参考</p>\n<p>\\chapter {相关基础知识介绍}<br />\n\\section {空间域及相关的生物功能意义}<br />\n\\subsection {空间域的概念}<br />\n 空间转录组学（Spatially Resolved Transcriptomics, SRT）的进展使得基因表达的空间多重映射成为可能，使研究者能够突破传统的细胞聚类分析，借助额外的空间信息识别更高层级的组织结构，即空间域（spatial domains）\\cite {vandereyken2023methods,seferbekova2023spatial,moffitt2022emerging}。空间域是指拥有相类似的空间表达模式的区域。这些区域通常对应于特定的解剖结构或者功能分区。\\cite {maynard2021transcriptome} 通过空间聚类识别空间域，已成为构建空间图谱的标准起始步骤，并在组织解剖可视化、组织空间连续性推断、特定区域标志基因识别、发育与疾病的空间特征挖掘以及区域依赖的分子调控网络的构建等方面发挥着关键作用。<br />\n\\subsection {生物功能意义}<br />\n 对于组织结构的识别来说，传统上，组织结构由组织学专家进行标注，这种方法劳动强度大且具有主观性。然而，空间聚类方法提供了一种无偏且高效的方式来自动划分组织结构，减少了人工干预的需求 \\cite {chen2018baristaseq,keren2018structured}。例如，经典的背外侧前额叶皮层（DLPFC\\cite {maynard2021transcriptome}）数据集最初由专家标注，但当前的空间聚类方法已经能够自动注释组织，其性能与人工标注相当。未来，整个大脑乃至更复杂的组织和器官有望通过计算方法以无偏且高效的方式进行标注。</p>\n<p>某些组织结构无法仅通过 H&amp;E（苏木精 - 伊红染色）图像直接识别。例如肝脏，在肝小叶内，组织空间上经典地被划分为不同区域（称为肝分区）。每个区域主要由具有不同代谢功能的肝细胞组成，但它们在形态上非常相似。\\cite {cho2021seqscope,benmoshe2019spatial,halpern2017spatial} 由于肝脏小叶数量庞大且形态复杂，手动标注尤其具有挑战性，在这种情况下，计算方法尤为重要。</p>\n<p>针对组织空间连续性的识别来说，某些组织显示出连续的空间模式，而不是具有明确边界的组织界面。例如，大脑皮层虽然被划分为多个离散层，但其边界可能并不严格。许多基因在皮层轴上表现出强烈的连续性 \\cite {fang2022merfish,zhang2021merfish}，某些更高级的细胞组织结构也显示出连续性，如细胞类型的复杂性和空间异质性，这些特征被发现与皮层深度具有很强的相关性 \\cite {zhang2021merfish}。这种空间连续性有时在疾病和癌症研究中具有临床意义。例如，研究人员已经开始探索从正常组织到癌组织的逐渐结构变化，以更深入地理解癌症的分子和组织生物学 \\cite {hunter2021tumorinterface,pelka2021immunehubs}。</p>\n<p>不同于细胞类型特异性标志基因，空间域特异性标志基因表现出更强的空间自相关性，其功能更可能与特定的空间环境相关 \\cite {zhu2018spatial}。在某些疾病状态下，基因的空间分布极为关键。例如：肝纤维化研究发现，在肝域内，与糖酵解相关的代谢物在纤维化区域边界处呈现出极化模式 \\cite {yuan2021seam}。</p>\n<p>在研究发育和疾病的空间特征方面，许多疾病和癌症的关键特征并不体现在细胞类型比例上，而是细胞在空间组织中的排列方式。\\cite {schurch2020cellular,kim2022unsupervised} 例如，在不同的癌症（如乳腺癌、结直肠癌）以及 COVID-19 研究中，细胞的空间组织模式被发现比细胞类型比例更能反映疾病状态。前沿计算方法已经证明了这一特征在疾病诊断中的重要性 \\cite {wu2022graph}。</p>\n<p zeng2023insitu=\"\">对于识别空间域相关的分子调控网络中，例如：STARmapPlus 作为一种新兴技术，能够同时对目标蛋白和基因表达进行空间解析，并已被用于研究阿尔茨海默病相关蛋白在不同空间域内的分布模式。另一项研究利用计算方法，结合空间微环境信息来预测蛋白的丰度，进一步探索疾病相关蛋白的空间调控机制。\\cite</p>\n<p>总体而言，空间域的识别不仅在组织结构注释中具有重要作用，更在疾病诊断、发育研究以及分子调控机制探索等方面展现出广阔的应用前景。深入理解空间域所承载的生物功能意义，将为空间转录组数据的挖掘与解释提供关键支撑。</p>\n<p>\\section {评价指标}<br />\n\\subsection {准确性指标}<br />\n NMI（归一化互信息）用于衡量两个聚类之间的相似性。NMI 的取值范围为 0 到 1，越接近 1 表示两个聚类结果越相似。NMI 衡量的是从一个聚类结果预测另一个聚类结果所需的额外信息量，适用于类别数量不一致的聚类结果评估。</p>\n<p equation=\"\">设 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> 是空间域聚类结果，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 是真实标签，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H(P)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H(T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span> 分别为它们的信息熵，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mi>I</mi><mo stretchy=\"false\">(</mo><mi>P</mi><mo separator=\"true\">,</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">MI(P,T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span> 表示它们的互信息，则 NMI 计算公式为：<br />\n\\begin{equation}<br />\nNMI = \\frac{MI(P,T)}{\\sqrt{H(P)H(T)}}<br />\n\\end</p>\n<p>ARI（调整兰德指数）用于比较两个聚类结果中每一对数据点是否被划分到相同簇中，适合用于类别数量一致时的聚类结果评估。</p>\n<p equation=\"\">ARI 的计算公式为：<br />\n\\begin{equation}<br />\n\\begin{alignedat}{2}<br />\nARI &amp;= \\frac{TP + TN - E}{TP + TN + FP + FN - E} \\<br />\n\\text{where} \\quad<br />\nE &amp;= \\frac{(TP+FP)\\times TP + (FN+TN)\\times (FP+TN)}{TP+TN+FP+FN}<br />\n\\end{alignedat}<br />\n\\end</p>\n<p>HOM\\cite {pedregosa2014homogeneity}（同质性得分）衡量聚类结果与真实标签的同质性。如果每个聚类簇仅包含同一类别的数据点，则聚类是完全同质的。HOM 得分范围为 0 到 1，1 表示完全同质。</p>\n<p>COM\\cite {pedregosa2014completeness}（完整性得分）衡量聚类结果相对于真实标签的完整性。如果同一类别的所有数据点都被正确划分到一个簇中，则聚类是完全完整的。COM 得分范围为 0 到 1，1 表示完全完整。<br />\n\\subsection {连续性指标}<br />\n CHAOS\\cite {shang2022spatially}（高通量开放科学的连续性评估） 是用于质谱成像和空间转录组学中空间连续性评估的指标。得分越低，表示空间域识别结果的连续性越好。</p>\n<p equation=\"\">计算步骤如下：<br />\n\\begin<ruby>enumerate}\n  \\item 构建每个数据点的 1 - 最近邻（1-NN）图，连接物理空间中欧几里得距离最近的细胞。\n  \\item 定义权重 $w_{kij}$：若细胞 $i$ 和 $j$ 属于同一簇 $k$，则 $w_{kij} = d_{ij}$（欧几里得距离），否则为 0。\n  \\item CHAOS 得分计算公式为：\n  \\begin {equation}\n        CHAOS = \\sum_{k=1}<rp>(</rp><rt>{K</rt><rp>)</rp></ruby> \\sum_<ruby>i=1}<rp>(</rp><rt>{n_k</rt><rp>)</rp></ruby> w_{kij}<br />\n\\end</p>\n<p enumerate=\"\">其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">n_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 表示簇 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 中的细胞数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 为空间域的总数。<br />\n\\end</p>\n<p>PAS\\cite {shang2022spatially}（共享区域百分比） 是衡量空间同质性的指标，用于量化空间转录组学中空间域识别算法的性能。PAS 值越低，表示空间域的连续性越好。其计算方式为：具有不同空间域标签的细胞，在其邻近的 10 个细胞中至少有 6 个与其标签不同的百分比。</p>\n<p>ASW\\cite {rousseeuw1987silhouettes} 最初用于评估聚类标签与嵌入空间（或距离矩阵）之间的一致性，后扩展用于评估预测空间域与物理空间的一致性。</p>\n<p>ASW（平均轮廓宽度） 的取值范围通常归一化到 0 到 1，越接近 1 表示聚类性能越好。其计算包括：</p>\n<p enumerate=\"\">\\begin{enumerate}<br />\n\\item \\textbf {轮廓宽度（SW）的定义}：<br />\n\\begin{itemize}<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span>：细胞与同一空间域中其他细胞的平均距离；<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>：细胞与最近邻其他簇中细胞的平均距离；<br />\n\\item 则：<br />\n\\begin{equation}<br />\nSW = \\frac{b - a}{\\max(a, b)}<br />\n\\end{equation}<br />\n\\end{itemize}<br />\n\\item \\textbf {ASW 的定义}：对所有细胞的 SW 值取平均。<br />\n\\end</p>\n<p>\\subsection {基因表达模式指标}<br />\n Moran's I\\cite {miller2021characterizing} 是空间统计学中衡量空间自相关程度的指标，常用于空间组学中评估 SVG（空间变异基因）的空间表达模式是否有序。</p>\n<p itemize=\"\">其取值范围为 -1 到 1：<br />\n\\begin{itemize}<br />\n\\item 趋近于 1：相似基因表达值空间聚集；<br />\n\\item 趋近于 0：表达随机无序；<br />\n\\item 趋近于 -1：呈棋盘格状交替分布。<br />\n\\end</p>\n<p equation=\"\">设 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 分别为细胞 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 的基因表达值，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>x</mi><mo>ˉ</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\bar{x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.56778em;vertical-align:0em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.56778em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.22222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span></span></span></span> 为平均表达值，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 为细胞数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">w_{ij}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 为空间权重，则：<br />\n\\begin<ruby>equation}\n\\begin{aligned}\n\\text{Moran's } I &amp;= \\frac{N}{W} \\cdot \\frac{\\sum_{i=1}<rp>(</rp><rt>{N</rt><rp>)</rp></ruby> \\sum_<ruby>j=1}<rp>(</rp><rt>{N</rt><rp>)</rp></ruby> w_<ruby>ij} (x_i - \\bar{x})(x_j - \\bar{x})}{\\sum_{i=1}<rp>(</rp><rt>{N</rt><rp>)</rp></ruby> (x_i - \\bar<ruby>x})<rp>(</rp><rt>2</rt><rp>)</rp></ruby> \\<br />\nw_{ij} &amp;=<br />\n\\begin{cases}<br />\n 1, &amp; \\text {若} i \\text { 与 } j \\text { 是空间邻居} \\<br />\n0, &amp; \\text {否则}<br />\n\\end{cases} \\<br />\nW &amp;= \\sum_{i,j} w_{ij}<br />\n\\end{aligned}<br />\n\\end</p>\n<p>Geary's C \\cite {miller2021characterizing} 同样用于度量空间自相关，与 Moran's I 类似，但更关注邻近细胞间的差异性。</p>\n<p equation=\"\">计算公式如下：<br />\n\\begin<ruby>equation}\n    Geary's\\ C = \\frac{N \\cdot \\sum_{i=1}<rp>(</rp><rt>{N</rt><rp>)</rp></ruby> \\sum_<ruby>j=1}<rp>(</rp><rt>{N</rt><rp>)</rp></ruby> w_<ruby>ij} (x_i - x_j)<rp>(</rp><rt>2</rt><rp>)</rp></ruby><ruby>2W \\cdot \\sum_{i=1}<rp>(</rp><rt>{N</rt><rp>)</rp></ruby> (x_i - \\bar<ruby>x})<rp>(</rp><rt>2</rt><rp>)</rp></ruby><br />\n\\end</p>\n<p>其中各符号含义同 Moran's I。</p>\n<p>\\subsection {可扩展性指标}<br />\n Time（运行时间） 指标用于评估空间域识别算法在给定数据集上的运行效率。它衡量模型从输入数据开始处理到输出预测结果所需的总时间，单位为秒（s）。在算法比较中，较小的 Time 值表示更高的计算效率。</p>\n<p 小结=\"\">Memory 指标衡量算法在运行过程中占用的最大内存量，以兆字节（MB）为单位。内存峰值反映了模型在运行过程中的资源需求，较小的 Memory 值通常表示更优的资源利用率，尤其在资源受限的计算环境下具有重要意义。<br />\n\\subsection</p>\n<p>综上所述，本文从多个维度系统地引入了用于评估空间域识别算法性能的指标体系，包括准确性、连续性、基因表达一致性及可扩展性。准确性指标（如 NMI、ARI、HOM 和 COM）用于衡量聚类结果与真实标签之间的一致性；连续性指标（如 CHAOS、PAS 和 ASW）反映预测空间域在物理空间上的连贯性与合理性；基因表达模型指标（如 Moran's I 和 Geary's C）评价模型是否能够识别出具有生物学意义的空间变异基因；而可扩展性指标（Time 与 Memory）则用于量化算法在实际应用中的效率与资源消耗。多维度、多角度的指标体系不仅有助于全面评价模型性能，也为后续空间组学算法的优化与选择提供了参考依据。</p>\n<p equation=\"\">\\chapter {空间域建模方法介绍}<br />\n\\section {非空间聚类方法}<br />\n\\subsection{Louvain}<br />\n Louvain\\cite {wolf2018scanpy} 是一种非空间聚类算法，它利用贪心优化的思路、通过不断迭代地合并和拆分社区来优化模块度，直到模块度不再增大，从而在一个大型的网络中获取非重叠的社区，它能够有效的提取社区的结构。<br />\n模块度的定义如下<br />\n \\begin {equation}<br />\nQ = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(c_i, c_j)<br />\n\\end</p>\n<p itemize=\"\">其中：<br />\n\\begin{itemize}<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{ij}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>：节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 之间是否有边，1 表示有，0 表示无；<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><msub><mi>k</mi><mi>i</mi></msub><msub><mi>k</mi><mi>j</mi></msub></mrow><mrow><mn>2</mn><mi>m</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{k_i k_j}{2m}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.338428em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.993428em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">m</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.50732em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2818857142857143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>：节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 在随机图中预期的连接概率；<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>δ</mi><mo stretchy=\"false\">(</mo><msub><mi>c</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\delta(c_i, c_j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>：指示函数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 在同一社区时为 1，否则为 0；<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>：图中的总边数，即 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">m = \\frac{1}{2} \\sum_{i} k_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.190108em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16195399999999993em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。<br />\n\\end</p>\n<p 空间聚类方法=\"\">\\subsection{Leiden}<br />\n Leiden\\cite {wolf2018scanpy,traag2019from} 是另一种非空间聚类算法，其原理与 Louvain 类似。Leiden 算法通过引入额外的精炼过程，解决了 Louvain 算法可能会产生连接不良的社区的问题，从而产生更高质量的社区结构，以提升聚类效果。<br />\n\\section</p>\n<p>\\subsection{BayesSpace}<br />\n BayesSpace\\cite {zhao2021spatial} 是一种基于贝叶斯建模的空间域识别算法，它实现了一个完全贝叶斯模型，并在此基础上引入马尔可夫随机场，以鼓励属于同一聚类的 spots 在空间上彼此接近。其建模过程通常包括以下几个关键组成部分：</p>\n<p 一、模型构建=\"\">\\textbf</p>\n<p>对每个 spot <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>，我们对其基因表达向量进行降维，得到一个低维表示 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>γ</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\gamma_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">γ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>（例如主成分分析后的主成分）。构建的概率模型如下所示：</p>\n<p equation=\"\">\\begin<ruby>equation}\n\\left( \\gamma_i \\mid z_i = k, w_i \\right) \\sim \\mathcal{N} \\left( \\mu_k, w_i<rp>(</rp><rt>{-1</rt><rp>)</rp></ruby> \\Lambda^{-1} \\right)<br />\n\\end</p>\n<p itemize=\"\">其中参数含义如下：<br />\n\\begin{itemize}<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>z</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>q</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">z_i \\in \\{1, \\dots, q\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mclose\">}</span></span></span></span>：表示 spot <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 所属的潜在聚类标签；<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>μ</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mu_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>：聚类 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 的均值向量；<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Λ</mi></mrow><annotation encoding=\"application/x-tex\">\\Lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Λ</span></span></span></span>：精度矩阵（precision matrix）；<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">w_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>：一个未知的（观测特异性）缩放因子。<br />\n\\end</p>\n<p 二、参数更新=\"\">\\vspace{1em}<br />\n\\textbf</p>\n<p>在模型推断阶段，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>μ</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mu_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Λ</mi></mrow><annotation encoding=\"application/x-tex\">\\Lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Λ</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">w_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的更新采用 Gibbs 采样方法迭代进行，而每个聚类标签 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>z</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">z_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的更新则采用 Metropolis-Hastings 算法。</p>\n<p>具体地，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>z</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">z_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的更新同时结合了似然项与空间先验信息。马尔可夫随机场（MRF）先验通过 Potts 模型定义如下：</p>\n<p equation=\"\">\\begin{equation}<br />\n\\pi(z_i) = \\exp \\left( \\frac{\\delta}{|\\langle ij \\rangle|} \\sum_{\\langle ij \\rangle} I(z_i = z_j) \\right)<br />\n\\end</p>\n<p itemize=\"\">其中：<br />\n\\begin{itemize}<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>i</mi><mi>j</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle ij \\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">⟩</span></span></span></span> 表示与 spot <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 相邻的所有 spot <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span>；<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">I(\\cdot)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span></span></span></span> 是指示函数，当括号内条件满足时取值为 1，否则为 0；<br />\n\\item <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>δ</mi></mrow><annotation encoding=\"application/x-tex\">\\delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span></span></span></span> 是平滑强度控制参数，用于调节空间相邻点倾向属于相同聚类的程度。<br />\n\\end</p>\n<p>该先验鼓励空间上相邻的 spot 被分配到相同的聚类中，从而提升空间聚类的连续性与一致性。</p>\n<p>此外，BayesSpace 还支持对 Visium 平台下每个 spot 进一步进行 \\textbf {亚像素分辨率提升（subspot resolution enhancement）}，即将一个 spot 分割为多个子区域，以实现更细粒度的空间结构识别。</p>\n<p>BayesSpace 在多个空间转录组学数据集中展现出优秀的空间聚类性能，尤其适用于组织结构复杂、空间域边界不清晰的场景。其实现基于 R 语言，并集成于 Bioconductor 生态中，具有良好的可重复性与可扩展性。<br />\n\\subsection{SpaGCN}<br />\n SpaGCN\\cite {hu2021spagcn} 是一种图卷积网络方法，它在空间转录组数据分析中融合了基因表达、空间位置信息以及组织学图像。SpaGCN 能够从每个样本的邻近点中聚合基因表达信息，从而识别出空间域。</p>\n<p>SpaGCN 进行空间域识别的时主要分为三个步骤进行：</p>\n<p>一、构建能够代表每个样本点的关系的图，图的距离构建主要考虑空间信息和组织学图像信息。</p>\n<p>二、SpaGCN 利用图卷积层去聚合每个样本点周围邻居的基因信息。图卷积层可被表示为：</p>\n<p equation=\"\">\\begin{equation}<br />\nf(X, A) = \\delta(AXB),<br />\n\\end</p>\n<p>其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> 是从主成分分析（PCA）获得的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>×</mo><mn>50</mn></mrow><annotation encoding=\"application/x-tex\">N \\times 50</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span></span></span></span> 嵌入矩阵，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>50</mn><mo>×</mo><mn>50</mn></mrow><annotation encoding=\"application/x-tex\">50 \\times 50</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span><span class=\"mord\">0</span></span></span></span> 的矩阵，表示卷积层的滤波器参数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>δ</mi><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\delta(\\cdot)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span></span></span></span> 是一个非线性激活函数，如 ReLU。</p>\n<p>三、通过聚合得到的表达矩阵再次通过无监督聚类算法进行聚类得到最终的结果。</p>\n<p>此外，SpaGCN 进行基于结构区域引导的差异表达分析 (domain-guided differential expression, DE)，以识别在特定结构区域中富集表达的基因。SpaGCN 检测到的基因具有良好的可迁移性，可用于其它数据集中空间基因表达变异的研究。</p>\n<p>SpaGCN 计算速度快，可在多种平台上运行，是一种适用于多种 SRT 数据研究的理想工具。<br />\n\\subsection{STAGATE}<br />\n STAGATE\\cite {dong2022deciphering} 是一种图注意力自编码框架，它通过整合空间信息和基因表达谱来学习低维的潜在标识，从而能够准确的识别空间结构域。STAGATE 通过使用注意力机制，从而更好地自适应地学习相邻样本点的相似性，并且可选地通过整合基因表达的预聚类结果，引入对细胞类型感知的模块。</p>\n<p>STAGATE 模型的构建主要分为下面三个步骤</p>\n<p>一、对 SNN 图的构建。除了常规的 SNN 图构建，STAGATE 提供了对细胞类型感知的 SNN 图构建。</p>\n<p>二、使用图注意力自编码框架对数据进行整合，从而学习样本在低维的潜在表示。</p>\n<p>三、使用聚类方法对低维表示的数据进行聚类得到划分的空间域结果。当我们知道分类标签的数量时采用 mclust 进行聚类，反之则采用 Louvain 进行聚类。</p>\n<p table=\"\">STAGATE 能显著提升空间结构域识别的准确性，并在保留空间表达模式的同时，有效去噪。更重要的是，STAGATE 可扩展至多张连续切片，有效降低切片间的批次效应，并从重建的三维组织中提取三维表达结构域。<br />\n\\subsection {小结}<br />\n Louvain 和 Leiden 算法由于其原始设计并未考虑空间信息，虽具有较低的算法复杂度与较强的数据适应性，但在空间结构识别方面存在明显不足。相比之下，SpaGCN、BayesSpace 和 STAGATE 作为空间感知算法，能够在建模过程中有效融合空间邻域信息，从而提升聚类的空间连续性与生物学解释能力。SpaGCN 借助图卷积机制与组织学图像信息联合建模，具备较强的空间结构识别能力；STAGATE 采用图注意力机制对邻接关系进行自适应加权，在保留空间表达模式的同时兼具降噪与跨切片扩展能力，适用于多种分辨率与平台。BayesSpace 则基于高斯混合模型与马尔可夫随机场进行贝叶斯建模，能够引入空间先验增强聚类精度，但其模型复杂度较高，且主要面向 Visium 等固定平台，对于如 Slide-seq 等高分辨率或跨平台数据适应性较弱，限制了其通用性。下表这些模型的特点进行了综合的阐述。<br />\n\\begin{table}[H]<br />\n\\centering<br />\n\\begin{tabular}{lcccc}<br />\n\\toprule<br />\n\\textbf {特性} &amp; \\textbf {Louvain / Leiden} &amp; \\textbf {SpaGCN} &amp; \\textbf {BayesSpace} &amp; \\textbf {STAGATE} \\<br />\n\\midrule<br />\n 是否空间感知 &amp; 否 &amp; 是 &amp; 是 &amp; 是 \\<br />\n 空间连续性 &amp; 无保障 &amp; GCN 处理 &amp; MRF 建模 &amp; 注意力建模 \\<br />\n 可解释性 &amp; 较弱 &amp; 自带差异分析 &amp; 可视化空间基因 &amp; 可解释注意力机制 \\<br />\n 算法复杂度 &amp; 低 &amp; 中等 &amp; 高 &amp; 高 \\<br />\n 使用数据的多样性 &amp; 强 &amp; 强 &amp; 弱 &amp; 强 \\<br />\n 组织学图像信息 &amp; 否 &amp; 是 &amp; 否 &amp; 否 \\<br />\n 使用平台 &amp; Python &amp; Python &amp; R &amp; Python \\<br />\n\\bottomrule<br />\n\\end{tabular}<br />\n\\caption {空间转录组聚类方法的比较}<br />\n\\end</p>\n<p 数据与实验结果=\"\">\\chapter</p>\n<p DLPFC:=\"\">\\section {数据预处理}<br />\n\\subsection {数据}<br />\n\\textbf</p>\n<p>10x Visium 数据集（也被称为 SpatialLIBD 或 DLPFC）是空间聚类方法中最广泛使用的基准数据集之一 \\cite {maynard2021transcriptome}。该数据集包含来自三位神经类型正常的成年捐献者的 12 个人类死后背外侧前额叶皮层（DLPFC）组织切片数据，所有样本均采用 10x Visium 技术进行分析，并配有配对的 H&amp;E 染色图像。我们使用编号为 151673 的样本作为数据集，包含 3639 个样本，每个样本包含 33538 个基因。</p>\n<p>\\textbf {人类肝脏组织:}<br />\n 这份数据集来自使用 10x Visium 技术的肝脏组织。\\cite {guilliams2022spatial} 该数据集包含 13 个数据，其中 8 个是小鼠肝脏数据，5 个是人类肝脏数据。这里我们采用人类肝脏数据作为样本，选取包含 1759 个样本，每个样本包含 32738 个基因的数据。</p>\n<p MERFISH:=\"\">\\textbf</p>\n<p>MERFISH\\cite {moffitt2018molecular} 数据集是一种基于成像的空间转录组学数据集，发表于 2018 年。在所有切片中，有五个切片被标注了区域标签。我们选取的数据包括 5557 个样本，每个样本包含 155 个基因。</p>\n<p osmFISH:=\"\">\\textbf</p>\n<p>osmFISH \\cite {codeluppi2018spatial} 数据集是一个基于成像的空间转录组学数据集，于 2018 年发布。该数据集包含来自小鼠体感皮层的一份数据，并与介绍 osmFISH 技术的论文一起发布。细胞数量为 4,839 个。基因的数量为 33 个，这些基因是从已发布的小鼠体感皮层单细胞 RNA 测序数据集中筛选出来的。</p>\n<p>\\textbf{ST:}<br />\n 该数据集是使用空间转录组学技术研究的 HER2 阳性乳腺肿瘤数据集 \\cite {andersson2021spatial}。细胞数量是 530 个，基因数量为 15029 个。</p>\n<p BARISTAseq:=\"\">\\textbf</p>\n<p figure=\"\">BaristaSeq 数据集 \\cite {spacetx2023web} 是通过 BaristaSeq 技术 \\cite {chen2018efficient} 获得的基于成像的空间转录组学数据集。数据包含 1690 个细胞和 79 个基因。<br />\n\\begin{figure}<br />\n\\centering<br />\n\\includegraphics<span bioPic.png=\"\">width=1\\linewidth</span><br />\n\\caption {Human Liver 和 Stereo-seq 的空间域划分}<br />\n\\label{fig:enter-label}<br />\n\\end</p>\n<p Stereo-seq:=\"\">\\textbf</p>\n<p>Stereo-seq 是一个基于成像的空间转录组学数据集，应用于小鼠嗅球组织的基因表达研究。数据集包含多个样本，涵盖了小鼠嗅球的不同区域，包含 19109 个细胞和 27106 个基因。数据集可在 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0ppbm1pYW9DaGVuTGFiL1NFRFJfYW5hbHlzZXMv\">https://github.com/JinmiaoChenLab/SEDR_analyses/</span>) 中获取。</p>\n<p 总结=\"\">\\subsubsection</p>\n<p 数据预处理=\"\">综上所述，以上空间转录组学数据集提供了丰富的基因表达信息和细胞分布数据，涵盖了不同的组织、物种以及研究方法。这些数据集为我们深入理解各类生物组织的空间结构和功能提供了强有力的支持，也为空间转录组学技术的进一步应用与发展奠定了基础。表 2.1 对上面的数据集进行了归纳<br />\n \\begin {table}[htbp]<br />\n\\centering<br />\n\\caption {文章中使用的数据集}<br />\n\\label{tab:comparison}<br />\n\\begin{tabular}{llcccc}<br />\n\\toprule<br />\n 样本名称 &amp; 空间技术 &amp; 半径 &amp; 样本数量 &amp; 基因数量 &amp; 稀疏性 \\<br />\n\\midrule<br />\nDLPFC        &amp; 10x Visium &amp; 55,\\si{\\micro\\meter} &amp; 3639  &amp; 33538 &amp; 0.93 \\<br />\nHuman Liver  &amp; 10x Visium &amp; 55,\\si{\\micro\\meter} &amp; 1759  &amp; 32738 &amp; 0.90 \\<br />\nMERFISH      &amp; MERFISH    &amp; <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\le</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> 1 cell          &amp; 5557  &amp; 155   &amp;   0.57    \\<br />\nosmFISH      &amp; osmFISH    &amp; <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\le</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> 1 cell          &amp; 4839  &amp; 33    &amp; 0.31 \\<br />\nST           &amp; ST         &amp; 55,\\si{\\micro\\meter} &amp; 530   &amp; 15029 &amp; 0.87 \\<br />\nBARISTAseq   &amp; BARISTAseq &amp; <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\le</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> 1 cell          &amp; 1690  &amp; 79    &amp; 0.86 \\<br />\nSTARmap      &amp; STARmap    &amp; <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\le</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> 1 cell          &amp; 1049  &amp; 166   &amp; 0.69 \\<br />\nSTARmap*     &amp; STARmap*   &amp; <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\le</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> 1 cell          &amp; 1207  &amp; 1020  &amp; 0.77 \\<br />\nStereoseq    &amp; Stereoseq  &amp; 500,\\si{\\nano\\meter} &amp; 19109 &amp; 27106 &amp; 0.98 \\<br />\n\\bottomrule<br />\n\\end{tabular}<br />\n\\end{table}<br />\n\\subsection</p>\n<p>对于不同的模型我们针对模型本身的使用要求采用不同的数据预处理方式。</p>\n<p>针对 Louvain 和 Leiden 模型，先对原始基因表达数据进行标准化处理（如 UMI 归一化并取对数），并筛选出高变异基因以降低数据维度和噪声。随后通过主成分分析（PCA）对表达矩阵进行降维，并在低维空间中构建 K 近邻图（KNN 图），该图将每个样本节点与其在表达模式上最相似的若干邻居连接，为后续的图聚类提供结构基础。</p>\n<p dong2022deciphering=\"\">针对 STAGATE 模型，我们首先移除了不在主要组织区域以内的数据。接着我们对于未处理的基因数据进行对数变换并进行规范化。最后选取 3000 个高可变基因作为 STAGATE 的输入。\\cite</p>\n<p zhao2021spatial=\"\">针对 BayesSpace 模型，我们对于未处理的基因数据进行对数变换并进行规范化。接着我们使用 PCA 对选取的 2000 个高可变基因进行降维并最终选择 15 个主成分进行输入。\\cite</p>\n<p hu2021spagcn=\"\">针对 SpaGCN 模型，在预处理过程中，表达数量少于三个测量点的基因会被剔除。然后对每个测量点的基因表达值进行归一化处理：即将每个基因的 UMI 计数除以该测量点所有基因的 UMI 总数，再乘以 10,000，最后取自然对数进行转换。预处理完成后，SpaGCN 会将基因表达数据与组织图像数据转化为一个加权无向图 G (V, E) 并将此数据进行输入。\\cite</p>\n<p>\\subsection {不同数据在 STAGATE 模型下的表现}<br />\n 为了更好的理解模型在不同数据下的表现存在差异，并直观的把握模型在不同类型数据集聚类的效果，首先我们对于不同数据集在 STAGATE 模型下的表现进行了实验。</p>\n<p>不同数据集在聚类时的表现存在差异，我们对各个数据集在不同评价指标下的表现进行了可视化展示，直观呈现空间域划分结果（见图 4.2）。</p>\n<p>在准确性相关指标方面，基于 10x Visium 平台的 DLPFC 数据集在 ARI、NMI、HOM 和 COM 四项指标中表现最优；BARISTAseq、Human Liver 与 MERFISH 数据集也展现出良好的聚类效果，其余数据集则相对较弱。</p>\n<p figure=\"\">\\begin{figure}<br />\n\\centering<br />\n\\includegraphics<span DatasetInSTAGATE.png=\"\">width=1\\linewidth</span><br />\n\\caption {数据集在 STAGATE 上的表现}<br />\n\\label{fig:enter-label}<br />\n\\end</p>\n<p>在反映基因空间表达模式的两个指标中，Moran’s I 更偏重于衡量基因在整体空间中的聚集程度，而 Geary’s C 更关注基因在局部邻域中的变化，并对极端值更为敏感。可以观察到，10x Visium 数据集在聚类后基因分布呈现出整体聚集的趋势，但局部区域的空间自相关性较弱。此外，Moran’s I 与 Geary’s C 在多数数据集上呈现出相反的评价趋势，提示某些数据在整体表达模式与局部连续性之间存在一定的权衡。以 BARISTAseq 数据集为例，其在 Moran’s I 上得分最低，但在 Geary’s C 上反而表现最优，体现出其基因在局部的表达模式更具结构性。</p>\n<p>在空间连续性指标方面，BARISTAseq、DLPFC、MERFISH 和 osmFISH 数据集在 CHAOS 指标下表现较好；而在 PAS 指标下，BARISTAseq、DLPFC 和 MERFISH 表现最佳；在 ASW 指标中，BARISTAseq 与 DLPFC 显著优于其余数据集，显示出其空间聚类的紧凑性与一致性。</p>\n<p>在可扩展性方面，MERFISH 数据集在时间消耗方面显著高于其他数据集，这与其 “多样本、少基因” 的数据特性相符。在内存消耗方面，不同数据集根据样本数量和基因维度差异表现各异，未呈现明显统一趋势。</p>\n<p>如先前的基准研究所指出，空间技术和计算方法的多样性对于实现本研究的核心目标至关重要：一方面，为生物学研究人员提供模型选择的指导依据；另一方面，推动计算方法开发者持续优化现有方法。生物学家需了解在其所使用的数据（无论基于现有技术或新兴平台）上，何种聚类方法最为有效。现有空间转录组技术中，10x Visium 与 MERFISH 占据了已发表数据的大量份额，并凭借商业化发展趋势有望持续扩展其影响力。对于新兴空间技术生成的数据集，本研究亦可通过数据特征相似性进行方法推荐，具有一定推广价值。</p>\n<p>综合以上实验结果，结合数据集的商业可获取性及模型适配性，本研究后续主要选择 DLPFC 与 MERFISH 两个数据集作为重点评估对象，并进一步探索若干新兴空间技术数据集中聚类结果的生物学解释与潜在意义。</p>\n<p 模型构建=\"\">\\section</p>\n<p 实验流程=\"\">\\subsection</p>\n<p>如图 4.1 所示为本研究的总体流程图。为了更好地评估空间聚类模型的性能，我们采用了人工预标注的类别作为真实标签进行对比分析。在五种聚类模型（Leiden、Louvain、BayesSpace、STAGATE、SpaGCN）上，对来自七种空间技术的八个不同数据集进行了空间域划分。为了确保方法间的公平对比，我们统一采用包含空间位置信息和基因表达信息的标准化处理数据作为模型输入。</p>\n<p figure=\"\">\\begin{figure}<br />\n\\centering<br />\n\\includegraphics<span Benchmarking.png=\"\">width=\\textwidth</span><br />\n\\caption {流程图}<br />\n\\label{fig:enter-label}<br />\n\\end</p>\n<p 参数设置=\"\">\\subsection</p>\n<p>对于每个模型我们进行 10 次重复的运行，每次运行的我们重新设置模型的种子的随机数以确认模型的运行稳定程度。</p>\n<p>对于直接影响聚类结果中空间域数量的参数，我们根据不同方法的特点采用了两种处理策略：(1) 对于可直接设定预期空间域数量的算法（如 SpaGCN 和 BayesSpace），我们将参数设置为与真实标签中空间域数量一致；(2) 对于只能设置聚类分辨率的算法，我们搜索了最接近预期空间域数量的分辨率值。<br />\n网络相关参数</p>\n<p>对于网络相关参数包括神经网络的层数、隐藏层神经元数量以及训练的停止准则。对于这些参数，我们采用原始文献中作者推荐的设置。</p>\n<p 实验结果分析=\"\">\\section</p>\n<p>\\subsection {针对 10x Visium DLPFC 数据集的模型评估}<br />\n\\begin{figure}<br />\n\\centering<br />\n\\includegraphics<span ModelInDLPFC.png=\"\">width=1\\linewidth</span><br />\n\\caption {各模型在 10x Visium DLPFC 数据集下的表现}<br />\n\\label{fig:enter-label}<br />\n\\end{figure}<br />\n 我们通过在 DLPFC 数据集的组织切片上对预测的空间域进行可视化划分，评估了各个模型的空间聚类性能，相关结果如图 4.3 所示。从图 4.3b 可以看出，SpaGCN、BayesSpace 和 STAGATE 等方法均呈现出符合预期的层状结构，而 Leiden 和 Louvain 方法由于未考虑空间信息，表现明显较差。这也与已有研究一致 —— 它们常作为对照方法，用于展示空间信息在聚类任务中的优势。</p>\n<p>在具体数值上，五种方法的最高 NMI（归一化互信息）分别为：STAGATE（0.714）、BayesSpace（0.688）、SpaGCN（0.661）、Leiden（0.307）和 Louvain（0.306）。这些数值与可视化结果高度一致，进一步验证了 STAGATE 的优异性能，其次为 BayesSpace 和 SpaGCN，而 Leiden 与 Louvain 表现最差。</p>\n<p>虽然 NMI 是评估聚类效果最核心的指标之一，但其他指标能从不同维度补充分析方法的性能表现。图 4.3a 展示了多项评估指标的可视化结果。从准确性相关指标（如 HOM 和 COM）来看，空间聚类方法整体显著优于非空间方法。在基因表达模式上，我们也观察到了在空间聚类与非空间聚类方法之间的一个典型权衡现象：空间聚类模型更注重局部连续性，因而在表达模式的局部一致性上表现优越，而非空间模型则更倾向于保持全局相似性，这与本章第一节中对数据聚类趋势的观察结果一致。</p>\n<p>在连续性指标方面，如 CHAOS 和 PAS，空间聚类模型展现出更高的一致性与紧凑性，尤其是 BayesSpace 和 STAGATE 表现最为突出。然而，在可扩展性方面，BayesSpace 的时间和内存开销最高，表明在追求运行效率时可能需要选用其他方法。</p>\n<p>在实际应用中，若目标是获得更高的聚类准确性与空间连续性，推荐使用 STAGATE 和 BayesSpace；若更关注组织结构的精细分辨，可考虑 HOM 值较高的模型；若主要关注全局表达模式的相似性，Leiden 和 Louvain 虽精度较低，但计算效率高，可作为快速探索工具。此外，若希望研究组织学图像信息对聚类效果的影响，SpaGCN 是较合适的选择。而在模型稳定性和结果可解释性方面，BayesSpace 表现尤为突出，适合对结果稳定性要求较高的场景。</p>\n<p>不同空间聚类方法在准确性、连续性、表达模式偏好和可扩展性等方面各具优势，选择适合的模型应依据具体应用需求、数据特性和计算资源综合权衡。</p>\n<p figure=\"\">\\subsection {针对 MERFISH 数据集的模型评估}<br />\n\\begin{figure}<br />\n\\centering<br />\n\\includegraphics<span ModelInMERFISH.png=\"\">width=1\\linewidth</span><br />\n\\caption {各模型在 MERFISH 数据集下的表现}<br />\n\\label{fig:enter-label}<br />\n\\end</p>\n<p>MERFISH 是一种被广泛应用的、基于成像的空间转录组测序技术。通过对其进行空间域划分（如图 4.4b 所示），可以观察到该组织结构高度复杂，空间域具有异质形状和邻接关系，这使得在该数据集上进行空间聚类预测任务具有较大挑战性。由于 BayesSpace 依赖于具有 spot 位置信息的空间数据，因此无法应用于 MERFISH 数据集，在本节分析中不予考虑。</p>\n<p>在 MERFISH 数据集上对剩余可用方法进行评估时，首先从可视化结果来看，STAGATE 表现最为出色，优于其他三种方法；而 SpaGCN 相较于其在 10x Visium DLPFC 数据集上的表现，性能出现了明显下滑。</p>\n<p>在具体的 NMI（归一化互信息）指标上，四种方法的最高得分分别为：STAGATE（0.588）、SpaGCN（0.250）、Leiden（0.185）、Louvain（0.186）。这些结果与可视化效果高度一致，进一步验证了 STAGATE 在该数据集上的优异性能；其次为 SpaGCN，而 Leiden 与 Louvain 仍然表现最差，印证了其不适合用于复杂的空间结构聚类任务。</p>\n<p>图 4.4a 展示了多项评估指标的可视化结果。从整体趋势来看，各方法在 MERFISH 数据集上的表现与在 DLPFC 数据集上存在显著差异。特别是 SpaGCN，在 DLPFC 数据集中略逊于 STAGATE，而在 MERFISH 数据集中性能显著下降，这说明 SpaGCN 对于成像型、高稀疏度的空间数据处理能力较弱。另一方面，从模型稳定性的角度来看，STAGATE 在 MERFISH 数据集上的预测结果方差高于其在 DLPFC 数据集上的表现，可能原因在于 MERFISH 数据集中基因数量相对较少，且数据更为稀疏，增加了聚类任务的不确定性。</p>\n<p>STAGATE 在 MERFISH 数据集上仍然展现出良好的空间聚类能力，是目前分析此类成像型空间转录组数据的优选方法。而 SpaGCN 在面对高度稀疏和结构复杂的组织数据时性能不稳定，提示我们在选择聚类模型时需充分考虑数据类型的特性及适配性。</p>\n<p 在人类肝脏数据和小鼠嗅球数据上组织划分评估=\"\">\\subsection</p>\n<p>\\begin{figure}<br />\n\\centering<br />\n\\includegraphics<span bioPic.png=\"\">width=1\\linewidth</span><br />\n\\caption {Human Liver 和 Stereo-seq 的空间域划分}<br />\n\\label{fig:enter-label}<br />\n\\end{figure}<br />\n 在空间转录组数据分析中，空间域的划分不仅有助于揭示组织内部的空间结构特征，更承载着重要的生物学意义。不同的空间区域通常对应着功能各异的细胞群体，它们在基因表达、代谢状态，甚至疾病发生机制中扮演着彼此不同但又相互协作的角色。通过精确的空间聚类，不仅可以帮助我们理解细胞如何在空间中协同工作、组织如何维持功能稳态，还能揭示关键的发育过程或病理变化在空间尺度上的动态演化。</p>\n<p>我们将多种聚类模型分别应用于两类具有代表性的空间转录组数据集：10x Visium 技术下获得的人类肝脏组织数据，以及 Stereo-seq 技术生成的小鼠嗅球组织数据，结果如图 4.5 所示。其中 Stereo-seq 是一种新兴的空间组学技术，通过 DNA 纳米球图案化芯片可实现亚细胞级的空间分辨率。本研究中使用的数据被重采样（binning）至细胞级分辨率（约 14 μm）。Fu 等人已经在 DAPI 染色图像中对小鼠嗅球冠状切面的层状结构进行了注释，包括前移行流（RMS）、颗粒细胞层（GCL）、内丛状层（IPL）、锥体细胞层（MCL）、外丛状层（EPL）以及嗅神经层（ONL）（图 4.5b）。</p>\n<p>在 Human Liver 数据集中（图 4.5a），通过对门脉区（Portal）及其周边区域（Periportal）的观察可以看出，SpaGCN 虽能较好地识别出门脉区，但未能体现门脉区与其周边区域之间的空间关系。相较之下，STAGATE 尽管识别出的门脉区数量更少，但能够准确刻画不同区域之间的结构性关联，表现出更强的生物学一致性。而对于非空间聚类算法而言，其划分结果缺乏空间连续性，甚至在部分区域上出现了明显的误判。</p>\n<p>在 小鼠嗅球组织数据中，STAGATE 能够清晰识别出前移行流区域，并在颗粒细胞层内进一步辨识出一个新的空间亚群。此外，根据已有研究，STAGATE 所识别的多个区域均得到了已知基因标志物的支持，如中间神经细胞层中狭窄结构的准确识别进一步体现了其强大的空间解析能力。相比之下，SpaGCN 及非空间方法在该数据集上的识别能力则较为有限，难以呈现清晰的空间域轮廓。</p>\n<p>空间域划分不仅为空间转录组数据提供了结构化的理解框架，也为探索组织功能分区和疾病相关机制提供了关键支撑。STAGATE 等空间感知模型展现出更强的泛化能力与生物学解释力，为空间生物信息学的深入发展提供了有力工具。</p>\n<p>\\chapter {总结与展望}<br />\n\\section {对论文工作的总结}<br />\n 在本研究中，我们对主流的空间域识别方法进行了系统的梳理与综合评估。首先，明确了空间域的基本概念，并深入阐述了其在生物学上的功能意义，从而更清晰地界定了研究对象与实验动机。接着，我们详细介绍了空间域建模所涉及的数据，汇总了本研究中使用的八个数据集，并分析了它们的主要特征及相互之间的共性。</p>\n<p>随后，我们系统地归纳了用于模型评估的评价指标，将其分为四大类：准确性、连续性、基因表达模式和可扩展性，并针对每一类指标的计算原理与评估意义进行了深入解读。最后，我们对所涉及的各类模型进行了简要介绍，梳理了它们的实现机制，并比较了各自的优势与局限性。</p>\n<p>在实验部分，我们以 STAGATE 模型为例，分析了其在不同数据集上的表现，并结合数据的实际应用价值（如商业潜力）为后续数据集的选择提供了依据。我们重点针对 DLPFC 数据集与 MERFISH 数据集这两类分别代表 spot 类型与单细胞类型的典型数据，开展了模型评估，直观展示了不同模型在空间域识别中的性能差异，进一步凸显了空间聚类模型在该任务中的优势。</p>\n<p>此外，我们还探索了模型在实际生物学场景中的应用。通过对人类肝脏数据和小鼠嗅球数据的分析，呈现了各模型下的聚类结果，并结合已有生物学知识对聚类区域的功能意义进行了解读，为空间转录组学在生物医学研究中的应用提供了参考依据。</p>\n<p 存在的不足及未来的展望=\"\">本文从理论梳理、数据集分析、模型评估到生物学应用，系统地探讨了空间域识别方法的研究现状与实际效果，为后续研究提供了坚实的基础和清晰的参考方向。尽管当前的空间建模方法在准确性与适应性方面已取得显著进展，但在跨平台泛化能力、生物学解释性以及多模态数据融合等方面仍存在一定的挑战。未来的研究可在提升模型可解释性、构建统一的评估框架以及深入挖掘空间转录组数据的潜在生物学价值等方面持续探索，以推动空间转录组学在疾病机制研究、组织结构重建等领域的进一步发展。<br />\n\\section</p>\n<p>本文系统性地评估了当前主流的空间域识别算法，从数据集构建、评价指标设计以及生物学意义等多个维度对现有方法进行了补充与完善，基本构建了完整的实验流程体系。然而，本文仍存在以下几方面的不足：</p>\n<p>首先，在模型选择方面，本文选取了两种非空间域聚类模型与三种空间域聚类模型，尽管这些模型在当前研究中具有较强的代表性，但总体数量仍显不足，尚不能全面涵盖当前空间域建模方法的全部特征。未来可进一步引入更多空间聚类模型，尤其是近年来新提出的深度学习方法，以提升实验的全面性与结果的说服力。</p>\n<p>其次，在数据集选择上，本文仅针对每种空间转录组技术挑选了 1 至 2 个代表性数据集进行分析，这在一定程度上可能引入偏倚，限制了对不同空间技术特性的全面理解。后续研究可拓展至更多样化的数据集，以增强评估结果的普适性，同时为研究者在选择空间技术平台时提供更具参考价值的依据。</p>\n<p>最后，受限于实验条件与资源，本文尚未对大规模空间转录组数据开展评估，因此缺乏模型在高维度、大样本环境下的性能表现分析。未来可结合高性能计算平台，对模型在大规模数据集下的计算效率、可扩展性与稳定性进行系统研究。</p>\n<p document=\"\">综上所述，尽管本文在空间域识别方法的系统评估方面做出了一定的探索和贡献，但仍有较大的提升空间。未来的研究可围绕模型种类的多样化、数据集覆盖面的拓展以及对实际应用场景的适应能力进一步深入，以期推动空间转录组学在更广泛生物医学领域的深入发展。<br />\n\\end</p>\n",
            "tags": [
                "论文",
                "学习笔记",
                "毕业设计"
            ]
        },
        {
            "id": "http://amentiraz.github.io/life/%E8%A7%92%E9%93%9C%E7%9C%9F%E5%AE%9E%E9%9F%B3%E4%B9%90%E4%BC%9A/",
            "url": "http://amentiraz.github.io/life/%E8%A7%92%E9%93%9C%E7%9C%9F%E5%AE%9E%E9%9F%B3%E4%B9%90%E4%BC%9A/",
            "title": "角铜真实音乐会",
            "date_published": "2025-04-04T08:48:43.000Z",
            "content_html": "<p>角铜真实<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/jiaotongzhenshi1.jpg\" alt=\"\" /><br />\n此前并没有听过这个乐队的歌，正好在平台上看见了他们的演出，一看 tag 是氛围 / 民谣 / 独立便觉得可以试试。然而在 b 站上试听了几首实在觉得风格过于实验性有点接受不来。最终看了现场的切片和实在天天跑代码受不了想换换脑子便买了票来到西安音乐厅。</p>\n<p>起初我认为这种小众且风格具有门槛的乐队哪会有人掏 200 块钱来看。于是便卡着点，一看门口长长的队伍等着买周边。我仍然觉得这些人不过是凑热闹，于是自欺欺人的我很遗憾的没能买到周边。</p>\n<p>好在座位很靠前，在第二排，坐在位置上能清楚的看到例如贝斯、吉他、提琴、鼓等等乐器。有些东西却看不太懂，电子琴和类似合成器尚能理解，一个小水缸，葫芦丝，鼓上挂着的铃铛样的东西又是什么。这些东西垒在一起更让人疑惑，有种现代与古典交织的不和谐感。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/jiaotongzhenshi2.jpg\" alt=\"\" /><br />\n乐队成员上场了，两个带着像是从哪个宗教色彩浓厚的部落里偷来的面具，另外几个倒是正常打扮。角铜真实应该是那位带着面具的女生了。看网易云上的照片感觉不怎么好看，现场一看那种活力与热情的身姿让人印象深刻。很快演出便开始了。</p>\n<p>预想中的复杂和不和谐的音乐并没有出现，反倒是乐队成员的互相配合营造出了一种氛围。这下我便深刻体会到了 ambient 的魅力。我一直在想为什么 ambient 非要把氛围给突出出来，在我看来很多古典曲目仍能达到烘托出氛围的效果。然而氛围音乐，起码是这个乐队中，大量重复的乐段并不会让人感到乏味，正儿八经的把人给送入到这种氛围之中。不会乏味的理由也很简单，不时加入新的乐器，或是简单的改变某个音却不破坏整个氛围，再加上绝佳的动态，让氛围不改变的同时情绪自然的流淌。</p>\n<p>我并不太会听氛围音乐，于是我按照自己的方式进行了品鉴。首先我注意到的是乐队成员，主音即负责大部分旋律段的角铜真实和另一位吉他手年龄都不大，而提琴手、鼓手、贝斯都是起码父辈到祖父辈的人了。这里就十分有趣，三位经验丰富的乐手凭借着丰富的演奏经验和扎实的基本功让演出处在一个极高的水平，例如贝斯烘托了律动，提琴在延伸情绪的表达上，特别是鼓手绝佳的音量控制，当我看到他以超高的速度又富有力量感弹奏又稳定的停下来时不由得感到震撼。而两位年轻人则是把年轻人的活泼和创新展现了出来，无论是与现场观众的互动抑或是使用复杂多样的音乐器材，虽说稍显稚嫩，但也是整场演出的灵魂所在。</p>\n<p>在我看来，乐器音色的选择是极为苛刻的，最为直观的来说，不同的歌手的嗓音往往适合不同风格的歌曲，更别提把诸如水的流动声，纸张的晃动声，鼓棒在擦片上的摩擦声，有些音色光是在现实生活中听到便觉得不适更何况是在演奏会上。</p>\n<p>他们是怎么平衡的呢？不得不说角铜真实的天赋之高。这些本应不会出现在此的音色在他们的演奏中却塑造了一种 “原始” 的 “梦幻” 的氛围。这具体是一种怎样的氛围呢？好比你行走在野生、神秘而又被遗弃的原始部落里，无论是鸟叫还是树木断裂的声音，甚至于裂开的天空传来的呼救。一切都是被允许的，因为我的内心是渴求的，而在渴求中这份神秘又让我得到了满足。这是前三分之一的歌曲带给我的感受。</p>\n<p>渴求仍在继续，这种渴求转变成了具体的东西。中间有一首大意是 “我想要说话” 的歌我认为很出彩。由压抑中爆发，主唱开始喋喋不休的不停的表达自己，又哑然失语，返璞归真，在咿呀中不知所云，到了第三乐章，主唱开始不再一昧表达自己，转而看向周围：这是椅子、这是鼓、这是鞋子…… 从认识世界中变得成熟与温和。配上主唱的面具和她夸张的动作，十分 drama 的场景扑面而来，这里一定是借鉴了音乐剧的表现形式，不仅在音乐中释放自己的情感，更是直观的向观众展现。</p>\n<p>到了最后，角铜真实以一首 flower everywhere 结束了整场演出。这首曲子也非常有趣，听到这个名字我以为是欢快的曲子，但上来就是听都听不懂的像在砸琴键的和弦开场且这个和弦贯穿整个曲子。我不禁想，花在哪呢？可随着各种乐器的加入，虽说整个曲子的氛围虽然没有变但在各种 “规整” 的声音加入后，不和谐的声音也变得能够接受，更神奇的是由于和弦的不断规律重复，似乎隐隐之中让人产生了有它才正常的错觉。这种表达方式我还是第一次见。花在哪里呢？若是处在鲜花盛开的地方，诉说到处都是花似乎很合理。然而世界上总有不美丽的花，人也是如此。当在此种情形下你仍能觉得 flower everywhere，爱也从中体现。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/jiaotongzhenshi3.jpg\" alt=\"\" /><br />\n有人说为什么一定要去演奏会听音乐，自己在家带个耳机不也是挺好的吗？在我开始听这场演奏会的时候，最大的感受就是 “音质高”，我能够清晰的分辨出哪里是鼓，哪里是贝斯，而不是像平时听歌一样各种声音糊在了一起。其次来说的话就是仪式感不一样，身边的人都在跟你一起听曲子，就像看电影一样，一种集体的氛围感油然而生，再加上这不单单是听曲子，场上演奏者与观众的互动，场下观众与演奏者的互动都是演出的一部分。我迄今为止听过两场演奏会，起码在我听的这两场里，有一个很好的元素就是返场。演奏者假装演奏完最后在观众的呼声中返场再演奏最后的曲目，这种类似于社交属性的行为是耳机无法取代的。但从音乐的角度说，这场演出给我最大的感受是听歌不仅仅是用耳朵去听而是用身体去感受，在我听到快结束时，我缩在靠凳里，感觉不光是耳膜在与音乐共振，更重要的是身体感觉在发热，一方面可能是现场的气氛，另一方面能利用自己的身体感受到音乐的起伏，我认为这是耳机所替代不了的。</p>\n<p>总的来说，这场演出让我感受到了氛围音乐的魅力，乐队成员的配合和音色的选择都让我印象深刻。虽然我对氛围音乐的理解还不够深入，但这场演出让我对这种风格有了更深的认识和体会。唯一有点遗憾的是可能是这种音乐风格的特点，我无法记住音乐演出过程中的旋律或者其它更能量化它的东西，只单单留下了对音乐的感受，但即便如此也是让人十分满意的一场演出了。综合的来评价的话我觉得能打个 9 分。</p>\n",
            "tags": [
                "生活",
                "演奏会",
                "音乐",
                "演奏会"
            ]
        }
    ]
}