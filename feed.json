{
    "version": "https://jsonfeed.org/version/1",
    "title": null,
    "subtitle": "",
    "icon": "http://amentiraz.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "http://Amentiraz.github.io",
    "items": [
        {
            "id": "http://amentiraz.github.io/%E5%AF%B9%E7%95%8F%E9%9A%BE%E6%83%85%E7%BB%AA%E7%9A%84%E5%88%86%E6%9E%90/",
            "url": "http://amentiraz.github.io/%E5%AF%B9%E7%95%8F%E9%9A%BE%E6%83%85%E7%BB%AA%E7%9A%84%E5%88%86%E6%9E%90/",
            "title": "对畏难情绪的分析",
            "date_published": "2025-08-14T07:24:39.000Z",
            "content_html": "<p>家里小朋友对学习新的知识有畏难情绪，并且很难接受自己的失败，家长问我怎么办，我这里写一个对畏难情绪的分析。</p>\n<span id=\"more\"></span>\n<h1 id=\"第一什么是畏难情绪\"><a class=\"anchor\" href=\"#第一什么是畏难情绪\">#</a> 第一，什么是畏难情绪。</h1>\n<p>当我们被动（大多数情况）或主动去做某件事情，而这件事情 —(第一有可能没有接触过，第二有可能我们接触过但我们认为它并不好处理) 超出了我们所能承受的 &quot;认为能够轻松解决的范围&quot;，从而我们一方面恐惧情绪的消耗，另一方面恐惧自己完成失败的可能性，从而不愿意去做的一种心理感受。</p>\n<p>畏难情绪的对象。畏难情绪的对象往往是被感知为：1. 困难的，2. 陌生的，3. 富有挑战性的  4。有可能失败的。而这些对象还有一个特征是需要我们主动消耗精力去完成的并且它所预期获取的成就感或者快乐并不符合我们主动去消耗精力。而且这种脱离控制的感觉，核心是在于主体并不认为自己能够很好的去解决任务。 对象既是必须 “靠近” 去完成的（它就在眼前），但在畏难情绪中，主体又本能地想要与之保持 “距离”（回避、拖延）。这种 “既近又远” 的空间张力是畏难的典型特征。</p>\n<p>畏难情绪的主体。畏难情绪的主体往往 1. 并没有获得去解决他所需要完成的对象的相关知识。2. 并没有足够的动力或者情绪去处理相关的对象。最大的问题是在这里他所获得的往往并不是积极的反馈，而他的内心并不能承受对他者对自身的行为和成果进行否定。而这个否定其实并不直接指向主体本身，而是通过主体所创造的事物间接指向主体。这里的主体对成果进行了误解（幻想），主体幻想自身的成果是自身的投射，从而造成别人指出主体的错误造成了对主体本身的损害。为了预防这种损害，从而主体形成了一种防御机制去避免自己去挑战困难的事物。然而事实上，我们也很难去把自己的行为所做出的结果与自身割裂开。</p>\n<p>同时我们明明认知到这件事情是我们应当去做的，做了这件事是好的，而面对预期的消极情绪我们的消极情绪掩盖了前者的认知，从而造成了一种实质上的割裂，这种割裂反而会更严重的去损害我们的内心。并且与此同时，成就感的喜悦被消极情绪所扭曲。</p>\n<h1 id=\"如何去解决畏难情绪\"><a class=\"anchor\" href=\"#如何去解决畏难情绪\">#</a> 如何去解决畏难情绪</h1>\n<p>分析完上面感觉这个问题也不是什么问题，就省略了</p>\n",
            "tags": []
        },
        {
            "id": "http://amentiraz.github.io/CellOT/",
            "url": "http://amentiraz.github.io/CellOT/",
            "title": "CellOT",
            "date_published": "2025-08-08T05:24:12.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://amentiraz.github.io/%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E5%9B%9E%E5%BF%86%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E5%9B%9E%E5%BF%86%E4%BB%80%E4%B9%88/",
            "url": "http://amentiraz.github.io/%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E5%9B%9E%E5%BF%86%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E5%9B%9E%E5%BF%86%E4%BB%80%E4%B9%88/",
            "title": "当我们在回忆大学生活，我们在回忆什么",
            "date_published": "2025-07-17T02:53:18.000Z",
            "content_html": "<p>四年的时光转瞬即逝。在大二时我还在想大学时光漫长，每天枯燥的做核酸、上课，闲下来便躺在床上玩着手机，晚上还悠闲的在校园里漫步，似乎时间也变得粘稠起来。然而从大三开始为自己的未来做打算后，时间便再也没有为我停留，学习、与他人社交，每一件事都是我急迫去做的。然而当面临大四下数着时间毕业的日子里，回望我的大学生活，大部分事却已经回忆不起来，寥寥的几句话就能概括大部分时间，反而是一些鸡毛蒜皮的小事却格外清晰。我在大学究竟获得了什么，这个问题不由得让我沉默。</p>\n<p>其实仔细想想，我大学在纸面上还是做了许多事的，拿过两个 ACM 校内二等奖，美国数学建模竞赛特等奖，全国数学建模竞赛二等奖，学习成绩不好不坏，但最后也是靠着这些奖项保研了。然而当我去回忆这些竞赛时我回忆的是什么呢？ACM 的校内二等奖其实并没有怎么努力便获得了，全靠吃高中的老本，而且有意思的是大一的比赛我并没有参加，是因为我在预选的网络赛中虽然打到了前列的名次，然而我忘了去参加正式赛便遗憾落榜。而美赛我回忆起来的是由于比赛成绩发布是半夜，我的另外两个队友说他们要守夜等成绩，我早上醒来后发现他们半夜在欢呼拿到了很好的成绩，我倒是没什么感觉，但礼节上也装作激动惊讶的样子回复了几句便去上课了。而全国数学建模竞赛便不怎么如人意，由于队友也很敷衍加上自己当时由于其他的事心情不好便也草草交了。回想起来，对于我而言，似乎无论是奖项本身带来的成就还是去为了这些奖项去学习的过程都没有让我在回忆中留下深刻的回忆，反倒是一些出乎意料的状况格外印象深刻。</p>\n<p>大四上去试着面试了华为，那边的 HR 问我，你在打这些比赛之前的目标是怎样的，我一时语塞，但也如实回答了：我并没有什么目标，只是想去试试便去做了。面试官当时惊讶的看着我，似乎怀疑我有所隐瞒。是呀，有目标打比赛，获得荣誉然后去争取更好的前程才是正常人的思维吧，要不然有什么理由去打比赛呢，这不是毫无意义吗？</p>\n<p>想起来，我可能也是受到了高中经历的影响。在 CSP 比赛的前一周出门时，我的父母问我你这次比赛能拿到什么名次，我自信的说，上次我拿了省二，这次起码省一。然而最后由于发挥失常甚至连省三都没有。我现在还记得我在电子科技大学教学楼大厅内对着竞赛老师嚎啕大哭。到了现在，我已经记不起我做过的大部分题目了，而那次比赛我怎么都想不出来的” 格雷码 “这道题我仍旧记忆犹新。</p>\n<p>这么一看怎么记忆中的事情全是糟糕的东西组成的，这些奖项难道一点作用也没有吗？其实也是有的。当我获得美赛特等奖后虽然表面上没什么，但对我自身的心理产生了很正面的影响。在一个全球的竞赛中拿了很高的名次确实让我面对其他人更有自信了。仔细想想，整个年级也没几个的竞赛方面成果比我更厉害了。我和他人说活更有底气，我也因此更融入了 “社会” 而不是像大一一样用一种清高的不屑去看待人际交往。</p>\n<p>这样写起来我都感觉自己有点不要脸，有一点成就就想去炫耀，就想去获得他人的认可。但其实也并不完全是这样。获得奖项后才发现这些奖项如浮萍一般，这并不是去评判一个人的标准，这些奖项并不能代表我，反倒会使得别人误解我。这些奖项另一个积极的影响就是让我不再以成绩、社会地位等等诸如此类的东西去评判一个人。那么组成一个人的东西、或者说对于一个人来说他所真正拥有的东西是什么呢？在这些经历当中我们究竟获得的东西是什么？我认为我们获得的便是我们的心灵因此而受到改变的东西。这个东西能够以回忆的形式而得到重现。</p>\n<p>我的数学建模的队友都非常优秀，两个人都是名列前茅，均分 90 分往上，相比较而言我的主课成绩也就只有 85 左右。听他们聊起自己的生活似乎是被学习所填满的，需要忙很多事情，竞赛，大大小小的实验，平时上课也要一丝不苟，考试更是需要全力以赴。相比较而言，我虽然基本不翘课，但是也仅限于去听个响，最后考试也是提前一周突击应付完，甚至考试我保持着写完就提前交卷的习惯。我对自己学习专业课的目标是大致学懂就行，考试对我而言也只是走个形式。</p>\n<p>有人说，你心真大，不担心自己的未来吗。不是这样的，这其实是因为我完全不知道大学的升学流程。我直到大二下才清楚保研是需要平时成绩的，甚至找工作需要实习的流程我都是春招的时候才知道。但我如今无比庆幸自己没有去了解这些。</p>\n<p>我问我的队友，你现在天天都在忙，那你什么时候玩呢？他回答我说，等我年入百万就玩。我俩都沉默了一会儿，我说等你年入百万更没有时间玩了，他也不说话了。</p>\n<p>现在想来我也没有表达准确，我也没办法表达准确。“玩” 这个词并不准确，更准确的应该是，你何时为自己而活呢？有人会说，为自己的前途而奋斗这难道不是为自己而活吗。我之前也因为这个问题跟我的一个舍友进行过讨论。我认为人只有发自内心，不被其他外界条件约束，然而去生活才是为自己而活。那个舍友问我，难道为自己的家人父母获得更好的生活去奋斗这个也不算为自己而活吗。我当即没有反应过来便说，那也勉强算吧。但事后我也并不认为这是为自己而活，因为这种事在回忆中就像是那些大大小小的成就一样，即便达成后也只是单薄的一句话，要是为自己而活，一定是发自内心的去想要为他人付出，而不是受限于社会的责任的他人的戒律之下。</p>\n<p>那么我随心所欲的去放纵便是好的吗？这样能让我回忆起来更多的东西，增加我人生的厚度吗？很显然这也是不行的。我的一个舍友对我说：你的生活太单调了，每天准时起床，学习，吃饭，晚上又规律的睡觉，这样的生活多单调乏味啊，像我一样天天打游戏，虽然作息不规律，但是有意思的多。我说，这样下来难道不会很空虚吗？他说，这倒也是。</p>\n<p>实际上我在大二的时候放纵过一段时间，网课挂在旁边，自己躺在床上看网文，从早到晚，晚上实在撑不住了才放下手机睡觉，这样子我持续了两周左右。然而当我看完那本网文时，一种空虚和对现实所有事物感到无趣的情绪笼罩了我。说难听点就像吸了毒被送去戒毒所一样。我现在再也想不起那本网文讲了什么，但那股空虚感时刻警醒着我，我后来再也没有像那时一样没日没夜的去进行这种简单的娱乐了。</p>\n<p>现在想来，那种放纵虽然不是受到他人的约束，但确实是受到低级欲望的支配。并不是说这样不对，而是当我长时间去沉浸在这种非现实中会不自觉的受到非现实的世界观的影响，我的非现实的世界观定然会受到现实的冲击。我认识很多人上了大学便沉迷游戏和虚拟世界的社交之中，后来现实生活越来越糟。但你能断言他们的世界观是错误的吗。有人对我说：躺平才是面对这个世界正确的选择，这句话和人活着就是要不断地去追名逐利，又有什么区别呢？他们都不过是受限于一个框架下，去 “被迫” 过着 “自己” 的生活。然而据我观察，这样的生活往往会消融在框架之下，它们往往不会成为我们的一部分，我们所对它的阐述往往是 “调用” 了框架的 “接口”。实际上这样的生活真的组成了我们吗？我对此存疑。</p>\n<p>虚无主义是一个很流行的概念，说到底我们做的所有事都会受到一个问题的拷问：“有什么意义？”。以前父辈的人很少看到有人去思考这个问题，而我们这代人面对这个问题时往往会很取巧的说：一切本来就没有什么意义。或者会说：“本来没有意义，你认为有意义便有意义。” 以此为根据继续自己的生活。我对这个问题倒有一些不一样的看法，生活有价值的回忆往往是由无意义的事情组成的。无论你如何去为自己构建意义，这个意义真的能经受的住 “你所构建的意义有什么意义” 这个拷问吗？而那些无意义而去做的事情往往才是发自我们内心的。</p>\n<p>我很自豪的说，我上大学干过许多诸如此类无意义的事情：我几乎每天早上都去吃早饭，由此也认识了一位食堂的阿姨；我常常晚上出去散步，我知道绕学校一个小圈大概是半个小时，绕学校一个大圈是一个小时；我吃完晚饭会去弹弹吉他，从最开始大横按都不太行到现在开始试着弹 Marcin 的那些高难度的曲目，并且学了一些乐理可以开始即兴了；我大四的时候每周会抽一天时间去学学哲学，虽然还是一无所知但改变了我思考问题的方式；我去听了几场演奏会，看了几场爵士 jam，提升了我对音乐的理解；我思考了一年关于如何去面对我和一位女生的关系，最后决定把她约出来然后在第二天拉黑了她所有的联系方式；我开始写博客，用文字去记录自己的思考和生活。在无意义中我获得了意外的满足，我的生活从原来的 “似水流年” 变成了一个个的节点并组成了我。我不再为回忆的空虚而恐慌，我满足于我的回忆。</p>\n<p>大学生活中我最满意我的一点是我形成了我自己的价值观并且尽量知行合一。我热爱生活，并且基于自发的对他人的责任积极的去完成我的工作。然而自己的准则并不能保证我风雨无忧，我写过这样一句话：“当我下定决心去爱这个世界时，我才发现这个世界是一座地狱。”</p>\n<p>我和我的一个朋友曾有这样的争辩，我说，人人是平等的，他反驳我说，人人就不是平等的，有钱的人可以买到更多的东西，身处要职的人可以轻易的用权力去压迫其他人，生活中，老师是你需要尊敬的，领导是需要你恭维的，当然你也可以不恭维，那么代价又是什么呢？再极端一些，士兵在战场上如果不杀人，那结果就是被人杀。我们很难去决定自己的生活。</p>\n<p>事实上，他也是对的。我曾经对我的一个信仰伊斯兰教的舍友说，实际上我认为宗教挺好的，最起码由于大家都是上帝的子民，所以人人平等。现在上网你也能发现大部分人心底也根本不认同人人平等。人的贪欲被 “世界就是这样” 所合理化，人们更愿意认同那一张张纸作为金钱的真实也不愿意认同自己心中所迸发出的感情的真挚，处在这样的环境中你很难独善其身。似乎你只能随波逐流，要不然等待你的往往是他人的不理解和对自身的伤害。</p>\n<p>那我们能怎么办呢，是选择顺从这个世界，将自己变成他们的一份子吗？还是说带上面具，去假装迎合他人，但这且不提精神压力有多大，这个面具往往就是你的内心，你的内心不可能不受影响。还是说像堂吉诃德一般最终殉道于对理想主义的追求之中呢？我不知道该怎么做，我并没有足够的见识和能力去解决这个问题，但我猜如果把我逼急了可能会选择第二种吧。</p>\n<p>有点偏题了，但事实上我们并没有能力去选择我们的回忆。我们的回忆往往是突如其来的而非计划周全得来的。但即便它是突如其来的，我也应当去尽量选择它所来的方向。说到底，即使这个世界是一座地狱，那也并不影响我爱它。我决定了去受到它的影响，决定去成为它的一份子（或者说我本来就是它的一份子），我当然也能选择尽量不去受到它的影响。在这种决定与不决定当中，我能获得某种程度的自由，况且在被迫当中往往能明确自己的内心，属于自己的回忆往往能在这种突兀之中得到明晰。</p>\n<p>我在 2024 年进过两次急诊，虽说是心脏问题，但幸好也只是虚惊一场。深夜的急诊室是忙碌的，我的右边的床友是一位中年的大叔，他喝醉酒后被人砸的满头是血，他的朋友问他谁砸的他也说不出来，等到他朋友暂时离开才默默啜泣。左边离得远的床友要更惨一些，也是我们学校的学生，和同学出去玩被车撞了，内脏似乎是撞破了，他的哭喊在急诊室显得更加的沉重，沉重到他的哭喊显得像白噪声一样理所应当，很快他又被送往更深处进行治疗。但清晨的急诊室则好很多，我看到医生集合汇报病人和器材的情况，医生们井然有序，严肃认真的情况给我留下了深刻的印象。有些事情在平时是想不明白的，在急诊室里会更加的清晰。对我而言什么是重要的呢？我又想怎样去回忆自己的人生呢？</p>\n<p>临近毕业的一天早上吃饭时，食堂的那位阿姨说希望我送她一张我自己的照片，她想以此激励自家的小孩向我学习。既然是礼物，我想着就送好点，除了照片，我买了一个笔记本和书签，最后又附上了一张明信片。明信片上写什么我想了很久，最终写下了如下文字：</p>\n<blockquote>\n<p>回忆重现过去</p>\n<p>期许开启未来</p>\n<p>世界在你心中展开</p>\n<p>祝你学习进步，前程似锦</p>\n</blockquote>\n<p>22 岁的我仍旧对世界充满着期许。我风华正茂，似乎什么也击不垮我。我正如同王小波的《黄金时代》中的王二一般，不知道随之而来的 “锤骟术” 会对我带来怎样的影响。但我也不用知道，因为我才大学本科刚毕业，我将在世界留下我的痕迹正如同世界会深刻的影响我。但无论如何，我希望在我年迈之际，我回忆起的是无论何时风华正茂的自己。</p>\n<h1 id=\"后记\"><a class=\"anchor\" href=\"#后记\">#</a> 后记</h1>\n<p>这篇文章严谨来说从大三我就开始构思了，最开始想以一种高考命题作文式的方式去写一些伟光正的东西，后来又想写一些自己大学生活的经历作为记录，但又觉得有些浪费题材，斟酌了很久，最终决定以回忆为主题去写自己的大学生活。。</p>\n<p>说实话，写到后面越来越力不从心，很多问题我也没有想明白，很多事情我还没有经历，去断然进行评价也显得自大。但最起码，我也算写出了一篇结构完整，令自己较为满意的文章。<br />\n或许里面的观点会随着时间的推移而变化，或许我甚至还会推翻自己的观点，但管他的，我才 22 岁，犯点错是在正常不过的事情了。</p>\n<p>这篇文章从落笔到完成断断续续写了三天，这篇文章参杂了很多我当下对世界与自身的思考，同时也记录了大学生活中那些影响我的瞬间，在取舍当中，我认为当下的思考的变化更能代表我的大学生活，故加入了很多思辨的内容。</p>\n<p>回忆对我而言不仅是记忆，回忆本身也是组成人的一个重要的因素，把回忆的时间拉到未来更像是一种目标式的东西，所以它在某种程度上也算是开启了未来。</p>\n<p>若干年后，当我再看到这篇文章会是怎样的想法呢？我对此充满期待。</p>\n<p>2025-07-23 00:52 初稿终了</p>\n",
            "tags": []
        },
        {
            "id": "http://amentiraz.github.io/other/%E8%A7%82%E5%89%8D%E9%A1%BB%E7%9F%A5/",
            "url": "http://amentiraz.github.io/other/%E8%A7%82%E5%89%8D%E9%A1%BB%E7%9F%A5/",
            "title": "观前须知",
            "date_published": "2025-07-11T12:00:47.847Z",
            "content_html": "<p>这个博客建立的目的纯属当作记录自己当下生活和类似笔记本的平台，里面包含大量自己的主观臆断。里面的大部分观点是拾人牙慧，自己的看法也大多浅薄且偏激，不具有任何现实意义。我也无意去传播自己的思想，也不屑于拿自己的认识去洗脑别人。当你与我交流时 —— 无论以什么方式，我都会把你看作是与我对等的，具有独立思考能力，具有主体性的，具有共情能力的个体。</p>\n<p>博客已经将内容做好了分类，你可以进入到对应的板块去寻找自己感兴趣的内容。同时本博客除非特殊情况不会删除自己以往的文章，或许它们文笔粗糙且内涵幼稚，但也算是我成长的一部分。</p>\n<p>最后，对于不知从什么渠道了解到这个博客的你，如果这个博客对你有帮助，那便是再好不过的事情了。</p>\n",
            "tags": [
                "其它"
            ]
        },
        {
            "id": "http://amentiraz.github.io/hello-world/",
            "url": "http://amentiraz.github.io/hello-world/",
            "title": "Hello World",
            "date_published": "2025-07-11T11:38:32.845Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        },
        {
            "id": "http://amentiraz.github.io/%E8%BF%98%E5%8E%9F%E4%B8%8E%E7%BB%99%E4%BA%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
            "url": "http://amentiraz.github.io/%E8%BF%98%E5%8E%9F%E4%B8%8E%E7%BB%99%E4%BA%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
            "title": "还原与给予读书笔记",
            "date_published": "2025-06-30T13:38:49.000Z",
            "content_html": "<p>暑假速通一下现象学，本身我也读过马里翁的《情爱现象学》，正好借此机会更深入的了解一下现象学的相关理论。<br />\n不打算记录的那么详细，会将 GPT 生成的文字和自身看过后想写的一些东西记录下来。</p>\n<span id=\"more\"></span>\n<h1 id=\"第一章-突破与扩展\"><a class=\"anchor\" href=\"#第一章-突破与扩展\">#</a> 第一章 突破与扩展</h1>\n<h2 id=\"两种解释与一项拓展\"><a class=\"anchor\" href=\"#两种解释与一项拓展\">#</a> 两种解释与一项拓展</h2>\n<h3 id=\"q\"><a class=\"anchor\" href=\"#q\">#</a> Q：</h3>\n<p>怎么理解：“即使是为了展开存在意义的问题，存在也必须被给予，以便能够追问其意义。胡塞尔的壮举恰恰在于吧存在置于在场之上，使存在以现象的方式呈现于范畴之中。由于这一壮举，我最终有了一个低级：‘存在’不是一个单纯的概念，不是一个通过演绎活动而得到的纯粹抽象”</p>\n<p>A:<br />\n<strong> 核心句子的分层解读</strong></p>\n<h4 id=\"1-即使是为了展开存在意义的问题存在也必须被给予\"><a class=\"anchor\" href=\"#1-即使是为了展开存在意义的问题存在也必须被给予\">#</a> 1. <strong>“即使是为了展开存在意义的问题，存在也必须被给予”</strong></h4>\n<ul>\n<li><strong>关键点</strong>：任何对 “存在” 的哲学追问（比如海德格尔的 “存在之问”），都<strong>必须以存在的显现为前提</strong>。</li>\n<li><strong>马里翁的立场</strong>：现象（包括 “存在” 本身）必须首先<strong>被给予我们</strong>，才能成为被思考的对象。</li>\n<li><strong>类比</strong>：就像你必须先收到一份礼物（给予），才能去研究它是什么（追问意义）。</li>\n</ul>\n<h4 id=\"2-胡塞尔的壮举在于把存在置于在场之上\"><a class=\"anchor\" href=\"#2-胡塞尔的壮举在于把存在置于在场之上\">#</a> 2. <strong>“胡塞尔的壮举在于把存在置于在场之上”</strong></h4>\n<ul>\n<li><strong>“在场”</strong>（presence）指现象<strong>直接向意识显现</strong>的状态。</li>\n<li><strong>胡塞尔的突破</strong>：传统形而上学（如康德）认为 “存在” 不可知，只能通过概念推理；但胡塞尔通过<strong>现象学还原</strong>，让存在本身作为一种<strong>现象</strong>直接呈现于意识（即 “在场”）。</li>\n<li><strong>意义</strong>：存在不再是抽象概念，而是可被直观的 “事物本身”。</li>\n</ul>\n<h4 id=\"3-使存在以现象的方式呈现于范畴之中\"><a class=\"anchor\" href=\"#3-使存在以现象的方式呈现于范畴之中\">#</a> 3. <strong>“使存在以现象的方式呈现于范畴之中”</strong></h4>\n<ul>\n<li><strong>“范畴”</strong>：指意识的基本结构（如时间、空间、因果性等）。</li>\n<li>胡塞尔认为，现象必须在意识的范畴框架内才能被理解（例如：一个苹果作为现象，需通过 “颜色”“形状” 等范畴被把握）。</li>\n<li><strong>马里翁的潜在批评</strong>：胡塞尔仍将现象束缚于<strong>主体的认知结构</strong>中（范畴即主体的牢笼）。</li>\n</ul>\n<h4 id=\"4-存在不是一个单纯的概念不是纯粹抽象\"><a class=\"anchor\" href=\"#4-存在不是一个单纯的概念不是纯粹抽象\">#</a> 4. <strong>“存在不是一个单纯的概念…… 不是纯粹抽象”</strong></h4>\n<ul>\n<li>胡塞尔的贡献在于<strong>将存在从形而上学抽象拉回具体经验</strong>：\n<ul>\n<li>传统哲学：存在 = 逻辑推导出的概念（如 “上帝存在”）。</li>\n<li>胡塞尔：存在 = 可被直观的现象（如 “我眼前这张桌子的存在感”）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"q-海德格尔的此在是怎样的一种概念\"><a class=\"anchor\" href=\"#q-海德格尔的此在是怎样的一种概念\">#</a> Q: 海德格尔的此在是怎样的一种概念</h3>\n<p>A:<br />\n 海德格尔的 “<strong>此在</strong>”（Dasein，德语直译为 “在那里存在”）是他哲学的核心概念，特指<strong>人的存在方式</strong>。它既不是传统哲学中的 “主体”，也不是生物学意义上的 “人”，而是揭示 “存在意义” 的关键通道。理解这一概念需要跳出传统框架，下面从五个维度展开：</p>\n<hr />\n<h4 id=\"一-此在的本质不是什么而是如何\"><a class=\"anchor\" href=\"#一-此在的本质不是什么而是如何\">#</a> <strong>一、此在的本质：不是 “什么”，而是 “如何”</strong></h4>\n<p>- 为什么此在特殊 <strong>传统哲学</strong>：将人定义为 “理性动物”（亚里士多德）或 “思维主体”（笛卡尔）。</p>\n<ul>\n<li><strong>海德格尔的颠覆</strong>：<br />\n<strong>此在的本质在于它的 “生存”（Existenz）</strong>—— 它不是现成的 “实物”，而是一种<strong>动态的 “去存在”（to be）的可能性</strong>。\n<blockquote>\n<p>例：一把锤子是 “现成在手”（固定功能），而此在是 “上手状态”（不断在行动中定义自己）。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"二-此在的独特性对存在发问的存在者\"><a class=\"anchor\" href=\"#二-此在的独特性对存在发问的存在者\">#</a> <strong>二、此在的独特性：对 “存在” 发问的存在者</strong></h4>\n<ul>\n<li><strong>为什么此在特殊？</strong><br />\n只有此在会追问：“<strong>存在</strong>（Being）<strong>本身意味着什么？</strong>”\n<ul>\n<li>石头不会思考自己的存在，</li>\n<li>但此在的生存天然包含对自身存在的<strong>领会</strong>（understanding）。</li>\n</ul>\n<blockquote>\n<p>此在是存在得以显现的 “澄明之地”。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"三-此在的生存结构在世界之中存在\"><a class=\"anchor\" href=\"#三-此在的生存结构在世界之中存在\">#</a> <strong>三、此在的生存结构：“在世界之中存在”</strong></h4>\n<p>此在<strong>绝非孤立主体</strong>，而是始终嵌在三个互相交织的结构中（称 “<strong>在世结构</strong>”）：</p>\n<ol>\n<li><strong>世界</strong>（World）：\n<ul>\n<li>不是物理宇宙，而是<strong>意义网络</strong>（如锤子的意义指向 “敲钉子”，进而指向 “盖房子”……）。</li>\n<li>此在通过使用工具（“上手状态”）揭示世界的意义。</li>\n</ul>\n</li>\n<li><strong>常人</strong>（Das Man, “the They”）：\n<ul>\n<li>此在的日常状态被<strong>社会规范</strong>支配（“别人都这么做”），导致个体失去本真性。</li>\n<li>例：按社交媒体标准生活，逃避自我选择。</li>\n</ul>\n</li>\n<li><strong>自身</strong>（Self）：\n<ul>\n<li>此在可能沉沦于 “常人”，也可能通过<strong>畏</strong>（Angst）直面死亡，回归<strong>本真存在</strong>。</li>\n</ul>\n</li>\n</ol>\n<p><img data-src=\"https://via.placeholder.com/400x200?text=%E6%AD%A4%E5%9C%A8%E7%9A%84%E7%94%9F%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%9A%E4%B8%96%E7%95%8C-%E5%B8%B8%E4%BA%BA-%E8%87%AA%E8%BA%AB\" alt=\"\" /></p>\n<hr />\n<h4 id=\"四-此在的时间性面向死亡的操心\"><a class=\"anchor\" href=\"#四-此在的时间性面向死亡的操心\">#</a> <strong>四、此在的时间性：面向死亡的 “操心”</strong></h4>\n<p>此在的生存本质是 “<strong>操心</strong>”（Sorge, Care），其根基是<strong>时间性</strong>：</p>\n<ul>\n<li><strong>过去</strong>（被抛性）：此在被抛入特定历史、文化中（非自愿）。</li>\n<li><strong>现在</strong>（沉沦）：日常陷入闲谈、好奇、两可的 “常人” 状态。</li>\n<li><strong>未来</strong>（筹划）：通过 “<strong>向死而生</strong>” 获得本真性 ——<br />\n<strong> 死亡</strong>作为最私己的可能性，迫使此在直面自身有限性，从而<strong>主动筹划人生</strong>。</li>\n</ul>\n<blockquote>\n<p>例：意识到生命有限，放弃跟风，选择自己真正热爱的职业。</p>\n</blockquote>\n<hr />\n<h4 id=\"五-此在与马里翁的分歧关键\"><a class=\"anchor\" href=\"#五-此在与马里翁的分歧关键\">#</a> <strong>五、此在与马里翁的分歧关键</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>海德格尔</strong></th>\n<th><strong>马里翁</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>核心关注</strong></td>\n<td>存在意义（通过此在追问）</td>\n<td><strong>现象如何自我给予</strong></td>\n</tr>\n<tr>\n<td><strong>此在角色</strong></td>\n<td>存在意义的揭示者</td>\n<td><strong>可能遮蔽给予性</strong></td>\n</tr>\n<tr>\n<td>“存在” 的根基</td>\n<td>此在的生存论结构</td>\n<td><strong>现象自身的给予性</strong>（先于此在）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>马里翁的批评</strong>：<br />\n海德格尔让 “此在” 垄断了存在意义的解释权（如 “工具的意义由此在赋予”），这仍是<strong>隐蔽的主体中心主义</strong>。</li>\n<li><strong>马里翁的主张</strong>：<br />\n现象（如艺术品、神圣启示）可能<strong>超越此在的领会框架</strong>，以饱和状态 “给予” 自身意义，甚至颠覆此在的预期。</li>\n</ul>\n<h3 id=\"q-2\"><a class=\"anchor\" href=\"#q-2\">#</a> Q:</h3>\n<p>怎么理解：“《逻辑研究》的突破在于把处于其先天观念性中的含义解放出来” 这句话</p>\n<p>A:<br />\n 胡塞尔在《逻辑研究》（特别是第一研究 “表达与含义”）中提出的这一主张，彻底颠覆了 19 世纪流行的<strong>心理主义</strong>逻辑观，是现象学诞生的关键突破。要理解这句话，需要分三步解开其历史背景、核心概念和哲学革命性：</p>\n<hr />\n<h4 id=\"一-背景胡塞尔对抗的敌人心理主义\"><a class=\"anchor\" href=\"#一-背景胡塞尔对抗的敌人心理主义\">#</a> <strong>一、背景：胡塞尔对抗的敌人 —— 心理主义</strong></h4>\n<ul>\n<li><strong>心理主义是什么？</strong><br />\n19 世纪主流观点（如约翰・穆勒、西格瓦特）认为：\n<ul>\n<li><strong>逻辑规律是心理活动的产物</strong>（例如 “A=A” 源于人脑的联想习惯）。</li>\n<li><strong>含义（meaning）是主观心理图像</strong>（想到 “狗” 时你脑海中的狗形象）。</li>\n</ul>\n</li>\n<li><strong>致命问题</strong>：<br />\n如果逻辑依赖于个人心理，那么<strong>真理将失去普遍性</strong>（你的 “狗” 和我的 “狗” 可能不同），数学和科学的基础将崩溃。</li>\n</ul>\n<hr />\n<h4 id=\"二-胡塞尔的突破含义的先天观念性\"><a class=\"anchor\" href=\"#二-胡塞尔的突破含义的先天观念性\">#</a> <strong>二、胡塞尔的突破：含义的 “先天观念性”</strong></h4>\n<h4 id=\"1-含义不是心理图像而是观念对象\"><a class=\"anchor\" href=\"#1-含义不是心理图像而是观念对象\">#</a> 1. <strong>“含义” 不是心理图像，而是观念对象</strong></h4>\n<ul>\n<li>例：当你说 “三角形有三条边”：\n<ul>\n<li><strong>心理主义</strong>：含义 = 你脑海中具体的三角形图像（如▲）。</li>\n<li><strong>胡塞尔</strong>：含义 = <strong>“三角形” 的理想概念本身</strong>（不受具体图像影响）。</li>\n</ul>\n</li>\n<li><strong>关键区分</strong>：\n<ul>\n<li><strong>心理行为</strong>（你的思考活动，主观且多变）</li>\n<li><strong>含义内容</strong>（“三角形定义”，<strong>客观且恒定</strong>）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-先天观念性的涵义\"><a class=\"anchor\" href=\"#2-先天观念性的涵义\">#</a> 2. <strong>“先天观念性” 的涵义</strong></h4>\n<p>| 术语        | 解释                                                                 |<br />\n|-------------|----------------------------------------------------------------------|<br />\n| <strong>先天</strong>    | 独立于经验（不依赖具体感知或心理过程）                               |<br />\n| <strong>观念性</strong>  | 属于<strong>理念领域</strong>（非物理实体，也非心理状态），具有普遍性和必然性     |</p>\n<blockquote>\n<p>例：数学真理 “1+1=2” 是先天观念的 —— 即使宇宙毁灭，它仍然成立。</p>\n</blockquote>\n<h4 id=\"3-如何解放含义\"><a class=\"anchor\" href=\"#3-如何解放含义\">#</a> 3. <strong>如何 “解放” 含义？</strong></h4>\n<p>胡塞尔将含义从<strong>心理学的束缚</strong>中解放出来：</p>\n<ul>\n<li>含义不再是私人的、模糊的心理图像；</li>\n<li>而是<strong>公共的、精确的观念对象</strong>，可被不同主体<strong>同一地把握</strong>（你我理解的 “三角形” 本质相同）。</li>\n</ul>\n<hr />\n<h4 id=\"三-哲学革命为现象学奠基\"><a class=\"anchor\" href=\"#三-哲学革命为现象学奠基\">#</a> <strong>三、哲学革命：为现象学奠基</strong></h4>\n<h4 id=\"1-确立现象学领域\"><a class=\"anchor\" href=\"#1-确立现象学领域\">#</a> 1. <strong>确立现象学领域</strong></h4>\n<p>含义作为观念对象，成为现象学研究的<strong>自主领域</strong>：</p>\n<ul>\n<li>无需还原为心理过程，也无需依赖物理世界。</li>\n<li>现象学任务：<strong>直观</strong>（intuition）含义的本质（如 “什么是正义？”）。</li>\n</ul>\n<h4 id=\"2-范畴直观的可能性\"><a class=\"anchor\" href=\"#2-范畴直观的可能性\">#</a> 2. <strong>“范畴直观” 的可能性</strong></h4>\n<p>胡塞尔发现，我们不仅能直观具体事物（如看苹果），还能<strong>直接把握抽象观念</strong>（如 “红色本身”“存在本身”），这为哲学提供了严格方法。</p>\n<h4 id=\"3-影响链\"><a class=\"anchor\" href=\"#3-影响链\">#</a> 3. <strong>影响链</strong></h4>\n   <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">A[反心理主义] --&gt; B[含义作为观念对象] --&gt; C[现象学还原] --&gt; D[回到事物本身]</span><br></pre></td></tr></table></figure>\n<hr />\n<h4 id=\"马里翁视角的深意\"><a class=\"anchor\" href=\"#马里翁视角的深意\">#</a> <strong>马里翁视角的深意</strong></h4>\n<p>马里翁在《还原与给予》中重提这一突破，是为了铺垫自己的主张：</p>\n<ol>\n<li>胡塞尔解放了含义，但<strong>仍将含义绑定于主体意向性</strong>（含义需被意识 “构成”）。</li>\n<li>马里翁要进一步解放现象：\n<ul>\n<li><strong>现象自身</strong>（如神圣启示、艺术震撼）<strong>能超越主体意向性主动给予意义</strong>。</li>\n</ul>\n<blockquote>\n<p>胡塞尔释放了含义，马里翁想释放现象本身！</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h4 id=\"生活化类比理解三角形的三种方式\"><a class=\"anchor\" href=\"#生活化类比理解三角形的三种方式\">#</a> <strong>生活化类比：理解 “三角形” 的三种方式</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>理论</strong></th>\n<th><strong>如何理解 “三角形”</strong></th>\n<th><strong>问题</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>心理主义</td>\n<td>“我脑中▲的图像”</td>\n<td>你的▲和我的△不同，数学崩溃</td>\n</tr>\n<tr>\n<td>胡塞尔</td>\n<td><strong>“三角形” 的理想定义</strong>（三条边，内角和 180°）</td>\n<td>客观真理得以成立</td>\n</tr>\n<tr>\n<td>马里翁（延伸）</td>\n<td>三角形以<strong>溢出定义的方式震撼你</strong>（如分形艺术中无限复杂的三角结构）</td>\n<td>现象反抗主体的概念框架</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h4 id=\"为什么这一突破如此重要\"><a class=\"anchor\" href=\"#为什么这一突破如此重要\">#</a> <strong>为什么这一突破如此重要？</strong></h4>\n<ul>\n<li><strong>拯救了逻辑与数学的客观性</strong>：使 20 世纪分析哲学、语言哲学成为可能。</li>\n<li><strong>现象学奠基</strong>：为 “回到事物本身” 提供方法论，影响海德格尔、梅洛 - 庞蒂等。</li>\n<li><strong>马里翁的跳板</strong>：若含义可独立于心理，现象为何不能独立于主体？</li>\n</ul>\n<blockquote>\n<p>胡塞尔解放了含义，马里翁则试图用<strong>给予性</strong>解放现象本身 —— 这是《还原与给予》的核心战役。</p>\n</blockquote>\n<h3 id=\"q-3\"><a class=\"anchor\" href=\"#q-3\">#</a> Q:</h3>\n<p>什么是 “一切原则的原则”</p>\n<p>A:<br />\n 胡塞尔的 “<strong>一切原则的原则</strong>”（the principle of all principles）是现象学的<strong>方法论基石</strong>，出自《纯粹现象学和现象学哲学的观念》（1913）。它定义了现象学如何 “回到事物本身”，并直接影响了马里翁对 “给予性” 的思考。以下是分层解析：</p>\n<hr />\n<h4 id=\"一-原则的原文与核心主张\"><a class=\"anchor\" href=\"#一-原则的原文与核心主张\">#</a> <strong>一、原则的原文与核心主张</strong></h4>\n<blockquote>\n<p><strong>“任何原初给予的直观都是知识的合法源泉，在直观中原初地（可说是在其机体的现实中）给予我们的东西，应按其被给予的限度被接受。”</strong><br />\n（《观念 I》§24）</p>\n</blockquote>\n<h4 id=\"关键点浓缩\"><a class=\"anchor\" href=\"#关键点浓缩\">#</a> 关键点浓缩：</h4>\n<ol>\n<li><strong>直观优先</strong>：知识的终极基础是<strong>直观</strong>（直接体验），而非逻辑推理或理论假设。</li>\n<li><strong>原初给予性</strong>：现象必须在<strong>亲身被给予</strong>的限度内被承认。</li>\n<li><strong>反建构主义</strong>：禁止用先验概念篡改现象的自我显现。</li>\n</ol>\n<blockquote>\n<p>💡 简单说：<strong>现象怎么显现场，就怎么接受它！</strong></p>\n</blockquote>\n<hr />\n<h4 id=\"二-为什么这是一切原则的原则\"><a class=\"anchor\" href=\"#二-为什么这是一切原则的原则\">#</a> <strong>二、为什么这是 “一切原则的原则”？</strong></h4>\n<p>它颠覆了传统哲学的认知等级：</p>\n<table>\n<thead>\n<tr>\n<th><strong>传统哲学</strong></th>\n<th><strong>胡塞尔的现象学</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>理性推理 &gt; 感官经验</td>\n<td><strong>直观经验 &gt; 理性建构</strong></td>\n</tr>\n<tr>\n<td>理论优先于现象</td>\n<td><strong>现象优先于理论</strong></td>\n</tr>\n<tr>\n<td>主体强加范畴于对象</td>\n<td><strong>让对象自身显现</strong></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>地位</strong>：它是现象学还原的<strong>终极依据</strong>，其他方法（如悬置判断）皆服务于它。</li>\n</ul>\n<hr />\n<h4 id=\"三-直观的深意不仅是感官更是范畴直观\"><a class=\"anchor\" href=\"#三-直观的深意不仅是感官更是范畴直观\">#</a> <strong>三、“直观” 的深意：不仅是感官，更是范畴直观</strong></h4>\n<p>胡塞尔的 “直观” 包含两类：</p>\n<ol>\n<li><strong>感性直观</strong>（Sensory Intuition）：\n<ul>\n<li>感知具体事物（如看见红色、触摸冰块）。</li>\n</ul>\n</li>\n<li><strong>范畴直观</strong>（Categorical Intuition）⭐：\n<ul>\n<li><strong>直接把握抽象本质</strong>（如 “红本身”“正义”“存在”）。</li>\n</ul>\n<blockquote>\n<p>例：当你理解 “5+7=12”，你不是在数手指，而是直观到数学真理本身。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li><strong>突破性</strong>：传统哲学认为抽象概念需通过推理获得，胡塞尔宣称我们能<strong>直接 “看见” 本质</strong>。</li>\n</ul>\n<hr />\n<h4 id=\"四-马里翁的继承与批判\"><a class=\"anchor\" href=\"#四-马里翁的继承与批判\">#</a> <strong>四、马里翁的继承与批判</strong></h4>\n<p>马里翁在《还原与给予》中，以此原则为跳板推进现象学革命：</p>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>胡塞尔</strong></th>\n<th><strong>马里翁的推进</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>给予者</strong></td>\n<td>主体意向性构成现象</td>\n<td><strong>现象自身给予</strong>（自我显现）</td>\n</tr>\n<tr>\n<td><strong>直观界限</strong></td>\n<td>受限于主体认知结构</td>\n<td><strong>饱和现象突破主体框架</strong></td>\n</tr>\n<tr>\n<td>“原则” 的缺陷</td>\n<td>隐含主体中心性</td>\n<td>解放现象的绝对给予性</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>继承</strong>：完全接受 “直观作为源泉”。</li>\n<li><strong>批判</strong>：胡塞尔仍要求现象<strong>符合主体的直观能力</strong>（如时间 / 空间形式），而饱和现象（如神迹、艺术）<strong>溢出直观能力</strong>，迫使主体被动接受。\n<blockquote>\n<p>马里翁：若现象以不可控的方式给予，主体必须 “投降” 而非 “构成”。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"五-生活化类比\"><a class=\"anchor\" href=\"#五-生活化类比\">#</a> <strong>五、生活化类比</strong></h4>\n<p>想象你第一次看到极光：</p>\n<ul>\n<li><strong>传统哲学家</strong>：<br />\n用物理学解释（电子碰撞大气层），忽略眼前的震撼。</li>\n<li><strong>胡塞尔</strong>：<br />\n<strong>暂停科学理论</strong>，专注描述极光<strong>如何直接呈现</strong>于你的视觉（色彩流动、空间感）。</li>\n<li><strong>马里翁</strong>：<br />\n极光以<strong>超越你认知的壮美</strong>（饱和现象）击溃你，你只能惊叹 ——“它给予的远比我能接受的更多”。</li>\n</ul>\n<hr />\n<h4 id=\"六-该原则的哲学史意义\"><a class=\"anchor\" href=\"#六-该原则的哲学史意义\">#</a> <strong>六、该原则的哲学史意义</strong></h4>\n<p>| Column1. <strong>反形而上学</strong>：拒绝用抽象概念（如 “实体”“上帝”）覆盖真实经验。<br />\n2. <strong>反科学主义</strong>：科学模型需回溯到直观经验，而非替代经验。<br />\n3. <strong>为现象学奠基</strong>：所有现象学研究必须始于 “直观到的被给予者”。</p>\n<blockquote>\n<p>马里翁的使命：若现象自身是给予的源泉，那么现象学还原的终点应是<strong>现象的绝对给予性</strong>，而非主体的意向性。这正是《还原与给予》的书名深意。</p>\n</blockquote>\n<h3 id=\"我们要在充分发挥了的直观中获得明见性\"><a class=\"anchor\" href=\"#我们要在充分发挥了的直观中获得明见性\">#</a> 我们要在充分发挥了的直观中获得明见性：</h3>\n<p>这个在现时抽象中被给予之物与语词含义在规律表述中所指之物是真实而现实的同一体。</p>\n<h3 id=\"q-4\"><a class=\"anchor\" href=\"#q-4\">#</a> Q:</h3>\n<p>我不太理解先天观念性，这个概念不需要论证吗，还是说这是个前提条件，为什么就能得出我直观的就是事物本身的含义</p>\n<p>A:<br />\n 你的质疑非常犀利！这正点中了现象学最关键的难题：<strong>胡塞尔如何能断言 “先天观念性” 的存在？它是否只是一个未被论证的前提？</strong> 让我们解剖这个问题的复杂性，从现象学的内在逻辑和潜在争议入手：</p>\n<hr />\n<h4 id=\"一-先天观念性的论证逻辑现象学描述而非传统证明\"><a class=\"anchor\" href=\"#一-先天观念性的论证逻辑现象学描述而非传统证明\">#</a> <strong>一、“先天观念性” 的论证逻辑：现象学描述而非传统证明</strong></h4>\n<p>胡塞尔的方法不是数学式的 “演绎论证”，而是通过<strong>现象学描述</strong>让你 “<strong>看见</strong>” 观念性的存在。其步骤可概括为：</p>\n<ol>\n<li>\n<p><strong>揭露心理主义的荒谬</strong>：<br />\n如果含义是主观心理图像 → 则逻辑 / 数学失去客观性 → 科学知识崩溃（归谬法）。</p>\n<blockquote>\n<p>例：若 “1+1=2” 取决于你的脑细胞状态，数学将无法普遍有效。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>引导你 “直观” 观念对象</strong>：</p>\n<ul>\n<li><strong>操作</strong>：请你反思 “三角形” 的含义：\n<ul>\n<li>你脑海中的▲（心理图像）总是模糊的、可变的（如角度不精确），</li>\n<li>但你理解的 “三角形本质”（三条边、内角和 180°）是<strong>精确、永恒不变</strong>的。</li>\n</ul>\n</li>\n<li><strong>结论</strong>：这个不变的 “本质” 就是<strong>先天观念对象</strong> —— 它独立于你的心理活动。</li>\n</ul>\n</li>\n<li>\n<p><strong>本质直观（Wesensschau）的合法性</strong>：<br />\n胡塞尔认为，通过<strong>悬置经验判断</strong>（现象学还原），你能直接 “看” 到观念本质，如同用眼睛看颜色。</p>\n<blockquote>\n<p>这不是推理，而是<strong>认知方式的转换</strong> —— 就像从平面视角切换到 3D 视角后，你突然理解了空间关系。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h4 id=\"二-为什么敢说直观到事物本身现象学还原的保障\"><a class=\"anchor\" href=\"#二-为什么敢说直观到事物本身现象学还原的保障\">#</a> <strong>二、为什么敢说 “直观到事物本身”？—— 现象学还原的保障</strong></h4>\n<p>胡塞尔通过两步操作，试图确保直观的客观性：</p>\n<table>\n<thead>\n<tr>\n<th><strong>步骤</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>悬置判断</strong>（Epoche）</td>\n<td>搁置对 “三角形是否存在” 的信念，专注其<strong>显现方式</strong>（避免经验干扰）。</td>\n</tr>\n<tr>\n<td><strong>本质还原</strong></td>\n<td>从具体三角形（▲/△）中 “抽象” 出普遍本质，但非逻辑抽象，而是<strong>直观本质</strong>。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>关键主张</strong>：<br />\n还原后，意识中呈现的<strong>就是事物本身</strong>（现象），而非心理表征或物理对象。\n<blockquote>\n<p>例：还原后你关注的不是纸上画的▲，而是 “三角形性”（triangularity）本身。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"三-潜在争议循环论证\"><a class=\"anchor\" href=\"#三-潜在争议循环论证\">#</a> <strong>三、潜在争议：循环论证？</strong></h4>\n<p>批评者（如自然主义者）指出：</p>\n<ul>\n<li>现象学预设了 “直观能把握本质”，但这正是待证明的！</li>\n<li>所谓 “观念对象” 可能只是<strong>大脑的认知错觉</strong>（神经活动模式）。</li>\n</ul>\n<h4 id=\"胡塞尔的回应\"><a class=\"anchor\" href=\"#胡塞尔的回应\">#</a> 胡塞尔的回应：</h4>\n<ol>\n<li>\n<p><strong>先验转向</strong>：<br />\n不讨论 “观念对象是否实存”，而探究 “它如何必然被我们经验”。</p>\n<blockquote>\n<p>类似康德：不问 “上帝是否存在”，而问 “为何人类必有上帝观念”。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>自明性（Evidenz）标准</strong>：<br />\n当一种直观达到<strong>明见性</strong>（无可置疑的清晰性），它就是真理的源泉。</p>\n<blockquote>\n<p>例：你无法怀疑 “思维中的怀疑行为本身存在”（笛卡尔式自明）。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h4 id=\"四-马里翁的推进从直观到给予\"><a class=\"anchor\" href=\"#四-马里翁的推进从直观到给予\">#</a> <strong>四、马里翁的推进：从 “直观” 到 “给予”</strong></h4>\n<p>马里翁在《还原与给予》中揭示胡塞尔的深层矛盾：</p>\n<ul>\n<li><strong>胡塞尔的理想</strong>：让现象自身显现（一切原则的原则）。</li>\n<li><strong>实际执行</strong>：现象必须<strong>符合主体的直观能力</strong>（如时间 / 空间形式），否则无法被接纳。</li>\n</ul>\n<h4 id=\"马里翁的解决方案\"><a class=\"anchor\" href=\"#马里翁的解决方案\">#</a> 马里翁的解决方案：</h4>\n<ol>\n<li><strong>倒转关系</strong>：<br />\n不是主体 “直观” 现象，而是现象 “给予” 自身。</li>\n<li><strong>饱和现象的颠覆性</strong>：<br />\n某些现象（如神迹、无限的爱）<strong>溢出主体的直观能力</strong>，迫使主体承认：\n<ul>\n<li>直观有其界限，</li>\n<li><strong>现象自身才是意义的绝对源泉</strong>。</li>\n</ul>\n<blockquote>\n<p>此时，“先天观念性” 被 “绝对给予性” 取代 —— 观念不是被主体 “看见” 的，而是现象主动 “撞击” 主体。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h4 id=\"五-生活化类比理解三角形的两种进路\"><a class=\"anchor\" href=\"#五-生活化类比理解三角形的两种进路\">#</a> <strong>五、生活化类比：理解 “三角形” 的两种进路</strong></h4>\n<h4 id=\"场景你和朋友争论什么是完美三角形\"><a class=\"anchor\" href=\"#场景你和朋友争论什么是完美三角形\">#</a> <strong>场景</strong>：你和朋友争论 “什么是完美三角形”</h4>\n<ul>\n<li><strong>自然主义者</strong>：<br />\n“完美三角形不存在！你看到的只是近似▲的物理图形或神经元放电。”</li>\n<li><strong>胡塞尔主义者</strong>：<br />\n“闭上眼，悬置对纸笔的信念，专注‘三角形’的意义 —— 你是否‘看到’一个超越一切具体图像的、精确的几何本质？”</li>\n<li><strong>马里翁主义者</strong>：<br />\n“当你突然被分形几何中的曼德博集合震撼时（无限复杂的三角结构），是数学现象自身在向你显现其深渊般的给予性，而非你在‘把握’它。”</li>\n</ul>\n<hr />\n<h4 id=\"结论现象学的冒险\"><a class=\"anchor\" href=\"#结论现象学的冒险\">#</a> 结论：现象学的 “冒险”</h4>\n<p>胡塞尔对 “先天观念性” 的坚持，本质是<strong>一场哲学赌注</strong>：</p>\n<ol>\n<li><strong>赌直观的可靠性</strong>：人能通过训练直接把握本质。</li>\n<li><strong>赌现象学描述的严格性</strong>：还原后的体验是普遍的、可交流的。</li>\n<li><strong>赌反心理主义的必要性</strong>：若放弃观念客观性，理性将崩塌。</li>\n</ol>\n<blockquote>\n<p>马里翁则赌得更激进：<strong>现象给予的暴力性能冲破主体性的牢笼</strong>，这恰是《还原与给予》的革命性所在。</p>\n</blockquote>\n<h3 id=\"q-5\"><a class=\"anchor\" href=\"#q-5\">#</a> Q:</h3>\n<p>什么是回到实事本身，与原则的原则有什么区别</p>\n<p>A:<br />\n“<strong>回到实事本身</strong>”（Zu den Sachen selbst!）是胡塞尔现象学的<strong>总纲领</strong>，而 “<strong>一切原则的原则</strong>” 是实现这一纲领的<strong>具体方法论准则</strong>。二者是目标与手段的关系，但隐含深刻张力。让我们通过对比解析它们的联系与区别：</p>\n<hr />\n<h4 id=\"一-核心定义与关系\"><a class=\"anchor\" href=\"#一-核心定义与关系\">#</a> <strong>一、核心定义与关系</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>概念</strong></th>\n<th><strong>定位</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>回到实事本身</strong></td>\n<td><strong>现象学目标</strong></td>\n<td>哲学的根本任务：摆脱偏见，<strong>直接面向现象</strong>（而非理论建构）。</td>\n</tr>\n<tr>\n<td><strong>一切原则的原则</strong></td>\n<td><strong>第一方法论</strong></td>\n<td>实现上述目标的<strong>操作标准</strong>：以直观到的 “原初给予” 为唯一合法知识来源。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>简言之：</p>\n<ul>\n<li><strong>“回到实事” 是目的地</strong>（“去罗马！”），</li>\n<li><strong>“原则的原则” 是交通工具使用手册</strong>（“必须坐火车去，禁止绕路！”）。</li>\n</ul>\n</blockquote>\n<hr />\n<h4 id=\"二-如何理解回到实事本身\"><a class=\"anchor\" href=\"#二-如何理解回到实事本身\">#</a> <strong>二、如何理解 “回到实事本身”？</strong></h4>\n<h4 id=\"1-针对谁的革命\"><a class=\"anchor\" href=\"#1-针对谁的革命\">#</a> 1. <strong>针对谁的革命？</strong></h4>\n<ul>\n<li>反对<strong>传统形而上学</strong>：用抽象概念（如 “实体”“上帝”）覆盖真实经验。</li>\n<li>反对<strong>科学主义</strong>：用数学公式替代生活世界（如用 “波长” 定义红色，忽略红玫瑰的绚烂）。</li>\n</ul>\n<h4 id=\"2-实事sachen指什么\"><a class=\"anchor\" href=\"#2-实事sachen指什么\">#</a> 2. <strong>“实事”（Sachen）指什么？</strong></h4>\n<p>不是物理对象，而是<strong>意识中显现的现象</strong>，包括：</p>\n<ul>\n<li>感官对象（苹果的颜色）</li>\n<li>抽象观念（正义、数字）</li>\n<li>情感体验（爱的感受）</li>\n</ul>\n<blockquote>\n<p>💡 关键：现象必须<strong>如其显现自身的样子</strong>被考察，而非被理论扭曲。</p>\n</blockquote>\n<h4 id=\"3-如何回到\"><a class=\"anchor\" href=\"#3-如何回到\">#</a> 3. <strong>如何 “回到”？</strong></h4>\n<p>通过 <strong>现象学还原</strong>（悬置自然态度），剥离附加在现象上的预设：<br />\n| <strong>自然态度</strong>          | <strong>现象学态度</strong>              |<br />\n|-----------------------|----------------------------|<br />\n| 相信苹果独立于意识存在 | 关注 “苹果”<strong> 如何向意识显现</strong> |<br />\n| 用生物学解释爱情      | 描述爱<strong>被体验的方式</strong>       |</p>\n<hr />\n<h4 id=\"三-一切原则的原则的特殊性它给回到实事套上枷锁\"><a class=\"anchor\" href=\"#三-一切原则的原则的特殊性它给回到实事套上枷锁\">#</a> <strong>三、“一切原则的原则” 的特殊性 —— 它给 “回到实事” 套上枷锁</strong></h4>\n<p>胡塞尔为 “回到实事” 设置了<strong>不可违反的操作规则</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TB</span><br><span class=\"line\">    A[回到实事本身] -- 必须通过 --&gt; B[一切原则的原则]</span><br><span class=\"line\">    B -- 要求 --&gt; C[仅接受原初直观的给予]</span><br><span class=\"line\">    C -- 依赖 --&gt; D[主体意向性的构成能力]</span><br></pre></td></tr></table></figure>\n<h4 id=\"枷锁体现\"><a class=\"anchor\" href=\"#枷锁体现\">#</a> <strong>枷锁体现</strong>：</h4>\n<ol>\n<li>\n<p><strong>直观的垄断性</strong>：<br />\n现象必须被<strong>主体直观到</strong>才能合法 —— 若现象超出直观能力（如 “无限”），则被排除。</p>\n<blockquote>\n<p>例：神启若无法被感官或范畴直观，则不被承认为 “实事”。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>主体中心的隐性预设</strong>：<br />\n现象需符合主体的认知结构（时间 / 空间形式），否则无法 “被给予”。</p>\n<ul>\n<li><strong>马里翁的批评</strong>：这实则是<strong>主体对现象的暴力驯化</strong>，违背了 “回到实事” 的初心。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h4 id=\"四-关键区别目标-vs-手段的断裂\"><a class=\"anchor\" href=\"#四-关键区别目标-vs-手段的断裂\">#</a> <strong>四、关键区别：目标 vs. 手段的断裂</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>回到实事本身</strong></th>\n<th><strong>一切原则的原则</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>开放性</strong></td>\n<td>理想上<strong>向所有现象敞开</strong></td>\n<td><strong>以直观为门槛</strong>，过滤 “非常态” 现象</td>\n</tr>\n<tr>\n<td><strong>主客体关系</strong></td>\n<td>现象优先（消弭主客对立）</td>\n<td>隐含<strong>主体对现象的审查权</strong></td>\n</tr>\n<tr>\n<td><strong>马里翁的批判</strong></td>\n<td>应彻底忠于现象自身给予性</td>\n<td>实际沦为<strong>主体中心主义的工具</strong></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>悖论</strong>：胡塞尔的口号呼吁 “回到现象”，但他的方法却要求 “现象回到主体框架内”。</p>\n</blockquote>\n<hr />\n<h4 id=\"五-案例如何分析一次宗教启示\"><a class=\"anchor\" href=\"#五-案例如何分析一次宗教启示\">#</a> <strong>五、案例：如何分析 “一次宗教启示”</strong></h4>\n<p>- 你不是在数手指 <strong>胡塞尔的操作</strong>：</p>\n<ol>\n<li>悬置对 “神是否存在” 的判断（现象学还原）。</li>\n<li>尝试<strong>直观</strong>该体验 —— 若启示内容（如 “无限者”）<strong>无法被主体直观</strong>（超出时空范畴），则判定其无效。<br />\n→ 结论：这不是合法 “实事”。</li>\n</ol>\n<ul>\n<li><strong>马里翁的主张</strong>（《还原与给予》）：\n<ol>\n<li>宗教启示作为 <strong>“饱和现象”</strong>，恰恰以<strong>溢出直观能力的方式给予自身</strong>。</li>\n<li>真正的 “回到实事本身” 要求<strong>放弃直观原则</strong>，接受现象自身的绝对给予性。<br />\n→ 结论：启示是更高阶的 “实事”，它暴露了胡塞尔原则的局限。</li>\n</ol>\n</li>\n</ul>\n<hr />\n<h4 id=\"六-哲学史意义马里翁的颠覆\"><a class=\"anchor\" href=\"#六-哲学史意义马里翁的颠覆\">#</a> <strong>六、哲学史意义：马里翁的颠覆</strong></h4>\n<p>马里翁认为：</p>\n<ul>\n<li><strong>真正的 “回到实事本身”</strong> 必须忠于现象<strong>自我显现的绝对自由</strong>，哪怕颠覆主体框架。</li>\n<li><strong>胡塞尔的矛盾</strong>：<br />\n他的目标（回到实事）是革命的，<br />\n他的手段（原则的原则）却是保守的 —— 将现象囚禁在 “主体牢笼” 中。\n<blockquote>\n<p><strong>解决路径</strong>：用 <strong>“给予性”</strong> 替代 <strong>“直观性”</strong> 作为最高原则 —— 现象学应从 “主体构成” 转向 “现象给予”。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"结语从口号到战场\"><a class=\"anchor\" href=\"#结语从口号到战场\">#</a> <strong>结语：从口号到战场</strong></h4>\n<ul>\n<li><strong>胡塞尔</strong>：<br />\n“回到实事” 的口号 + “直观原则” 的方法 → 现象学作为<strong>严格科学</strong>。</li>\n<li><strong>马里翁</strong>：<br />\n解放 “回到实事” 的原始承诺 → 现象学作为 <strong>“给予性” 的启示录</strong>。</li>\n</ul>\n<blockquote>\n<p>二者的张力正是《还原与给予》的核心动力：若现象自身是源泉，那么连 “直观” 都可能是对现象的遮蔽 —— 真正的还原，是还原到<strong>无条件的给予</strong>。</p>\n</blockquote>\n<h3 id=\"q-6\"><a class=\"anchor\" href=\"#q-6\">#</a> Q:</h3>\n<p>什么是存在论</p>\n<p>A:<br />\n<strong> 存在论（Ontology）</strong> 是哲学的核心分支，探究 <strong>“存在本身”（Being as such）</strong> 而非具体存在者的终极问题。它追问：</p>\n<ul>\n<li><strong>什么使事物 “存在” 而非 “不存在”？</strong></li>\n<li><strong>“存在” 本身意味着什么？</strong></li>\n<li><strong>不同存在者（如物质、意识、数字）的存在方式有何根本差异？</strong></li>\n</ul>\n<p>以下从 <strong>概念内涵、历史演进、现象学转向</strong> 三方面解析，并关联马里翁《还原与给予》的批判性突破 ——</p>\n<hr />\n<h4 id=\"一-存在论的核心问题\"><a class=\"anchor\" href=\"#一-存在论的核心问题\">#</a> 一、<strong>存在论的核心问题</strong></h4>\n<h4 id=\"1-存在-vs-存在者海德格尔的存在论差异\"><a class=\"anchor\" href=\"#1-存在-vs-存在者海德格尔的存在论差异\">#</a> 1. <strong>存在 vs. 存在者</strong>（海德格尔的 “存在论差异”）</h4>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>解释</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存在者</strong>（beings）</td>\n<td>具体存在的实体（人、石头、数字、情感）</td>\n<td>这把椅子、牛顿定律、你此刻的喜悦</td>\n</tr>\n<tr>\n<td><strong>存在</strong>（Being）</td>\n<td>使存在者得以存在的 <strong>根本条件</strong> 或 <strong>显现方式</strong>（非实体）</td>\n<td>椅子的 “物性”、定律的 “真理性”、喜悦的 “情绪性”</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>关键</strong>：存在论不研究 “椅子是什么”，而研究 <strong>“椅子为何能作为‘物’存在”</strong>。</p>\n</blockquote>\n<h4 id=\"2-经典问题域\"><a class=\"anchor\" href=\"#2-经典问题域\">#</a> 2. <strong>经典问题域</strong></h4>\n<ul>\n<li>存在是 <strong>一还是多</strong>？</li>\n<li>存在是 <strong>物质还是精神</strong>？</li>\n<li>存在具有 <strong>层级结构</strong> 吗？（如柏拉图：理念 &gt; 现象）</li>\n<li><strong>虚无是否存在</strong>？</li>\n</ul>\n<hr />\n<h4 id=\"二-存在论的历史演进\"><a class=\"anchor\" href=\"#二-存在论的历史演进\">#</a> 二、<strong>存在论的历史演进</strong></h4>\n<h4 id=\"1-古希腊奠基\"><a class=\"anchor\" href=\"#1-古希腊奠基\">#</a> 1. <strong>古希腊奠基</strong></h4>\n<ul>\n<li><strong>巴门尼德</strong>：存在是 “ <strong>一</strong> ”（永恒不变），非存在不可言说。</li>\n<li><strong>亚里士多德</strong>：提出 <strong>“第一哲学”</strong>（即存在论），定义存在为 <strong>“实体”</strong>（ousia），并通过 <strong>范畴</strong>（如质、量、关系）分析存在方式。</li>\n</ul>\n<h4 id=\"2-中世纪神学转向\"><a class=\"anchor\" href=\"#2-中世纪神学转向\">#</a> 2. <strong>中世纪神学转向</strong></h4>\n<ul>\n<li>存在 = <strong>上帝创造</strong>（阿奎那：存在分等级，上帝是 “纯粹存在”）。</li>\n</ul>\n<h4 id=\"3-近代认识论挤压\"><a class=\"anchor\" href=\"#3-近代认识论挤压\">#</a> 3. <strong>近代认识论挤压</strong></h4>\n<ul>\n<li>笛卡尔 → 康德：存在论问题被 <strong>认识论</strong>（人如何认识存在？）取代。\n<blockquote>\n<p>康德：存在 <strong>不是谓词</strong>（说 “上帝存在” 未增加新内容），只能通过主体范畴认知。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"4-现象学重启存在论\"><a class=\"anchor\" href=\"#4-现象学重启存在论\">#</a> 4. <strong>现象学重启存在论</strong></h4>\n<table>\n<thead>\n<tr>\n<th>哲学家</th>\n<th>突破</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>胡塞尔</strong></td>\n<td>搁置 “存在是否客观” 问题，专注 <strong>现象如何在意识中显现</strong>（意向性）。</td>\n</tr>\n<tr>\n<td><strong>海德格尔</strong></td>\n<td>⭐ <strong>存在论革命</strong>：追问 <strong>“存在本身的意义”</strong>，揭示 “此在”（人）是理解存在的通道。</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h4 id=\"三-海德格尔的存在论革命-马里翁的批判\"><a class=\"anchor\" href=\"#三-海德格尔的存在论革命-马里翁的批判\">#</a> 三、<strong>海德格尔的存在论革命 → 马里翁的批判</strong></h4>\n<h4 id=\"1-海德格尔的核心主张\"><a class=\"anchor\" href=\"#1-海德格尔的核心主张\">#</a> 1. <strong>海德格尔的核心主张</strong></h4>\n<ul>\n<li><strong>此在（Dasein）优先性</strong>：<br />\n只有人（此在）会追问存在意义，故存在论需通过 <strong>此在的生存分析</strong>（如 “在世”“向死而生”）展开。</li>\n<li><strong>存在被时间性定义</strong>：<br />\n存在不是现成实体，而是 <strong>动态的 “去存在”</strong>（becoming），其意义在时间中生成。</li>\n</ul>\n<h4 id=\"2-马里翁在还原与给予中的爆破\"><a class=\"anchor\" href=\"#2-马里翁在还原与给予中的爆破\">#</a> 2. <strong>马里翁在《还原与给予》中的爆破</strong></h4>\n<p>马里翁认为海德格尔仍陷于 <strong>隐蔽的主体中心主义</strong>：</p>\n<ul>\n<li><strong>问题</strong>：<br />\n海德格尔让 <strong>此在垄断存在意义的解释权</strong>（存在需通过此在的生存结构显现）。</li>\n<li><strong>解决方案</strong>：<br />\n用 <strong>“给予性”（givenness）取代 “存在”</strong> 作为第一哲学范畴：\n<ul>\n<li>现象（如神迹、艺术品）可 <strong>主动自我给予</strong>，溢出此在的理解框架（饱和现象）。</li>\n<li><strong>存在本身也需被给予</strong>！ → 存在不是起点，而是 <strong>给予的结果</strong>。</li>\n</ul>\n<blockquote>\n<p>“存在者必须首先 <strong>被给予</strong>，才能追问其存在” —— 这才是现象学最彻底的还原。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"四-生活化类比存在论的三种视角\"><a class=\"anchor\" href=\"#四-生活化类比存在论的三种视角\">#</a> 四、<strong>生活化类比：存在论的三种视角</strong></h4>\n<h4 id=\"场景面对一座雪山\"><a class=\"anchor\" href=\"#场景面对一座雪山\">#</a> <strong>场景</strong>：面对一座雪山</h4>\n<table>\n<thead>\n<tr>\n<th>视角</th>\n<th>存在论问题</th>\n<th>回应</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>传统哲学</strong></td>\n<td>雪山是 <strong>什么实体</strong>？</td>\n<td>“由岩石、冰雪构成的物质实体”</td>\n</tr>\n<tr>\n<td><strong>海德格尔</strong></td>\n<td>雪山如何向 <strong>此在显现存在意义</strong>？</td>\n<td>“在攀登的畏与美中，揭示自然的在场性”</td>\n</tr>\n<tr>\n<td><strong>马里翁</strong></td>\n<td>雪山如何 <strong>自我给予</strong> 其存在？</td>\n<td>“雪山的壮美 <strong>强行侵入</strong> 我的感知，使我被动接受其超越性”</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h4 id=\"五-为什么马里翁要解构存在论\"><a class=\"anchor\" href=\"#五-为什么马里翁要解构存在论\">#</a> 五、<strong>为什么马里翁要解构存在论？</strong></h4>\n<p>在《还原与给予》中，他试图证明：</p>\n<ol>\n<li>\n<p><strong>存在论的历史是遗忘 “给予性” 的历史</strong>：<br />\n从古希腊到海德格尔，哲学总将存在 <strong>预设为起点</strong>，却忽略了存在者首先需 <strong>被给予我们</strong>。</p>\n</li>\n<li>\n<p><strong>现象学应回归更本源维度</strong>：</p>\n<p>饱和现象（如十字架上的牺牲、梵高的《星空》）证明：</p>\n<ul>\n<li><strong>给予先于存在</strong>，</li>\n<li><strong>现象自身才是意义的绝对源泉</strong>。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>存在论非被废除，而是被 <strong>置于给予性之下</strong> —— 这是马里翁对现象学的彻底激进化。</p>\n</blockquote>\n<hr />\n<h3 id=\"q-7\"><a class=\"anchor\" href=\"#q-7\">#</a> Q:</h3>\n<p>怎么理解下面这段话：“如果这种对认识意义的思索所提供的不是一种单纯的意见，而是像这里所严格要求的那样，提供一种明晰的 (einsichtig) 知识，那么它就必须在被给予的思维体验和认识体验的典范性的基础上作为纯粹的本质直观来进行”</p>\n<p>A:<br />\n 这段出自胡塞尔《现象学的观念》的文本，浓缩了现象学作为<strong>严格科学</strong>的方法论核心 —— 它要求哲学必须摆脱意见（doxa），通过<strong>本质直观</strong>（Wesensschau）获得<strong>绝对明晰的知识</strong>。以下分三步拆解其逻辑：</p>\n<hr />\n<h4 id=\"一-句子结构解剖\"><a class=\"anchor\" href=\"#一-句子结构解剖\">#</a> <strong>一、句子结构解剖</strong></h4>\n<blockquote>\n<p>“如果这种对认识意义的思索……”</p>\n<ul>\n<li><strong>目标</strong>：获得 <strong>“明晰的知识”</strong>（非主观意见）</li>\n<li><strong>方法</strong>：<strong>纯粹的本质直观</strong></li>\n<li><strong>操作基础</strong>：<strong>被给予的思维体验和认识体验的典范性实例</strong></li>\n</ul>\n</blockquote>\n<hr />\n<h4 id=\"二-关键概念解析\"><a class=\"anchor\" href=\"#二-关键概念解析\">#</a> <strong>二、关键概念解析</strong></h4>\n<h4 id=\"1-明晰的知识einsichtig\"><a class=\"anchor\" href=\"#1-明晰的知识einsichtig\">#</a> 1. <strong>“明晰的知识”（einsichtig）</strong></h4>\n<ul>\n<li>不是逻辑推理的结论，而是 <strong>直接自明的真理</strong>（如同 “2+2=4” 般无可置疑）。</li>\n<li>要求 <strong>绝对清晰性</strong>，排除任何模糊、推测或传统偏见。</li>\n</ul>\n<blockquote>\n<p>💡 现象学的野心：哲学应像数学一样严密。</p>\n</blockquote>\n<h4 id=\"2-被给予的思维体验和认识体验\"><a class=\"anchor\" href=\"#2-被给予的思维体验和认识体验\">#</a> 2. <strong>“被给予的思维体验和认识体验”</strong></h4>\n<ul>\n<li><strong>思维体验</strong>（Denkerlebnisse）：具体意识活动（如怀疑、判断、想象）。</li>\n<li><strong>认识体验</strong>（Erkenntniserlebnisse）：指向真理的意识行为（如理解一个数学证明）。</li>\n<li><strong>关键</strong>：这些体验必须是 <strong>现象学还原后的纯粹现象</strong>（悬置其是否对应外部实在），仅关注其 <strong>内在被给予性</strong>。</li>\n</ul>\n<h4 id=\"3-典范性的基础上\"><a class=\"anchor\" href=\"#3-典范性的基础上\">#</a> 3. <strong>“典范性的基础上”</strong></h4>\n<ul>\n<li>需选取 <strong>典型实例</strong> 作为分析对象（如分析 “感知” 时，选一个苹果的视觉体验）。</li>\n<li>这些实例是 <strong>本质直观的跳板</strong>，类似几何学家用具体三角形把握 “三角性”。</li>\n</ul>\n<h4 id=\"4-纯粹的本质直观reine-wesensintuition\"><a class=\"anchor\" href=\"#4-纯粹的本质直观reine-wesensintuition\">#</a> 4. <strong>“纯粹的本质直观”</strong>（reine Wesensintuition）⭐</h4>\n<ul>\n<li><strong>本质直观 ≠ 经验归纳</strong>：\n<table>\n<thead>\n<tr>\n<th>经验归纳</th>\n<th>本质直观</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>从 100 个苹果观察红色</td>\n<td>从一个苹果的红色 <strong>直观 “红本身”</strong></td>\n</tr>\n</tbody>\n</table>\n</li>\n<li><strong>操作步骤</strong>：\n<ol>\n<li><strong>自由想象变更</strong>：在想象中任意修改苹果的属性（大小、形状、位置）。</li>\n<li><strong>发现不变项</strong>：当所有属性变化时，“红” 的<strong>本质内核</strong>依然恒定。</li>\n<li><strong>把握本质</strong>：这个不变项（如 “视觉延展性”“色谱定位”）就是 <strong>“红” 的本质</strong>。</li>\n</ol>\n</li>\n</ul>\n<hr />\n<h4 id=\"三-深层逻辑现象学如何成为严格科学\"><a class=\"anchor\" href=\"#三-深层逻辑现象学如何成为严格科学\">#</a> <strong>三、深层逻辑：现象学如何成为 “严格科学”？</strong></h4>\n<h4 id=\"1-对抗两种错误路径\"><a class=\"anchor\" href=\"#1-对抗两种错误路径\">#</a> 1. <strong>对抗两种错误路径</strong></h4>\n<p>| 错误类型       | 问题                     | 现象学方案               |<br />\n|----------------|--------------------------|--------------------------|<br />\n| <strong>经验主义</strong>   | 依赖感官，知识或然性     | 通过本质直观获得<strong>必然性</strong> |<br />\n| <strong>理性主义</strong>   | 脱离体验，陷入概念空转   | 以<strong>被给予的体验</strong>为地基 |</p>\n<h4 id=\"2-本质直观的合法性保障\"><a class=\"anchor\" href=\"#2-本质直观的合法性保障\">#</a> 2. <strong>本质直观的合法性保障</strong></h4>\n<ul>\n<li><strong>自明性</strong>（Evidenz）：当直观达到 <strong>无可置疑的清晰度</strong>（如你无法否认 “正在思考” 这一行为的存在），即为真理。</li>\n<li><strong>主体间可验证性</strong>：不同主体对同一本质（如 “红”）的直观结果一致（类似数学家对 “圆” 的理解相同）。</li>\n</ul>\n<h4 id=\"3-马里翁的潜在批评\"><a class=\"anchor\" href=\"#3-马里翁的潜在批评\">#</a> 3. <strong>马里翁的潜在批评</strong></h4>\n<p>胡塞尔假设本质直观 <strong>依赖主体能力</strong>（自由变更需主体执行），而马里翁主张：</p>\n<ul>\n<li>某些现象（如神圣者的显现）<strong>抗拒自由变更</strong>（无法被任意想象修改），</li>\n<li>其本质恰恰在 <strong>突破主体框架</strong> 时自我给予。</li>\n</ul>\n<blockquote>\n<p>例：基督的复活事件不可 “想象变更”，它以 <strong>绝对饱和性</strong> 给予自身本质。</p>\n</blockquote>\n<hr />\n<h4 id=\"四-生活化示例理解愤怒的本质\"><a class=\"anchor\" href=\"#四-生活化示例理解愤怒的本质\">#</a> <strong>四、生活化示例：理解 “愤怒” 的本质</strong></h4>\n<h4 id=\"传统哲学\"><a class=\"anchor\" href=\"#传统哲学\">#</a> <strong>传统哲学</strong></h4>\n<ul>\n<li>经验主义：统计 100 人发怒时的生理数据（心跳加速、脸红）→ 得出概率性结论。</li>\n<li>理性主义：用概念推演 “愤怒是理性的丧失”。</li>\n</ul>\n<h4 id=\"胡塞尔现象学操作\"><a class=\"anchor\" href=\"#胡塞尔现象学操作\">#</a> <strong>胡塞尔现象学操作</strong></h4>\n<ol>\n<li><strong>选取典范体验</strong>：回忆一次真实愤怒（如被无故指责）。</li>\n<li><strong>自由想象变更</strong>：\n<ul>\n<li>变更对象（老板 / 朋友）、场合（办公室 / 家中）、强度（暴怒 / 隐忍）...</li>\n</ul>\n</li>\n<li><strong>发现不变本质</strong>：\n<ul>\n<li>愤怒的 <strong>核心</strong> = <strong>“对不公侵犯的抗拒感”</strong>（即使对象和形式变化，此内核不变）。</li>\n</ul>\n</li>\n<li><strong>获得明晰知识</strong>：\n<ul>\n<li>这不是统计结论，而是 <strong>直观到的愤怒本质本身</strong>。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h4 id=\"五-哲学史意义现象学的科学奠基\"><a class=\"anchor\" href=\"#五-哲学史意义现象学的科学奠基\">#</a> <strong>五、哲学史意义：现象学的科学奠基</strong></h4>\n<p>胡塞尔借此宣告：</p>\n<ol>\n<li><strong>哲学知识可能</strong>：通过本质直观突破 “意见” 的泥潭。</li>\n<li><strong>操作严格性</strong>：需扎根于被给予的体验，避免形而上学空谈。</li>\n<li><strong>对马里翁的启示</strong>：\n<ul>\n<li>胡塞尔的 <strong>“被给予性”</strong> 是起点，</li>\n<li>但马里翁将其推向极致：现象自我给予的 <strong>暴力性</strong> 可摧毁主体直观框架（如饱和现象）。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>这段文本是 <strong>现象学方法论的浓缩宣言</strong> —— 它要求哲学家像科学家观察实验般 <strong>“直观” 意识的本质结构</strong>，而这正是《还原与给予》中马里翁既继承又爆破的基点。</p>\n</blockquote>\n<h3 id=\"q-8\"><a class=\"anchor\" href=\"#q-8\">#</a> Q:</h3>\n<p>怎么理解：“胡塞尔宣布了：对原初的感性感念，即对直观和感知这两个概念的不可或缺的扩展，这种扩展使得我们有权探讨范畴直观，特别是有权谈论普遍直观”</p>\n<p>A:<br />\n 胡塞尔在《逻辑研究》中提出的 <strong>“范畴直观”</strong>（categorial intuition）概念，是对传统认识论的根本性革命。这句话宣告了现象学对 “直观” 能力的 <strong>双重扩展</strong>，彻底打破了经验主义对直观的狭隘限定。以下是逐层解析：</p>\n<hr />\n<h4 id=\"一-背景传统直观理论的枷锁\"><a class=\"anchor\" href=\"#一-背景传统直观理论的枷锁\">#</a> <strong>一、背景：传统直观理论的枷锁</strong></h4>\n<h4 id=\"传统哲学经验主义康德的教条\"><a class=\"anchor\" href=\"#传统哲学经验主义康德的教条\">#</a> 传统哲学（经验主义 + 康德）的教条：</h4>\n<ol>\n<li><strong>直观仅限感性</strong>：\n<ul>\n<li>直观 = 感官直接接收的内容（颜色、声音、触感等）。</li>\n</ul>\n</li>\n<li><strong>范畴仅属理性</strong>：\n<ul>\n<li>抽象概念（如 “存在”“统一性”“因果”）需通过 <strong>知性范畴加工</strong> 感性材料获得，<strong>无法被直观</strong>。</li>\n</ul>\n<blockquote>\n<p>康德：范畴是主体的先天认知框架，现象需经其 “塑形” 才能被认识。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h4 id=\"二-胡塞尔的突破直观概念的双重扩展\"><a class=\"anchor\" href=\"#二-胡塞尔的突破直观概念的双重扩展\">#</a> <strong>二、胡塞尔的突破：直观概念的 “双重扩展”</strong></h4>\n<p>胡塞尔的核心主张：</p>\n<blockquote>\n<p><strong>直观不仅限于感性！我们还能直接 “看见” 范畴与普遍本质！</strong></p>\n</blockquote>\n<h4 id=\"扩展1从感性直观到范畴直观\"><a class=\"anchor\" href=\"#扩展1从感性直观到范畴直观\">#</a> 扩展 1：<strong>从 “感性直观” 到 “范畴直观”</strong></h4>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>对象</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>感性直观</strong></td>\n<td>具体事物的属性</td>\n<td>看见苹果的红色（感觉材料）</td>\n</tr>\n<tr>\n<td><strong>范畴直观</strong> ⭐</td>\n<td><strong>范畴关系与形式</strong></td>\n<td>直接把握 “苹果 <strong>是</strong> 红的”（“是” 的关系）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>关键案例</strong>（《逻辑研究》VI）：<br />\n当你看见 <strong>“一张白纸”</strong>：\n<ul>\n<li>感性直观：白色、矩形、光滑感。</li>\n<li><strong>范畴直观</strong>：\n<ul>\n<li>“白”<strong> 与</strong> “纸” 的 <strong>联结</strong>（“白 - 纸” 而非 “白 + 纸”），</li>\n<li>纸 <strong>作为主体</strong> 承载白色（<strong>主谓结构</strong>），</li>\n<li>整张纸 <strong>是</strong> 白的（<strong>存在判断</strong>）。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 <strong>革命性</strong>：范畴形式（如 “是”“与”“或”）<strong>本身被给予</strong>，而非主体强加！</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"扩展2从个别直观到普遍直观\"><a class=\"anchor\" href=\"#扩展2从个别直观到普遍直观\">#</a> 扩展 2：<strong>从 “个别直观” 到 “普遍直观”</strong></h4>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>对象</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>个别直观</strong></td>\n<td>单个事物</td>\n<td>看见这只苹果</td>\n</tr>\n<tr>\n<td><strong>普遍直观</strong> ⭐</td>\n<td><strong>本质或共相</strong></td>\n<td>直观 “苹果性”（所有苹果的普遍本质）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>操作方式</strong>：<strong>自由想象变更</strong>（见前文分析）\n<blockquote>\n<p>例：通过想象不同苹果（青 / 红、大 / 小），发现不变内核 ——<strong>“苹果性”</strong>（多汁果肉、核心种子等）。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"三-为什么不可或缺现象学作为严格科学的根基\"><a class=\"anchor\" href=\"#三-为什么不可或缺现象学作为严格科学的根基\">#</a> <strong>三、为什么 “不可或缺”？—— 现象学作为严格科学的根基</strong></h4>\n<p>胡塞尔扩展直观，是为了解决哲学的核心危机：</p>\n<ol>\n<li><strong>拯救逻辑与数学的客观性</strong>：\n<ul>\n<li>若 “1+1=2” 或 “A=A” 无法被直观，则它们只是主观约定。</li>\n<li><strong>范畴直观</strong>使逻辑律（如矛盾律）成为 <strong>自明的被给予者</strong>。</li>\n</ul>\n</li>\n<li><strong>为本质科学奠基</strong>：\n<ul>\n<li>数学、几何学、伦理学的研究对象（数、正义、空间）需通过 <strong>普遍直观</strong> 把握其本质。</li>\n</ul>\n</li>\n<li><strong>打破主客二元对立</strong>：\n<ul>\n<li>范畴不再仅是 “主观形式”，而是 <strong>现象自身显现的关系结构</strong>。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>马里翁在《还原与给予》中的继承</strong>：<br />\n胡塞尔证明直观可超越感性，为马里翁的 <strong>“饱和现象”</strong>（如神性显现）奠定基础 —— 若范畴可被直观，更高阶的给予为何不能？</p>\n</blockquote>\n<hr />\n<h4 id=\"四-生活化示例理解友谊\"><a class=\"anchor\" href=\"#四-生活化示例理解友谊\">#</a> <strong>四、生活化示例：理解 “友谊”</strong></h4>\n<ul>\n<li><strong>经验主义</strong>：<br />\n统计 100 对朋友的行为（吃饭、聊天频率）→ 归纳 “友谊” 特征（或然性结论）。</li>\n<li><strong>胡塞尔现象学</strong>：\n<ol>\n<li><strong>典范实例</strong>：反思你与挚友的一次深谈。</li>\n<li><strong>范畴直观</strong>：把握 “信任 <strong>与</strong> 理解”“他 <strong>为</strong> 你付出” 等关系形式。</li>\n<li><strong>普遍直观</strong>：\n<ul>\n<li>想象变更朋友身份（同学 / 同事）、事件（借钱 / 陪伴）...</li>\n<li>发现不变本质：<strong>“互为主体性的精神共在”</strong>。<br />\n→ 获得对 “友谊” 的 <strong>本质性明见</strong>（必然知识）。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<hr />\n<h4 id=\"五-哲学史意义从康德到胡塞尔的哥白尼反转\"><a class=\"anchor\" href=\"#五-哲学史意义从康德到胡塞尔的哥白尼反转\">#</a> <strong>五、哲学史意义：从康德到胡塞尔的哥白尼反转</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>康德</strong></th>\n<th><strong>胡塞尔</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>范畴是主体加工感性的工具</td>\n<td><strong>范畴是现象自身显现的形式</strong></td>\n</tr>\n<tr>\n<td>普遍性来自主体先天能力</td>\n<td><strong>普遍性被直观在现象中</strong></td>\n</tr>\n<tr>\n<td>现象符合主体</td>\n<td><strong>主体忠于现象的自我给予</strong></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>胡塞尔的宣言</strong>：<br />\n<strong>现象自身包含范畴结构！</strong> 主体只需 “看”，而非 “构造”。\n<blockquote>\n<p>这为马里翁的 <strong>“现象主权”</strong>（现象主动给予意义）埋下伏笔。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h4 id=\"结语直观的解放与现象学的彻底化\"><a class=\"anchor\" href=\"#结语直观的解放与现象学的彻底化\">#</a> <strong>结语：直观的解放与现象学的彻底化</strong></h4>\n<p>胡塞尔对直观的扩展，使哲学真正可能 <strong>“回到事物本身”</strong>：</p>\n<ol>\n<li><strong>砸碎枷锁</strong>：直观不再被感官禁锢，可通达关系与本质。</li>\n<li><strong>马里翁的激进推进</strong>：\n<ul>\n<li>若直观能接纳范畴与普遍者，</li>\n<li>为何不能接纳 <strong>彻底超越主体框架的饱和现象</strong>（如神的绝对他性）？</li>\n</ul>\n<blockquote>\n<p>《还原与给予》的核心使命：将直观扩展进行到底，直至现象 <strong>无条件自我给予</strong> 的深渊。<br />\nh</p>\n</blockquote>\n</li>\n</ol>\n",
            "tags": [
                "影视书籍",
                "书",
                "读书笔记"
            ]
        },
        {
            "id": "http://amentiraz.github.io/GEARS/",
            "url": "http://amentiraz.github.io/GEARS/",
            "title": "GEARS",
            "date_published": "2025-06-30T02:07:32.000Z",
            "content_html": "<p>Predicting transcriptional outcomes of novel multigene perturbations with GEARS.</p>\n<span id=\"more\"></span>\n<p>实验目的：Understanding cellular responses to genetic perturbation is central to numerous biomedical application, from identifying genetic interations involved in cancer to developing methods for regenerative medicine.</p>\n<p>挑战： The combinatorial explosion in the number of possible multigene perturbations severely limits experimental interrogation.</p>\n<p>GEARS: graph-enhanced gene activation and repression simulator. A method that integrates deep learning with a knowledge graph of gene-gene relationships to predict transcriptional responses to both single and multigene perturbations using single-cell RNA-sequencing data from perturbational screens.</p>\n<p>这段话不是很理解：The screens were run using the Perturb-seq assay, which combines a pooled screen with a single-cell RNA-sequencing readout of the entire transcriptome for each cell. 什么是 Perturb-seq assay，什么又是 pooled screen</p>\n<p>“pooled screen” 指的是把多个扰动一起进行实验，而不是一个一个单独做，节省时间和资源。</p>\n",
            "tags": [
                "论文",
                "生物",
                "学习笔记类",
                "算法"
            ]
        },
        {
            "id": "http://amentiraz.github.io/life/%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/",
            "url": "http://amentiraz.github.io/life/%E9%87%8D%E5%BA%86%E4%B9%8B%E6%97%85/",
            "title": "重庆之旅",
            "date_published": "2025-06-08T14:53:34.000Z",
            "content_html": "<p>重庆旅游记录</p>\n<span id=\"more\"></span>\n<p>快毕业了，正好没什么事干，闪现重庆。</p>\n<p>西安到重庆一共是 5 个多小时的高铁，高铁上看了会儿书，又昏昏欲睡，很快也到了重庆。</p>\n<p>我是暂住在我姐家，很多事情也不用操心，本来打算自己挑战一下旅游的，结果这方面都给我安排好了，少了很多麻烦。后面这个暑假还会去旅游，下次就自己搞定，实实在在的锻炼一下。</p>\n<p>晚上是去吃的烤串。和西安的不一样重庆的烤串就是点菜，西安则是店家烤好了分。烤串肉质很不错，很有嚼劲。和西安相似的是这里的烤串也是放在锡纸垫着的烤炉上，吃着也一直是热乎的。除了烤串还尝了一下烤串店卖的冰汤圆，还有小朋友很喜欢吃的一个类似于芝士焗蟹肉的小吃，也是非常不错，芝士和蟹肉的组合配合的很好，口感也爽口，小孩吃着也轻松。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin1.jpg\" alt=\"\" /><br />\n吃完烤串，我和我姐又去了重庆市规划展览馆上面去看了夜景，遗憾的是我们刚上去江对面的灯就熄了，没看到最漂亮的夜景。眺望江对岸有一种回到了上海外滩的感觉，各种各样的高楼大厦，游船在江上行驶，仔细一看楼上利用 LED 灯显示出各种各样的文字，景色也是十分不错了。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin2.jpg\" alt=\"\" /><br />\n第二天，早上去吃了重庆小面。说是重庆小面，我姐告诉我一般正宗的重庆小面都不叫重庆小面，我想也是，就像四川川菜的店铺不可能说店名就叫川菜，但奇怪的是陕西的陕菜确实标榜自己是陕菜（乐）。我们吃的那家是叫什么凳凳面，吃饭的方式也很奇特，一个大椅子用来放吃的，人坐在小凳子上吃。我点了一份豌杂面，辣度应该是标准辣。本来以为自己吃不了这种辣，结果发现还好，确实是比平时的辣度更高，但是这个辣的很有滋味，看得出来调料很有一手，观察面的话发现汤居然是黑的，这是说明它辣的发黑吗？我在西安吃过几次重庆小面，每一次都给我劝退得不行，要不然辣的遭不住，要不然面吃着一股方便面的味道，今天尝了下正宗的确实不一样。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin4.jpg\" alt=\"\" /></p>\n<p>吃了饭我们便去了山城步道，我原本以为是类似山路那样，结果路上全是商贩。吃的喝的，纪念品，走在路上不是感觉到原滋原味的重庆山城，而是重庆热情似火的商业化氛围。我和我姐吐槽，如果我评价西安是商业化太严重了，那重庆不如说只有商业化。当然也有十分不错的地方，由于山城步道离江很近所以能看到江景。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin6.jpg\" alt=\"\" /><br />\n山城步道里面还有很多小巷子，但全是商业化十分彻底，比较稀奇的甚至还看到了有人在用塔罗牌给人占卜。穿梭在各个商店之间让我感到有些无聊，但奇怪的是其它年轻的游客很有热情，巷子里塞满了各种适合拍照打卡的要素，用年轻人的话来说就是很潮（虽然我也是年轻人）。走在这条路上，感觉又很熟悉，我不仅想起当时在日本去参观清水寺还是浅水寺的时候，也是一段上坡路上路旁摆满了各种商铺。当我走进卖纪念品的店时，我竟然发现了类似于日本印账的东西，他们称呼为手账，你可以在上面盖章打卡。我一寻思这不就是日本的东西吗？当然也不大可能是日本抄袭的中国的，毕竟人家全国各地都有。我记得我在日本旅游的时候便对这种打卡形式直呼精妙，既满足了人的收藏癖，也可以时候拿来炫耀和纪念，美中不足的是我看重庆这种模型并不像日本一样现场手写，而是采用盖章的形式。这个时候我便意识到重庆的旅游景点模式，很有设计感。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin7.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin8.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin9.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin10.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin11.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin12.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin13.jpg\" alt=\"\" /></p>\n<p>话虽如此，山城步道还是有很多值得参观的地方，特别是快到尽头时的那个平台，一进去有一种进入了世外桃源的感觉，一颗巨大的树矗立在高处不仅让人浮想联翩。值得一提是，快到尽头时能看到很多猫，这些猫完全不怕人，慵懒的睡在道路旁 “任人宰割”，很少有见到完全不怕人的猫，路旁还有很多蓝色的花，没人去采摘，自然生长，重庆人的素质还是相当的高。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin14.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin15.jpg\" alt=\"\" /></p>\n<p>这里有个图书馆，我们坐在这里休息了很久，虽然要 5 块钱的门票费，但环境清幽，书籍也很多，体验还是相当不错。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin17.jpg\" alt=\"\" /></p>\n<p>吃完饭后我们去了解放碑，打算中午吃点小吃。又试了一下小汤圆，味道确实不错，有一种把冰粉换成汤圆的感觉，但是总归来说，感觉口味对我来说还是淡了。然后吃了一下这里的鬼包子，说是鬼包子其实就是小笼包，这个名字也是让人望而生畏，但包子尝起来也是很不错，肉馅是颗粒样的，可惜不能混装，只能一笼一笼的买。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin18.jpg\" alt=\"\" /></p>\n<p>我也去试着喝了一下茶颜悦色，说实话完全没有听说过这个品牌，但似乎这个又挺出名的，买的人也很多。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin19.jpg\" alt=\"\" /><br />\n尝了一下最推荐的那一款，怎么说呢，感觉有点太淡了，上面也就是普通的奶油，下面的奶茶和白开水最大的区别就是你知道自己喝的不是白开水，淡淡的味道，说不上难喝，但很难理解为什么受人追捧。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin21.jpg\" alt=\"\" /><br />\n我们下午去了三峡博物馆，人非常非常多，但可能是我的文化水平不高，看着那些文化的介绍，看看重庆的历史，从猴子开始讲起一直讲到各个国家来这里建领事馆，又讲到革命又是工业发展，场馆修着波澜壮阔，历史遗物丰富多彩，但可能是我学识短浅再加上确实没怎么认真转，怎么给人一种没什么文化底蕴的感觉呢？我不好说。但说实话，如果没什么文化底蕴，很多事情能解释的通了，其实也能下判断了，重庆的旅游业发达，是因为它人造的美很不错。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin22.jpg\" alt=\"\" /><br />\n然后是鹅岭二厂。这个名字就很奇怪，为什么一个厂都能算一个景点。来了发现，这边拍照打卡的地方很多，年轻的女性在这里拍摄照片歌颂自己的青春，我和我姐在这 city walk 穷游走路的不想走。我也是老了。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin26.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin27.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin25.jpg\" alt=\"\" /></p>\n<p>重庆和这些网红文化是双向奔赴的，互联网造就了重庆，重庆也迎合互联网，我想这也是为什么重庆文旅爆火的原因。しかし......</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin28.jpg\" alt=\"\" /><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin29.jpg\" alt=\"\" /></p>\n<p>终于来到了最期待也最害怕的重庆火锅，点了个微辣，就这样给我吓得都不行。之前在网上看到过别人吃重庆火锅，听说鸭肠是必点的，这次也特地点了个鸭肠，店员推荐了他们的血旺，这个也试了一下。刚开始吃的时候并没有感觉到辣，重庆的辣更多的是香辣，并不是像其他地方模仿重庆火锅一样为了辣而辣，血旺十分好吃，在我的记忆当中算是最好吃的一次了，咬下去确实是入口即化。鸭肠也很不错，特意点的脑花原本以为会很腻吃起来也很不错。但是吃到后面辣味便涌上来了，奇怪的是一般辣的受不了是感觉刺痛刺痛的那种，但这次吃却没有那种感觉，它的辣似乎被其它材料 “包裹” 住了，虽说后面没有吃完，但确实重庆火锅十分不错。</p>\n<h1 id=\"day-2\"><a class=\"anchor\" href=\"#day-2\">#</a> Day 2</h1>\n<p>早上尝了一下这边的抄手，抄手明显就要比面辣的多，吃完后我便前往龙门浩了。路上的出租车司机很热情，听我的口音后问我是不是本地人，我说我是成都的他便说川渝一家亲，后面又和我介绍重庆的历史，看得出来他对重庆很有自豪感。我说到重庆这种隔江的建筑有点像上海的外滩，他说他去过，感觉不如重庆，又说自己去过伦敦，也就那样。出租车师傅突然沉默了一下说他年轻的时候赚了很多钱，我还没恭喜他他又接着说，但是赌博，追求刺激又把钱都还回去了。我不知道该说什么，他又很激动的说，小兄弟，毒和毒千万不能碰，千万不能学我，我又能说什么呢？我说一定的。随后我们也很默契的把话题岔开，他听说我是大学生，又说起自己的儿子是空军，十分的优秀，我也为他高兴。快下车时，他说最近考勤严格，希望我给他打个好评。下车后我也是特意打开了 APP 给出了好评，也希望他生活顺利吧。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin30.jpg\" alt=\"\" /><br />\n龙门浩说实话没什么转的，也就是可能是我来的比较早的原因，商家也没有开门。说实话，我都不太明白龙门浩怎么也算个景点，倒是能看到许多艺人来这里打卡的照片，摆在路旁作为宣传。倒是龙门浩与一座桥是连在一起的，乘坐电梯可以到桥上。差不多逛完龙门浩后，我便徒步过桥前往朝天门。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin32.jpg\" alt=\"\" /><br />\n我习惯性的去旅游一个城市便去当地走走，于是我便徒步从龙门浩走到了朝天门。其实我倒觉得重庆的路边便魅力十足，错落有致的房屋，从上而下俯视便像是在攀爬山峰，这种难一见的城市景观才是重庆的一大特色。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin34.jpg\" alt=\"\" /><br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin33.jpg\" alt=\"\" /><br />\n抵达朝天门便能看到许多旅行团的，或者是网红在拍照，其实说白了就是一个平台，隔江望过去便是城市规划展览馆，临江看风景时意外还看到许多工人在下面借着建筑遮挡阳光在午睡。</p>\n<p>我去了解放碑吃了午饭，特意尝了一下酸辣粉。这玩意太辣了，味道还行但是太辣了，吃了一半便边擤鼻涕边喝水，抬头看看周围都感觉恍如隔世，头皮发麻的让人飘飘欲仙。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin41.jpg\" alt=\"\" /><br />\n下午也没看什么，去了洪崖洞周围也没有真的去洪崖洞，又点了一杯茶颜悦色，那种意料之中的淡味让人感到安心。没点茶百道但在茶百道睡了一个小时。稍作停顿便前往 Live house 去看演出了，这个部分放到另外的文章叙述。</p>\n<h1 id=\"day-3\"><a class=\"anchor\" href=\"#day-3\">#</a> Day 3</h1>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin31.jpg\" alt=\"\" /><br />\n早上去了城市规划展览馆。这个地方感觉是政府用来在正式场合对外宣传的，虽然也有大学生在逛，但能看到很多白衬衫的公务人员，也能看到外国人在听讲解员讲解。这个地方完整且正面的展示了重庆市的历史，文化，特色。逛完后我对重庆的印象好了不少。如果不是逛这个我离开了重庆也不知道大足石刻、巫峡等等也重庆的，咋不多宣传宣传这些，尽搞些网红文化。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin36.jpg\" alt=\"\" /><br />\n重庆美术馆。一眼和上海的那个美术馆差不多，外观就差不多。进去参观，大失所望。wdnmd，头一次听说美术馆的画明码标价，支持微信支付。而且这些国画说白了就是重庆美术馆的内部人员画的，委婉点来说就最开头的副馆长那幅画能看得出来有点水平，当然副馆长的画也不敢随便拍卖，其它的画我能看的出来还是可以，但是一看价格我就不太想看画了。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin37.jpg\" alt=\"\" /><br />\n二楼的画是一个叫张杰的个人展，虽然没有完全的展示，但是水平相当不错，人物的眼神，表情相当讲究，栩栩如生，看的时候我便觉得为震撼。很好的把这种普通中国人的生活表现了出来，而且能看出有自己的思想在里面，特别是《城市梦》那两张，真是非常厉害。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/chongqin40.jpg\" alt=\"\" /><br />\n下面这张也十分不错，不知道是透视的原理还是什么，整个城市像是在水面上一样，很有味道。</p>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>重庆之旅也就告一段落了</p>\n",
            "tags": [
                "生活",
                "旅游",
                "生活",
                "重庆",
                "旅游"
            ]
        },
        {
            "id": "http://amentiraz.github.io/life/MeetingJazz2025-06-01/",
            "url": "http://amentiraz.github.io/life/MeetingJazz2025-06-01/",
            "title": "MeetingJazz2025-06-01",
            "date_published": "2025-06-01T16:44:45.000Z",
            "content_html": "<p>在爵士酒吧过六一儿童节</p>\n<span id=\"more\"></span>\n<p>先说酒，点的 “大都会”，很清爽的味道，但是没什么酒味，有一种喝西柚水的味道，但那种实打实的涩味告诉我喝的是酒。酒的度数也不是很高，也没有什么变化，干干脆脆，感觉女性会更喜欢这类酒。综合打个 5 分，虽说还不错，但以后也不会点了。</p>\n<p>再说爵士现场，今天是四重奏，后面加入了人声，但时间比较赶听到 11：40 差不多我们就走了。吉他手有两个，一个年轻，一个老成。年轻的乐手的演奏很有热情，编排的很密但缺少了一些细腻的味道，老成的那位就十分厉害，无论是律动还是动态都处理的非常好，特别是在节奏舒缓的曲目更是厉害，揉弦恰到好处，即兴也很有味道。鼓手技巧很厉害，但我同行的同学对鼓手意见比较大，认为他干扰了自己听贝斯，但有一说一贝斯比较羞涩，虽说很有实力，但存在感却很低。</p>\n<p>演奏的前半场比较吵闹，有来玩的，后半场来玩的人都走了，剩下的人看得出来对爵士都很有热情，前半场不敢欢呼的在后半场补了回来，难得能看到这么浓厚的音乐氛围。</p>\n<p>看得出来这场演出，老成的那位吉他手的水平是远超其它乐手的，综合评价来说这次体验能给到 8 分，因为吉他演出确实不错。</p>\n",
            "tags": [
                "生活",
                "演奏会",
                "生活",
                "音乐"
            ]
        },
        {
            "id": "http://amentiraz.github.io/note/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E6%95%B0%E6%8D%AE/",
            "url": "http://amentiraz.github.io/note/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E6%95%B0%E6%8D%AE/",
            "title": "系统学习如何处理生物信息学数据",
            "date_published": "2025-05-20T07:14:29.000Z",
            "content_html": "<p>对于这个<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc2MtYmVzdC1wcmFjdGljZXMub3JnL3ByZWFtYmxlLmh0bWw=\">网页</span>下的知识的系统学习。</p>\n<span id=\"more\"></span>\n<h3 id=\"single-cell-rna-sequencing\"><a class=\"anchor\" href=\"#single-cell-rna-sequencing\">#</a> Single-cell RNA sequencing</h3>\n<p>Sequencing of RNA can be mainly conducted in two ways: Either by sequencing the mixed RNA from the source of interest across cells (bulk sequencing) or by sequencing the transcriptomes of the cells individually (single-cell sequencing).</p>\n<h3 id=\"transcript-quantification\"><a class=\"anchor\" href=\"#transcript-quantification\">#</a> Transcript quantification</h3>\n<p>Transcript quantification is the process of converting the raw data into an table of estimated transcript counts per gene per sample (for bulk-sequencing) or per cell (for single-cell sequencing).</p>\n",
            "tags": [
                "代码",
                "python",
                "学习笔记",
                "python"
            ]
        },
        {
            "id": "http://amentiraz.github.io/life/%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%AD%94%E7%9A%84%E5%90%AB%E4%B9%89/",
            "url": "http://amentiraz.github.io/life/%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%AD%94%E7%9A%84%E5%90%AB%E4%B9%89/",
            "title": "关于面孔的含义",
            "date_published": "2025-05-20T07:04:50.000Z",
            "content_html": "<p>对 DeepSeek 询问了关于伦理学中对于列维纳斯在面孔和外在性等方面的看法。</p>\n<span id=\"more\"></span>\n<h1 id=\"q-我想知道什么是完全现象他的法语是phenomene-de-plein-droit\"><a class=\"anchor\" href=\"#q-我想知道什么是完全现象他的法语是phenomene-de-plein-droit\">#</a> Q: 我想知道什么是完全现象，他的法语是 phenomene de plein droit</h1>\n<p>A:<br />\n 您提出的 “phénomène de plein droit”（完全现象 / 自主现象）是一个极具现象学深度的概念，需要从三个维度展开解析：</p>\n<hr />\n<h3 id=\"一-术语溯源与法语语境\"><a class=\"anchor\" href=\"#一-术语溯源与法语语境\">#</a> 一、术语溯源与法语语境</h3>\n<ol>\n<li>\n<p><strong>词源暴力</strong><br />\n “plein droit” 直译为 “充分权利”，在法律语境中指 “无需附加条件的法定资格”。移植到现象学中，<strong>萨特在《存在与虚无》<strong>中使用该词强调现象的</strong>自我授权性</strong> —— 现象不依赖他者证明其存在，其显现即是存在的确证。</p>\n</li>\n<li>\n<p><strong>现象学的权利革命</strong><br />\n与传统哲学将现象视为 “表象”（apparence）不同，<strong>梅洛 - 庞蒂在《知觉现象学》<strong>中指出：“现象不是通往本质的跳板，它就是本质栖居之地”。“完全现象” 颠覆了康德 “物自体 - 现象” 的二分，主张现象自身具有</strong>存在论上的完满性</strong>。</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"二-完全现象的四个特征\"><a class=\"anchor\" href=\"#二-完全现象的四个特征\">#</a> 二、完全现象的四个特征</h3>\n<ol>\n<li>\n<p><strong>非剩余性</strong>（Non-résiduel）<br />\n现象不隐藏任何 “背后的真理”，如 ** 列维纳斯在《别样于存在》** 所言：“他者的面容（visage）作为 phénomène de plein droit，不指向任何表象背后的灵魂，面容即是伦理命令本身”。</p>\n</li>\n<li>\n<p><strong>场域肉身性</strong>（Chair du monde）<br />\n梅洛 - 庞蒂通过 “肉身”（chair）概念说明：完全现象是<strong>身体 - 世界交织的拓扑学节点</strong>。例如疼痛不是 “神经系统信号”，而是身体空间向世界敞开的原初现象。</p>\n</li>\n<li>\n<p><strong>反构造性</strong>（Anti-constitution）<br />\n区别于胡塞尔 “意识构造现象” 的传统，** 马里翁在《既给予》** 中提出：“完全现象具有饱和性（saturation），它反向淹没意向性，迫使意识放弃构造权”。</p>\n</li>\n<li>\n<p><strong>伦理先验性</strong>（Primauté éthique）<br />\n在列维纳斯体系中，他者作为完全现象具有<strong>存在论暴力</strong>：不是 “我思故他在”，而是 “他者凝视迫使我存在”。这种伦理关系优先于认识论关系。</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"三-思想实验咖啡馆里的完全现象\"><a class=\"anchor\" href=\"#三-思想实验咖啡馆里的完全现象\">#</a> 三、思想实验：咖啡馆里的完全现象</h3>\n<p>假设您坐在巴黎花神咖啡馆，此时：</p>\n<ul>\n<li><strong>普通现象</strong>：侍应生的制服、咖啡杯的质感、邻座的笑声 —— 这些可被意向性捕获的对象</li>\n<li><strong>完全现象</strong>：\n<ol>\n<li>突然与陌生人的目光相遇，那种<strong>无法对象化的注视</strong>（列维纳斯）</li>\n<li>手中咖啡杯在疲劳时呈现的<strong>重量感突变</strong>（梅洛 - 庞蒂的 “身体图示” 重组）</li>\n<li>听见母语脏话时的<strong>语词暴力穿透</strong>（马里翁的 “饱和现象”）</li>\n</ol>\n</li>\n</ul>\n<p>这些情境中，现象<strong>挣脱了意向性框架</strong>，不再是意识的操作对象，反而成为重塑主体性的力量 —— 这正是 “完全现象” 的存在论特权。</p>\n<hr />\n<h3 id=\"四-哲学史坐标\"><a class=\"anchor\" href=\"#四-哲学史坐标\">#</a> 四、哲学史坐标</h3>\n<table>\n<thead>\n<tr>\n<th>思想家</th>\n<th>对 “完全现象” 的推进</th>\n<th>关键文本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>胡塞尔</td>\n<td>现象作为意向相关项</td>\n<td>《观念 I》</td>\n</tr>\n<tr>\n<td>海德格尔</td>\n<td>现象作为存在开显</td>\n<td>《存在与时间》</td>\n</tr>\n<tr>\n<td>列维纳斯</td>\n<td>现象作为伦理事件</td>\n<td>《总体与无限》</td>\n</tr>\n<tr>\n<td>马里翁</td>\n<td>现象作为给予性过剩</td>\n<td>《既给予》</td>\n</tr>\n</tbody>\n</table>\n<p>这个概念的演变史，折射出现象学从 “意识哲学” 到 “他者哲学” 再到 “给予性哲学” 的三次范式革命。理解 “phénomène de plein droit”，实质是把握现象学最激进的宣言：<strong>现象不再是哲学的起点，而是哲学的暴君</strong>。</p>\n<h1 id=\"q他者的他性怎么理解\"><a class=\"anchor\" href=\"#q他者的他性怎么理解\">#</a> Q: 他者的他性怎么理解</h1>\n<p>A:<br />\n 理解 “他者的他性”（alterity/altérité）是 20 世纪现象学与伦理哲学的核心命题，尤其以列维纳斯（Emmanuel Levinas）的论述最为深刻。这一概念挑战了西方哲学传统的 “同一性” 霸权，指向一种无法被自我消化、占有或同化的绝对差异。我们可以从五个维度展开：</p>\n<hr />\n<h3 id=\"一-哲学史背景从同一性暴力到他性解放\"><a class=\"anchor\" href=\"#一-哲学史背景从同一性暴力到他性解放\">#</a> 一、<strong>哲学史背景：从同一性暴力到他性解放</strong></h3>\n<ul>\n<li>\n<p><strong>传统哲学的困境</strong><br />\n自巴门尼德提出 “存在是一” 以来，西方哲学长期陷入 “同一性暴力”（violence of the Same）：将万物还原为 “我思” 的对象（笛卡尔）、绝对精神的环节（黑格尔）或权力意志的产物（尼采）。他者在此框架中只是<strong>认知的猎物</strong>。</p>\n</li>\n<li>\n<p><strong>现象学的转折点</strong><br />\n胡塞尔在《笛卡尔式沉思》中提出 “主体间性”（intersubjectivity），试图通过 “移情” 理解他者，但仍将他者视为 “另一个自我”（alter ego）—— 这本质上仍是<strong>自我的殖民化投射</strong>。</p>\n</li>\n<li>\n<p><strong>列维纳斯的颠覆</strong><br />\n “他性” 概念彻底扭转了这一逻辑：<strong>不是 “我理解他者”，而是 “他者质询我”</strong>。他者的存在先于我的理解，其不可还原的异质性成为伦理关系的起点。</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"二-他性的核心内涵四项不可还原性\"><a class=\"anchor\" href=\"#二-他性的核心内涵四项不可还原性\">#</a> 二、<strong>他性的核心内涵：四项不可还原性</strong></h3>\n<ol>\n<li>\n<p><strong>面容的不可见性</strong>（Invisibilité du visage）<br />\n列维纳斯在《总体与无限》中指出：“他者的面容（visage）拒绝被视觉捕获”。当我们凝视面容时，看到的不是五官的组合，而是一种<strong>伦理命令</strong> ——“汝不可杀人”（Tu ne tueras point）。面容超越表象，成为他性的肉身化符号。</p>\n</li>\n<li>\n<p><strong>时间的断裂性</strong>（Rupture temporelle）<br />\n他者的时间与我的时间<strong>不同步</strong>。在对话中，他者话语的 “此刻” 永远迟于我的预期，这种时差构成<strong>绝对的意外性</strong>，如同德里达所言：“他者的到来总是‘太迟’却又‘尚未’”。</p>\n</li>\n<li>\n<p><strong>语言的不可翻译性</strong>（Intraduisibilité）<br />\n即使使用同一种语言，他者的言说始终携带<strong>剩余意义</strong>。列维纳斯用犹太教 “托拉”（Torah）的诠释传统作喻：经文的意义永远超出注释，他者的话语是 “能指的溢出”。</p>\n</li>\n<li>\n<p><strong>存在的非对称性</strong>（Asymétrie existentielle）<br />\n我对他者的责任<strong>无需对等回报</strong>。这种伦理关系像陀思妥耶夫斯基笔下的 “为所有人承担罪责”，或是《塔木德》中 “他人的血比你自己的血更红”—— 他者的优先性瓦解了黑格尔式的主奴辩证法。</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"三-他性的伦理转向从认识论到责任\"><a class=\"anchor\" href=\"#三-他性的伦理转向从认识论到责任\">#</a> 三、<strong>他性的伦理转向：从认识论到责任</strong></h3>\n<ul>\n<li>\n<p><strong>伦理作为第一哲学</strong><br />\n列维纳斯将伦理学置于本体论之前：“在他者面前，存在被质疑”。这不是道德规训，而是<strong>存在方式的根本转变</strong> —— 他者的他性迫使我从 “自我保存” 转向 “为他者存在”。</p>\n</li>\n<li>\n<p><strong>责任的无限性</strong><br />\n “我对他者的责任比所有责任更责任”（《别样于存在》）。这种责任不设边界：纳粹集中营的看守对犹太囚犯的责任，并不少于母亲对孩子的责任。他性在此成为<strong>存在之重</strong>的源头。</p>\n</li>\n<li>\n<p><strong>替代（Substitution）的激进性</strong><br />\n最极端的他性体验体现为 “为他者受难”：当他人饥饿时，“我的胃在痉挛”（列维纳斯）。这种身体性的共感超越同情，直指<strong>存在的替代结构</strong> ——“我” 的位置永远可能被他者占据。</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"四-现象学谱系中的他性之争\"><a class=\"anchor\" href=\"#四-现象学谱系中的他性之争\">#</a> 四、<strong>现象学谱系中的他性之争</strong></h3>\n<table>\n<thead>\n<tr>\n<th>思想家</th>\n<th>对他性的态度</th>\n<th>关键隐喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>胡塞尔</td>\n<td><strong>温和他性</strong>：他者是 “另一个我”</td>\n<td>镜子中的倒影</td>\n</tr>\n<tr>\n<td>海德格尔</td>\n<td><strong>共在他性</strong>：在 “共在”（Mitsein）中稀释差异</td>\n<td>森林中的小径</td>\n</tr>\n<tr>\n<td>萨特</td>\n<td><strong>对抗他性</strong>：“他人即地狱”</td>\n<td>窥视与被窥视</td>\n</tr>\n<tr>\n<td>列维纳斯</td>\n<td><strong>绝对他性</strong>：他者是 “无限”（Infini）</td>\n<td>沙漠中的面容</td>\n</tr>\n</tbody>\n</table>\n<p>此表显示：列维纳斯的他性理论是对存在主义传统的爆破，将现象学从 “存在的焦虑” 推向 “伦理的震颤”。</p>\n<hr />\n<h3 id=\"五-他性的当代启示\"><a class=\"anchor\" href=\"#五-他性的当代启示\">#</a> 五、<strong>他性的当代启示</strong></h3>\n<ul>\n<li>\n<p><strong>技术社会的他性危机</strong><br />\n社交媒体将他人简化为数据点，算法推荐制造 “同温层”—— 这本质是<strong>他性的数字化谋杀</strong>。列维纳斯的警示在此愈发尖锐：当面容被转化为头像，伦理责任如何可能？</p>\n</li>\n<li>\n<p><strong>生态哲学的新维度</strong><br />\n深层生态学将 “他性” 扩展到非人类存在：一座山的沉默、一只鲸鱼的歌声，是否也携带不可还原的他性？这挑战了人类中心主义的伦理框架。</p>\n</li>\n<li>\n<p><strong>跨文化对话的伦理基础</strong><br />\n在文化冲突中，他性要求我们放弃 “理解他人” 的傲慢，转而保持 “不可理解的敬畏”。正如犹太教对 “不可 pronunciar 的神名”（יהוה）的态度 —— 他者的神圣性正在于其不可言说。</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"结语他性作为存在的伤口\"><a class=\"anchor\" href=\"#结语他性作为存在的伤口\">#</a> 结语：他性作为存在的伤口</h3>\n<p>列维纳斯的他性不是哲学概念，而是<strong>存在的创伤体验</strong>。它像一道永不愈合的伤口，提醒我们：真正的伦理生活不是 “与他人和解”，而是 “为他者流血”。在这个意义上，他性的不可理解性，恰恰是我们逃离自我牢狱的唯一通道。</p>\n<h1 id=\"q为什么汝不可杀人\"><a class=\"anchor\" href=\"#q为什么汝不可杀人\">#</a> Q: 为什么汝不可杀人</h1>\n<p>A:</p>\n<p>从列维纳斯（Emmanuel Levinas）的现象学伦理学视角看，“汝不可杀人”（Tu ne tueras point）这一诫命并非简单的道德律令，而是一种 <strong>存在论层面的伦理原初事件</strong>。它根植于他者的 “面容”（visage）对主体的绝对召唤，是对西方哲学传统中 “自我中心主义” 的彻底颠覆。以下分步骤解析：</p>\n<hr />\n<h3 id=\"一-面容的现象学分析他者的暴力性在场\"><a class=\"anchor\" href=\"#一-面容的现象学分析他者的暴力性在场\">#</a> 一、<strong>面容的现象学分析：他者的暴力性在场</strong></h3>\n<ol>\n<li>\n<p><strong>面容的非对象性</strong><br />\n列维纳斯在《总体与无限》中指出，他者的面容是 <strong>“不能被主题化”</strong> 的。它不是一张可被观察、描述或概念化的 “脸”（如生物学意义上的五官组合），而是 <strong>一种直接刺入我存在的伦理命令</strong>。当我试图用视觉捕捉面容时，它立刻溢出我的认知框架 —— 面容的 <strong>脆弱性</strong>（皮肤下跳动的血管、瞳孔中反射的光）和 <strong>裸露性</strong>（毫无防御的敞开）构成了一种 <strong>无声的控诉</strong>，迫使我意识到：</p>\n<blockquote>\n<p>“在面容中，他者以绝对的被动性抵抗我的权力 —— 这种抵抗本身就是伦理的显现。”</p>\n</blockquote>\n</li>\n<li>\n<p><strong>面容的 “汝不可杀人”</strong><br />\n 面容的显现天然携带禁令。列维纳斯强调：</p>\n<blockquote>\n<p>“面容的第一句话就是‘汝不可杀人’。”<br />\n 这不是宗教或法律的规训，而是 <strong>存在论上的先验结构</strong>。在凝视面容的瞬间，杀戮的 <strong>可能性</strong> 与 <strong>不可能性</strong> 同时爆发：</p>\n</blockquote>\n<ul>\n<li><strong>可能性</strong>：我握有物理能力杀死他者（如掐住喉咙）；</li>\n<li><strong>不可能性</strong>：面容的伦理在场已预先消解了这种暴力的合法性，杀人成为 <strong>存在论的自杀</strong>（因我的主体性依赖于他者的召唤）。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"二-伦理的优先性存在被质疑\"><a class=\"anchor\" href=\"#二-伦理的优先性存在被质疑\">#</a> 二、<strong>伦理的优先性：存在被质疑</strong></h3>\n<ol>\n<li>\n<p><strong>伦理学先于本体论</strong><br />\n列维纳斯颠倒了传统哲学的秩序。对他而言，<strong>伦理关系</strong>（与他者的面对面）比 “存在之思” 更根本：</p>\n<blockquote>\n<p>“在他者面前，我的存在本身成为问题。”<br />\n 当面容显现时，自我中心的 “存在意志”（conatus essendi）—— 即海德格尔式的 “向死存在” 或斯宾诺莎的 “自我保存”—— 突然被 <strong>伦理的震颤</strong> 打断。我被迫从 “为自身存在” 转向 “为他者存在”。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>责任的无限性</strong><br />\n “汝不可杀人” 不是对具体行为的禁止，而是对 <strong>无限责任</strong> 的揭示：</p>\n<ul>\n<li>他者的脆弱性要求我承担 <strong>不对称的责任</strong>（即使他者伤害我，我也无权报复）；</li>\n<li>这种责任不设边界，如列维纳斯所言：\n<blockquote>\n<p>“我对他者的责任比所有责任更责任，比所有义务更义务。”（《别样于存在》）<br />\n例如：在集中营里，纳粹看守对犹太囚犯的责任，并不亚于母亲对孩子的责任 —— 因为责任源于他者的绝对他性，而非社会关系或情感纽带。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"三-杀戮的哲学本质对无限性的谋杀\"><a class=\"anchor\" href=\"#三-杀戮的哲学本质对无限性的谋杀\">#</a> 三、<strong>杀戮的哲学本质：对无限性的谋杀</strong></h3>\n<ol>\n<li>\n<p><strong>暴力如何可能？</strong><br />\n列维纳斯承认，现实中的杀戮屡见不鲜，但这恰恰证明了人性的 <strong>堕落</strong>。当人实施杀戮时，本质上是企图 <strong>将他者还原为同一</strong>（the Same）：</p>\n<ul>\n<li>通过暴力将他者变成 “尸体”（一个可操纵的物体）；</li>\n<li>抹除他者的 “言说”（dire）能力，使其沉默为 “被言说者”（dit）。<br />\n这种还原是 <strong>存在论层面的犯罪</strong>，因为它否定了他者作为 “无限”（Infini）的超越性。</li>\n</ul>\n</li>\n<li>\n<p><strong>自杀的逻辑悖论</strong><br />\n列维纳斯甚至指出：</p>\n<blockquote>\n<p>“杀人者所杀的，正是那个唯一能赋予他杀人‘意义’的存在。”<br />\n 因为只有当他者作为伦理命令的来源在场时，杀戮才具有 “恶” 的维度；一旦他者被杀，杀人者也失去了自身作为 <strong>伦理主体</strong> 的资格，沦为动物性的暴力存在。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h3 id=\"四-替代substitution为他者受难的极端伦理\"><a class=\"anchor\" href=\"#四-替代substitution为他者受难的极端伦理\">#</a> 四、<strong>替代（Substitution）：为他者受难的极端伦理</strong></h3>\n<p>列维纳斯在后期著作中提出更激进的 “替代” 概念：</p>\n<blockquote>\n<p>“我始终是他人的人质。”（《别样于存在》）</p>\n</blockquote>\n<ul>\n<li><strong>身体层面的替代</strong>：当他者饥饿时，“我的胃在痉挛”；当他者受苦时，“我的皮肤在灼烧”。这种感受不是同情，而是 <strong>存在论上的替代结构</strong> —— 我的身体成为他者痛苦的容器。</li>\n<li><strong>责任的创伤性</strong>：替代不是自愿的选择，而是一种 <strong>被动的承受</strong>。正如约伯无缘无故受难，伦理责任也是无理由的强加。这种 “创伤” 恰恰证明了责任的 <strong>神圣性</strong>。</li>\n</ul>\n<hr />\n<h3 id=\"五-对传统哲学的爆破\"><a class=\"anchor\" href=\"#五-对传统哲学的爆破\">#</a> 五、<strong>对传统哲学的爆破</strong></h3>\n<p>列维纳斯的 “汝不可杀人” 彻底挑战了西方哲学的根基：</p>\n<ol>\n<li><strong>对抗黑格尔</strong>：否定 “主奴辩证法” 中的承认斗争，强调责任先于自由。</li>\n<li><strong>超越海德格尔</strong>：拒绝 “共在”（Mitsein）的温情，坚持他者的不可消化性。</li>\n<li><strong>批判康德</strong>：义务不再来自理性自律，而是他者面容的强制命令。</li>\n</ol>\n<hr />\n<h3 id=\"结语作为存在之伤的伦理\"><a class=\"anchor\" href=\"#结语作为存在之伤的伦理\">#</a> 结语：作为存在之伤的伦理</h3>\n<p>对列维纳斯而言，“汝不可杀人” 不是道德说教，而是 <strong>存在的伤口</strong>。它揭示了一个残酷的真相：</p>\n<blockquote>\n<p><strong>人类的高贵不在于征服他者，而在于为他者流血。</strong><br />\n当面容刺入我的世界时，我不再是自足的主体，而是沦为 <strong>他者的人质</strong> —— 这种伦理的 “被动性”，恰恰是人性最后的避难所。</p>\n</blockquote>\n<h1 id=\"q-什么是外在性\"><a class=\"anchor\" href=\"#q-什么是外在性\">#</a> Q: 什么是外在性</h1>\n<p>A:<br />\n<strong> 外在性（Exteriority）在列维纳斯哲学中的核心阐释</strong></p>\n<p>在列维纳斯（Emmanuel Levinas）的现象学伦理学中，<strong>外在性</strong>（Exteriorité/Exteriority）是一个颠覆传统哲学的核心概念，指向他者（the Other）不可被自我（the Self）同化、占有或还原的绝对异质性。它挑战了西方哲学中 “同一性”（the Same）的霸权，强调他者始终外在于自我的认知与权力体系，构成伦理责任的根源。以下从多个维度展开分析：</p>\n<hr />\n<h3 id=\"一-哲学史背景对同一性的批判\"><a class=\"anchor\" href=\"#一-哲学史背景对同一性的批判\">#</a> 一、<strong>哲学史背景：对 “同一性” 的批判</strong></h3>\n<ol>\n<li>\n<p><strong>传统哲学的困境</strong><br />\n自柏拉图至黑格尔，西方哲学倾向于将一切存在纳入 “同一性” 的框架，通过理性将差异消解为总体（Totality）。他者被简化为自我的镜像（如黑格尔的 “他者即自我的否定”），或知识的对象（如胡塞尔的 “移情” 理论）。</p>\n<ul>\n<li><strong>列维纳斯的突破</strong>：外在性彻底否定这种 “同一性暴力”，主张他者的存在先于且外在于自我的理解，其异质性不可被概念化或总体化。</li>\n</ul>\n</li>\n<li>\n<p><strong>与存在主义的区别</strong><br />\n萨特的 “他人即地狱” 仍将他者视为威胁自我自由的对抗性存在，而列维纳斯的外在性强调他者的<strong>伦理优先性</strong> —— 他者不是威胁，而是对自我提出无条件责任的召唤。</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"二-外在性的核心特征\"><a class=\"anchor\" href=\"#二-外在性的核心特征\">#</a> 二、<strong>外在性的核心特征</strong></h3>\n<ol>\n<li>\n<p><strong>不可还原的异质性（Irreducible Alterity）</strong><br />\n他者不能被纳入自我的意识结构或语言体系。例如，面对他者的<strong>面容</strong>（visage），我们无法将其简化为视觉对象或心理表征，其存在始终溢出认知框架，构成一种 “存在的溢出”（excess of being）。</p>\n</li>\n<li>\n<p><strong>无限的超越性（Infinite Transcendence）</strong><br />\n外在性与他者的 “无限性”（Infinity）紧密关联。列维纳斯借用笛卡尔的 “无限观念” 指出：</p>\n<blockquote>\n<p>“无限不是被思考的对象，而是思考的条件。”<br />\n 他者的无限性迫使自我承认自身的有限性，从而打破封闭的主体性。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>伦理的被动性（Ethical Passivity）</strong><br />\n外在性要求自我以<strong>被动性</strong>回应他者。这种被动性非消极，而是伦理责任的起点 —— 在他者的面容前，自我无法选择是否回应，只能被责任 “扣押”（obsession）。</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"三-外在性的现象学呈现面容与言说\"><a class=\"anchor\" href=\"#三-外在性的现象学呈现面容与言说\">#</a> 三、<strong>外在性的现象学呈现：面容与言说</strong></h3>\n<ol>\n<li>\n<p><strong>面容（Visage）作为外在性的具象化</strong></p>\n<ul>\n<li>面容不是物理意义上的脸，而是他者存在的直接显现。它的<strong>脆弱性</strong>（如皮肤下跳动的血管）与<strong>裸露性</strong>（无防御的敞开）发出无声的伦理命令：“汝不可杀人”（Tu ne tueras point）。</li>\n<li>面容的显现是<strong>非暴力的暴力</strong> —— 它不通过力量压制，却以脆弱性瓦解自我的权力意志。</li>\n</ul>\n</li>\n<li>\n<p><strong>言说（Dire）与所说（Dit）的张力</strong></p>\n<ul>\n<li><strong>言说</strong>（Dire）：他者的语言作为外在性的动态表达，始终携带未被说出的意义，拒绝被固化为 “所说”（Dit，即命题化、主题化的内容）。</li>\n<li><strong>语言的超越性</strong>：他者的言说如犹太教《塔木德》的诠释传统，永远留有意义的剩余，迫使自我放弃对意义的垄断。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"四-外在性的伦理意涵\"><a class=\"anchor\" href=\"#四-外在性的伦理意涵\">#</a> 四、<strong>外在性的伦理意涵</strong></h3>\n<ol>\n<li>\n<p><strong>责任先于自由</strong><br />\n列维纳斯颠倒了传统伦理学的根基：不是自由选择产生责任，而是他者的外在性<strong>强加责任</strong>于自我。这种责任是：</p>\n<ul>\n<li><strong>不对称的</strong>：无需他者回报；</li>\n<li><strong>无限的</strong>：超越具体情境的算计；</li>\n<li><strong>创伤性的</strong>：如 “人质” 般被劫持，被迫为他者承担一切。</li>\n</ul>\n</li>\n<li>\n<p><strong>替代（Substitution）：存在的极端形式</strong></p>\n<ul>\n<li>外在性在伦理层面体现为 “为他者受难”。列维纳斯提出：\n<blockquote>\n<p>“我即是他者的人质。”<br />\n 例如，当他者饥饿时，“我的胃在痉挛”—— 这不是共情，而是存在论上的替代，自我成为他者痛苦的载体。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"五-外在性与现代性反思\"><a class=\"anchor\" href=\"#五-外在性与现代性反思\">#</a> 五、<strong>外在性与现代性反思</strong></h3>\n<ol>\n<li>\n<p><strong>技术社会的危机</strong><br />\n在算法与大数据时代，他者被简化为数据点（如社交媒体的 “用户画像”），外在性被数字化的 “同一性” 吞噬。列维纳斯警示：失去外在性，意味着伦理关系的消亡。</p>\n</li>\n<li>\n<p><strong>生态伦理的扩展</strong><br />\n外在性可延伸至非人类存在（如动物、自然），挑战人类中心主义。一座山的沉默或一只动物的凝视，是否也携带不可还原的外在性？这为深层生态学提供了哲学基础。</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"六-列维纳斯与相关哲学家的对比\"><a class=\"anchor\" href=\"#六-列维纳斯与相关哲学家的对比\">#</a> 六、<strong>列维纳斯与相关哲学家的对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>哲学家</th>\n<th>核心概念</th>\n<th>与外在性的关系</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>黑格尔</td>\n<td>主奴辩证法</td>\n<td>他者被同一性消解，外在性被否定</td>\n</tr>\n<tr>\n<td>胡塞尔</td>\n<td>主体间性</td>\n<td>他者作为 “另一个自我”，外在性被弱化</td>\n</tr>\n<tr>\n<td>海德格尔</td>\n<td>共在（Mitsein）</td>\n<td>他者融入存在结构，外在性被稀释</td>\n</tr>\n<tr>\n<td>萨特</td>\n<td>他人即地狱</td>\n<td>外在性沦为对抗性，失去伦理维度</td>\n</tr>\n<tr>\n<td>德里达</td>\n<td>延异（Différance）</td>\n<td>外在性被解构为符号差异，缺乏伦理强制</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h3 id=\"结语外在性作为存在的救赎\"><a class=\"anchor\" href=\"#结语外在性作为存在的救赎\">#</a> 结语：外在性作为存在的救赎</h3>\n<p>列维纳斯的外在性不仅是一个哲学概念，更是对现代性危机的诊断与解药。在自我膨胀、他者消逝的今天，外在性提醒我们：<br />\n<strong>真正的伦理生活，始于承认他者永远外在于我的掌控，并甘愿为其付出无限责任。</strong><br />\n这种 “被动性” 非但不是弱点，反而是人性对抗虚无的最后堡垒。</p>\n<h1 id=\"q简单介绍一下对列维纳斯这套理论的批判\"><a class=\"anchor\" href=\"#q简单介绍一下对列维纳斯这套理论的批判\">#</a> Q：简单介绍一下对列维纳斯这套理论的批判</h1>\n<p>A:</p>\n<p>列维纳斯的伦理学尽管深刻，但也面临多方批判。以下是几个主要批判方向，结合具体例子说明：</p>\n<hr />\n<h3 id=\"一-抽象性困境脱离具体历史与社会\"><a class=\"anchor\" href=\"#一-抽象性困境脱离具体历史与社会\">#</a> 一、<strong>抽象性困境：脱离具体历史与社会</strong></h3>\n<ol>\n<li>\n<p><strong>真空中的伦理</strong><br />\n批判者（如齐泽克）指出，列维纳斯将伦理简化为 “面对面” 的抽象关系，<strong>忽视权力结构</strong>。例如：</p>\n<ul>\n<li>一个贫民窟儿童与跨国资本家的 “面容相遇” 中，结构性的剥削被伦理责任遮蔽。</li>\n<li>列维纳斯未回答：当 “他者” 是系统性暴力的受益者时，无限责任是否合理？</li>\n</ul>\n</li>\n<li>\n<p><strong>历史创伤的缺席</strong><br />\n列维纳斯虽受大屠杀影响，但理论未直面<strong>历史具体性</strong>。汉娜・阿伦特批评：</p>\n<blockquote>\n<p>“对纳粹刽子手谈‘汝不可杀人’，等于纵容邪恶。”<br />\n 伦理的绝对性可能消解对结构性不义的抵抗。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h3 id=\"二-政治无能从伦理到实践的断裂\"><a class=\"anchor\" href=\"#二-政治无能从伦理到实践的断裂\">#</a> 二、<strong>政治无能：从伦理到实践的断裂</strong></h3>\n<ol>\n<li>\n<p><strong>责任 vs 正义</strong><br />\n列维纳斯强调个体对 “他者” 的责任，但未解决<strong>多重他者的冲突</strong>。例如：</p>\n<ul>\n<li>巴勒斯坦人与以色列人互相视对方为 “他者”，无限责任如何转化为政治方案？</li>\n<li>南希・弗雷泽指出：“当多个他者的诉求冲突时，列维纳斯缺乏分配正义的原则。”</li>\n</ul>\n</li>\n<li>\n<p><strong>非暴力的悖论</strong><br />\n列维纳斯反对一切暴力，但现实中抵抗压迫常需暴力（如反殖民斗争）。弗朗茨・法农批评：</p>\n<blockquote>\n<p>“被殖民者的暴力，是对殖民者‘杀人禁令’早已失效的回应。”<br />\n 绝对非暴力可能沦为对压迫的默许。</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h3 id=\"三-性别盲区女性主义的批判\"><a class=\"anchor\" href=\"#三-性别盲区女性主义的批判\">#</a> 三、<strong>性别盲区：女性主义的批判</strong></h3>\n<ol>\n<li>\n<p><strong>男性中心的伦理</strong><br />\n露西・伊丽格瑞指出，列维纳斯的 “他者” 实质是<strong>男性化的他者</strong>：</p>\n<ul>\n<li>女性作为 “他者之他者”（如母亲、妻子）被排除在伦理场景外。</li>\n<li>面容的脆弱性隐喻强化女性 “被动受害” 的刻板形象。</li>\n</ul>\n</li>\n<li>\n<p><strong>母性经验的矛盾</strong><br />\n列维纳斯用 “母性” 比喻替代性责任（“为他者受难”），但女性主义者朱迪斯・巴特勒反驳：</p>\n<blockquote>\n<p>“这浪漫化了母性的牺牲，掩盖了真实生育中的权力不对等。”</p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h3 id=\"四-哲学内部的矛盾\"><a class=\"anchor\" href=\"#四-哲学内部的矛盾\">#</a> 四、<strong>哲学内部的矛盾</strong></h3>\n<ol>\n<li>\n<p><strong>语言背叛</strong><br />\n德里达在《暴力与形而上学》中指出：列维纳斯用哲学语言（一种 “总体化” 工具）言说 “不可言说的他者”，陷入<strong>自我解构</strong>：</p>\n<blockquote>\n<p>“试图用概念捕捉外在性，恰是对外在性的谋杀。”</p>\n</blockquote>\n</li>\n<li>\n<p><strong>犹太性的困境</strong><br />\n列维纳斯将犹太教伦理普世化，但批评者（如巴迪欧）认为这是<strong>特殊主义的伪装</strong>：</p>\n<ul>\n<li>“无限责任” 实质是犹太选民意识的世俗版本，缺乏跨文化有效性。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"五-生态批判人类中心主义的阴影\"><a class=\"anchor\" href=\"#五-生态批判人类中心主义的阴影\">#</a> 五、<strong>生态批判：人类中心主义的阴影</strong></h3>\n<ol>\n<li>\n<p><strong>非人类他者的缺席</strong><br />\n列维纳斯的他者仅限于人类，<strong>动物、自然被排除在伦理领域外</strong>。生态哲学家蒂莫西・莫顿质问：</p>\n<blockquote>\n<p>“一座因石油开采而消失的冰川，是否拥有‘面容’？”</p>\n</blockquote>\n</li>\n<li>\n<p><strong>技术物的伦理地位</strong><br />\n人工智能、仿生人等 “非人他者” 的出现，暴露其理论的局限性：</p>\n<ul>\n<li>如果 AI 的 “面容” 发出伦理命令，人类是否有责任服从？</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"总结批判的价值与理论的边界\"><a class=\"anchor\" href=\"#总结批判的价值与理论的边界\">#</a> 总结：批判的价值与理论的边界</h3>\n<p>这些批判并非否定列维纳斯的贡献，而是揭示其理论的<strong>历史局限与内在紧张</strong>。关键在于：</p>\n<ul>\n<li><strong>伦理的纯粹性 vs 现实的复杂性</strong>：当责任无限性与具体情境冲突时，如何抉择？</li>\n<li><strong>个体的神圣性 vs 集体的正义</strong>：当拯救一个他者需牺牲更多他者时，伦理是否失效？</li>\n</ul>\n<p>列维纳斯的真正遗产，或许不在于提供答案，而在于迫使我们在一个 “他者” 日渐被数据、资本与权力吞噬的时代，<strong>不断追问伦理的可能性与代价</strong>。</p>\n",
            "tags": [
                "生活",
                "思考",
                "列维纳斯",
                "现象学",
                "GPT"
            ]
        },
        {
            "id": "http://amentiraz.github.io/life/%E5%8F%A5%E5%AD%90%E6%91%98%E5%BD%95/",
            "url": "http://amentiraz.github.io/life/%E5%8F%A5%E5%AD%90%E6%91%98%E5%BD%95/",
            "title": "句子摘录",
            "date_published": "2025-05-11T07:49:06.000Z",
            "content_html": "<p>平时看到的一些好的句子就记录在这里面吧。</p>\n<span id=\"more\"></span>\n<p>Everything in the universe is within you, Ask all from yourself. -- 鲁米</p>\n<hr />\n<p>“我的社交能力还不如 5 岁的儿童和狗” -- 《孤独摇滚》</p>\n<hr />\n<p>你从不曾爱过我，你只爱我在你的生命中坠落。 -- 李娟</p>\n<hr />\n<p>“一直以来，似乎在关键的时刻，我大约都是选择困难的道理。”</p>\n<p>“在一种疏离感中获得意外的自由”</p>\n<p>-- 坂本龙一</p>\n<hr />\n<p>就让我在别人眼中虚伪吧，如果我对自己忠诚。 -- 艾米莉・勃朗特</p>\n<hr />\n<p>我宁愿和你一起奔向毁灭，也不愿意体验舒适的孤独。 -- 加缪</p>\n<hr />\n",
            "tags": [
                "生活",
                "摘录",
                "摘录"
            ]
        },
        {
            "id": "http://amentiraz.github.io/article/scPerturb/",
            "url": "http://amentiraz.github.io/article/scPerturb/",
            "title": "scPerturb",
            "date_published": "2025-05-11T02:16:23.000Z",
            "content_html": "<p>scPerturb: harmonized single-cell perturbation data.</p>\n<span id=\"more\"></span>\n<p>第一次接触这个领域，仔细的研读一下。</p>\n<h1 id=\"abstract\"><a class=\"anchor\" href=\"#abstract\">#</a> Abstract</h1>\n<p>这篇文章应用了 uniform quality control pipelines 和 harmonize feature annotations. 然后对于它的模型 scPerturb 的目的是 facilitates comparison and integration across datasets. 它们描述了一个 energy statistics (E-statistics) 去衡量 perturbation 和显著性检验。</p>\n<p>This work provides an information resource for researchers working with single-cell perturbation data and recommendations for experimental design, including optimal cell counts and read depth.</p>\n<h1 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> Introduction</h1>\n<p>Perturbation experiments probe the response of cells or cellular systems to changes in conditions.</p>\n<p>Nowadays, with advanced functional genomics techniques, single-cell genetic perturbations acting on individual cellular components are available. Perturbations using different technologies target different layers of the hierarchy of protein production.</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/41592_2023_2144_Fig1_HTML.webp\" alt=\"\" /><br />\n这里解释一下这张图，上面提到的 different technologies 指的是例如 CRISPR-cas9、CRISPRi 这些东西。比如 CRISPR-cas9 它在基因上直接做增删，CRISPRi 和 CRISPRa 分别抑制和激活转录 (transcription)，CRISPR-cas13 切割 RNA，一些小分子的药物影响蛋白质产物例如酶和受体。</p>\n<p>然后是比较关键的一句话： Barcodes associated with unique CRISPR guide perturbations are read alongside single-cell RNA sequencing (scRNA-seq), CITE-seq (cellular indexing of transcriptomes and epitopes by sequencing) or scATAC-seq (single-cell sequencing assay for transposase-accessible chromatin) to identify each cell’s perturbation condition.</p>\n<p>感觉很难理解上面这句话，我拿 GPT 跑了一个解释。</p>\n<details class=\"danger\"><summary>三种数据</summary><div>\n<p>下面分别对这三种单细胞多组学技术做详细介绍，包括它们的基本原理、实验流程、优势与局限，以及典型应用场景。</p>\n<hr />\n<h2 id=\"1-single-cell-rna-sequencing-scrna-seq\"><a class=\"anchor\" href=\"#1-single-cell-rna-sequencing-scrna-seq\">#</a> 1. Single-cell RNA sequencing (scRNA-seq)</h2>\n<h3 id=\"基本原理\"><a class=\"anchor\" href=\"#基本原理\">#</a> 基本原理</h3>\n<p>scRNA-seq 用于在单细胞水平上定量每个细胞的转录组（mRNA）表达。它能够揭示细胞间在基因表达谱上的异质性，识别不同细胞类型、细胞状态和发育轨迹。</p>\n<h3 id=\"实验流程\"><a class=\"anchor\" href=\"#实验流程\">#</a> 实验流程</h3>\n<ol>\n<li>\n<p><strong>单细胞分离</strong></p>\n<ul>\n<li>微流控芯片（如 10x Genomics Chromium）或滴式微流控（Drop-seq、inDrop）将单个细胞包封于微小液滴或孔室中。</li>\n</ul>\n</li>\n<li>\n<p><strong>细胞裂解与逆转录</strong></p>\n<ul>\n<li>每个液滴内加入含有细胞条形码（cell barcode）和分子标签（UMI, unique molecular identifier）的引物，裂解细胞并逆转录生成带有条形码的 cDNA。</li>\n</ul>\n</li>\n<li>\n<p><strong>文库构建与测序</strong></p>\n<ul>\n<li>将所有液滴中的 cDNA 汇合，进行扩增、建库并上机高通量测序（Illumina）。</li>\n</ul>\n</li>\n<li>\n<p><strong>数据处理与分析</strong></p>\n<ul>\n<li>根据条形码将每条读数（read）分配回对应细胞，UMI 去重后得到每个细胞中每个基因的表达量矩阵。</li>\n<li>下游分析包括细胞聚类、差异表达、伪时序分析等。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"优势\"><a class=\"anchor\" href=\"#优势\">#</a> 优势</h3>\n<ul>\n<li>能在单细胞水平揭示生物体系的异质性。</li>\n<li>支持大规模细胞通量（可达数万到数十万细胞）。</li>\n<li>数据成熟，分析工具丰富（Seurat、Scanpy 等）。</li>\n</ul>\n<h3 id=\"局限\"><a class=\"anchor\" href=\"#局限\">#</a> 局限</h3>\n<ul>\n<li>只捕获多聚 A 尾 mRNA，无法直接测到非 polyadenylated RNA（如部分非编码 RNA）。</li>\n<li>有 “高掉落率”（dropout）现象：低丰度转录本常常检测不到。</li>\n<li>无空间信息，需要结合空间转录组或成像技术。</li>\n</ul>\n<h3 id=\"应用场景\"><a class=\"anchor\" href=\"#应用场景\">#</a> 应用场景</h3>\n<ul>\n<li>细胞类型鉴定与注释</li>\n<li>发育过程伪时序重构</li>\n<li>疾病微环境中的免疫细胞分型</li>\n<li>药物或基因扰动后细胞响应分析</li>\n</ul>\n<hr />\n<h2 id=\"2-cite-seq\"><a class=\"anchor\" href=\"#2-cite-seq\">#</a> 2. CITE-seq</h2>\n<p>(Cellular Indexing of Transcriptomes and Epitopes by Sequencing)</p>\n<h3 id=\"基本原理-2\"><a class=\"anchor\" href=\"#基本原理-2\">#</a> 基本原理</h3>\n<p>CITE-seq 在常规模版 scRNA-seq 的基础上，额外对细胞表面或胞内蛋白进行标记与测量。它使用带有寡核苷酸标签的抗体（antibody–oligo conjugates），让蛋白质水平的定量也能通过测序来获取。</p>\n<h3 id=\"实验流程-2\"><a class=\"anchor\" href=\"#实验流程-2\">#</a> 实验流程</h3>\n<ol>\n<li>\n<p><strong>抗体标记</strong></p>\n<ul>\n<li>每种待测抗体共轭一个短的 DNA 报告子序列（antibody barcode）。</li>\n</ul>\n</li>\n<li>\n<p><strong>细胞染色</strong></p>\n<ul>\n<li>将多重标记的抗体混合物与细胞（或细胞悬液）孵育，使抗体特异性结合对应表面蛋白。</li>\n</ul>\n</li>\n<li>\n<p><strong>单细胞分离与裂解</strong></p>\n<ul>\n<li>如同 scRNA-seq，包封单细胞并裂解，同时释放 mRNA 和抗体上的 DNA barcode。</li>\n</ul>\n</li>\n<li>\n<p><strong>共逆转录与扩增</strong></p>\n<ul>\n<li>同时逆转录 mRNA（带细胞条形码 + UMI）与抗体 DNA barcode。</li>\n</ul>\n</li>\n<li>\n<p><strong>文库构建与测序</strong></p>\n<ul>\n<li>分离两种 cDNA：一部分用于测序转录组，另一部分用于测序抗体验证条形码（常用定制引物扩增）。</li>\n</ul>\n</li>\n<li>\n<p><strong>数据融合</strong></p>\n<ul>\n<li>将每个细胞的基因表达数据与对应的抗体信号（epitope 数量）整合，得到 “RNA + 蛋白” 联合矩阵。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"优势-2\"><a class=\"anchor\" href=\"#优势-2\">#</a> 优势</h3>\n<ul>\n<li>同时获得转录组与蛋白组信息，提高细胞类型鉴别的精度。</li>\n<li>蛋白质水平数据对低丰度或翻译后调控的靶点更敏感。</li>\n<li>可以同时检测几十到上百种表面 / 胞内蛋白。</li>\n</ul>\n<h3 id=\"局限-2\"><a class=\"anchor\" href=\"#局限-2\">#</a> 局限</h3>\n<ul>\n<li>抗体质量和特异性决定实验效果，需要严格的抗体验证。</li>\n<li>抗体–oligo 的成本和制备复杂度高于普通 scRNA-seq 试剂。</li>\n<li>通量受抗体组数和测序深度限制。</li>\n</ul>\n<h3 id=\"应用场景-2\"><a class=\"anchor\" href=\"#应用场景-2\">#</a> 应用场景</h3>\n<ul>\n<li>免疫细胞谱系分型（T 细胞亚群、B 细胞亚群鉴定）</li>\n<li>转录组与表型标志物联合分析</li>\n<li>细胞分化过程中蛋白与 RNA 调控耦合研究</li>\n<li>临床样本中多标志物联合表型剖析</li>\n</ul>\n<hr />\n<h2 id=\"3-single-cell-atac-sequencing-scatac-seq\"><a class=\"anchor\" href=\"#3-single-cell-atac-sequencing-scatac-seq\">#</a> 3. Single-cell ATAC sequencing (scATAC-seq)</h2>\n<p>(Assay for Transposase-Accessible Chromatin)</p>\n<h3 id=\"基本原理-3\"><a class=\"anchor\" href=\"#基本原理-3\">#</a> 基本原理</h3>\n<p>scATAC-seq 用于在单细胞水平绘制染色质开放性（chromatin accessibility）图谱，揭示基因调控元件（如启动子、增强子）在不同细胞类型或状态下的可及性差异。</p>\n<h3 id=\"实验流程-3\"><a class=\"anchor\" href=\"#实验流程-3\">#</a> 实验流程</h3>\n<ol>\n<li>\n<p><strong>单细胞分离</strong></p>\n<ul>\n<li>类似 scRNA-seq，可用微流控芯片（10x Genomics Chromium）或微流体滴式系统。</li>\n</ul>\n</li>\n<li>\n<p><strong>Tn5 转座酶标记</strong></p>\n<ul>\n<li>在裂解后的细胞核中加入加载了测序接头的 Tn5 转座酶，它会 preferentially 插入到开放染色质区，使这些区域同时获得测序接头。</li>\n</ul>\n</li>\n<li>\n<p><strong>条形码融合</strong></p>\n<ul>\n<li>通过在微液滴或孔室中完成转座反应，使插入片段带上细胞条形码和 UMI。</li>\n</ul>\n</li>\n<li>\n<p><strong>扩增与测序</strong></p>\n<ul>\n<li>扩增插入了接头的 DNA 片段，构建文库并进行高通量测序。</li>\n</ul>\n</li>\n<li>\n<p><strong>数据处理与分析</strong></p>\n<ul>\n<li>根据条形码将读数分配到细胞，去除 PCR 重复后得到每个细胞在基因组各位点的可及性矩阵（细胞 × peaks）。</li>\n<li>下游可做细胞聚类、TF motif 分析、基因调控网络推断等。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"优势-3\"><a class=\"anchor\" href=\"#优势-3\">#</a> 优势</h3>\n<ul>\n<li>直接捕获调控元件活性，补充转录组数据无法提供的调控层信息。</li>\n<li>能鉴定特异细胞类型的关键增强子或 TF 結合位点。</li>\n<li>与 scRNA-seq 联合（例如 Multiome）可同时获取转录组和染色质可及性数据。</li>\n</ul>\n<h3 id=\"局限-3\"><a class=\"anchor\" href=\"#局限-3\">#</a> 局限</h3>\n<ul>\n<li>通量和数据稀疏性问题更严重，通常每个细胞只有几千到一万条有效片段。</li>\n<li>峰（peak）调用和比对较复杂，对计算资源要求高。</li>\n<li>需要更深的测序深度以覆盖低频开放区域。</li>\n</ul>\n<h3 id=\"应用场景-3\"><a class=\"anchor\" href=\"#应用场景-3\">#</a> 应用场景</h3>\n<ul>\n<li>构建细胞类型特异的调控元件图谱</li>\n<li>推断转录因子活性与基因调控网络</li>\n<li>发育过程中染色质重塑动态研究</li>\n<li>结合 GWAS 数据定位变异影响的调控元件</li>\n</ul>\n<hr />\n<p><strong>总结对比</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>scRNA-seq</th>\n<th>CITE-seq</th>\n<th>scATAC-seq</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>主要测量层面</td>\n<td>mRNA 转录本</td>\n<td>mRNA + 表面 / 胞内蛋白</td>\n<td>染色质开放性（调控元件可及性）</td>\n</tr>\n<tr>\n<td>条形码与 UMI</td>\n<td>都有</td>\n<td>都有</td>\n<td>都有</td>\n</tr>\n<tr>\n<td>数据稀疏性</td>\n<td>较高（dropout）</td>\n<td>较高（RNA 部分） + 蛋白部分相对低 sparsity</td>\n<td>非常高（开放片段稀疏）</td>\n</tr>\n<tr>\n<td>分辨信息</td>\n<td>转录本丰度</td>\n<td>转录本 + 表型蛋白</td>\n<td>调控元件活性</td>\n</tr>\n<tr>\n<td>典型通量</td>\n<td>10⁴–10⁵ 细胞</td>\n<td>10⁴ 细胞（视抗体数量与测序深度而定）</td>\n<td>10³–10⁴ 细胞</td>\n</tr>\n</tbody>\n</table>\n<p>这三种技术各有侧重，常常结合使用以获得细胞多层次的分子图谱，帮助我们更全面地理解细胞状态与功能。</p>\n</div></details>\n<p>说实话，总感觉这段话有点牵强，真的和 perturbations 相关性这么大吗。</p>\n<p>下面的一段说了一下大规模数据的影响，目前精确去预测网络的 interactions 还是受限于数据规模小的影响。Large-scale single-cell perturbation–response screens enable exploration of complex cellular behavior inaccessible in bulk measurements.</p>\n<p>研究目的：Reliable analysis of increasingly large perturbation datasets requires efficient statistical tools to harness large numbers of cells and perturbations. 研究背景：The inherently high dimensionality of perturbation–response data complicates calculation of distances between perturbations, as does cell-to-cell variation and data sparsity. 本文基于各种 Multiple distance measures 方法中的 energy distance。</p>\n<p>“Cell lines”（细胞系）是指在体外条件下（通常是培养皿或培养瓶中），从多细胞生物体取出的细胞经适当处理后，能够持续生长、分裂并保持特定特征的一类细胞群体。</p>\n<p>Large perturbation screens are specifically designed to study a particular system, such as a cell line, under a set of perturbations of interest. 研究背景：“the field has accumulated a heterogeneous assortment of single-cell perturbation–response data with a wide range of different cell types, such as immortalized cell lines and induced pluripotent stem cell-derived models, and different perturbation technologies, including knockouts, activation, interference, base editing and prime editing”。所以 Computational methods to efficiently harmonize these different perturbation datasets are needed.</p>\n<p>所以这个文章干了两件事，第一，提供了 scPerturb 去标准化数据集，第二，提供了 E-distance 作为衡量指标。</p>\n<p>还是有点懵。</p>\n<h1 id=\"results\"><a class=\"anchor\" href=\"#results\">#</a> Results</h1>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/41592_2023_2144_Fig2_HTML.webp\" alt=\"\" /></p>\n<p>这里记一个结论：The average sequencing depth, that is, the mean number of reads per cell, in each study affects the number of low-expression genes observed. Increasing sequencing depth increases the UMI counts measured even for low-expression genes, reducing the uncertainty associated with zero counts.</p>\n<p>“测序深度（sequencing depth）” 是指在测序实验中，每个位点或每个分子被测序的平均次数，它反映的是数据的丰富程度或覆盖程度。</p>\n<p>这一大段挺难理解的，我拿 GPT 跑了一个解释：<br />\n这段话的核心在讲：<strong>不同数据集的测序质量指标差异很大，而测序深度对单细胞扰动实验的可解释性和分析结果有显著影响。</strong></p>\n<p>具体讲了以下几点：</p>\n<hr />\n<h3 id=\"1-不同数据集的样本质量差异显著\"><a class=\"anchor\" href=\"#1-不同数据集的样本质量差异显著\">#</a> 🔍 1. <strong>不同数据集的样本质量差异显著</strong></h3>\n<ul>\n<li>\n<p>数据集中细胞总数的多少主要受限于实验条件（例如样本处理能力、试剂成本、设备通量），尽管随着技术进步总量有增长趋势（见 Fig. 2b）。</p>\n</li>\n<li>\n<p>常用的质量控制指标包括：</p>\n<ul>\n<li>每个细胞的总 <strong>UMI 数（unique molecular identifier）</strong></li>\n<li>每个细胞检测到的 <strong>基因数量</strong></li>\n</ul>\n<blockquote>\n<p>👉 这些数值反映了测序的 “有效信息量”，在后续数据分析中用于筛选低质量细胞。</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n<h3 id=\"2-平均测序深度影响低表达基因的检测\"><a class=\"anchor\" href=\"#2-平均测序深度影响低表达基因的检测\">#</a> 📊 2. <strong>平均测序深度影响低表达基因的检测</strong></h3>\n<ul>\n<li>\n<p><strong>平均测序深度 = 每个细胞平均测得的 reads 数量</strong></p>\n</li>\n<li>\n<p>测序越深，就越可能捕获到<strong>低表达的基因</strong>，UMI 数也越高，进而：</p>\n<ul>\n<li>减少 “0 表达” 现象的误判（dropout）</li>\n<li>提高低表达基因的可靠检测</li>\n</ul>\n</li>\n<li>\n<p>这意味着：深度高不仅能检测更多基因，还能<strong>降低因低丰度而产生的假阴性</strong></p>\n</li>\n</ul>\n<hr />\n<h3 id=\"3-测序深度-数据质量\"><a class=\"anchor\" href=\"#3-测序深度-数据质量\">#</a> 🧪 3. <strong>测序深度 ≠ 数据质量</strong></h3>\n<ul>\n<li>\n<p><strong>并非只要加深测序就能弥补实验缺陷</strong>：</p>\n<ul>\n<li>如果在实验过程中 mRNA 已经降解了，reads 再多也无法 “复原” 丢失的转录本。</li>\n<li>数据恢复的上限受限于样本质量，常用 ** 测序饱和度（sequencing saturation）** 来估计。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"️-4-这些质量差异会影响后续分析\"><a class=\"anchor\" href=\"#️-4-这些质量差异会影响后续分析\">#</a> ⚠️ 4. <strong>这些质量差异会影响后续分析</strong></h3>\n<ul>\n<li>\n<p>不同扰动条件下，如果测序深度或数据质量不一致，可能会影响：</p>\n<ul>\n<li>扰动间的差异是否能被识别（distinguishability）</li>\n<li>聚类、差异表达、轨迹分析等下游计算的效果（downstream analysis performance）</li>\n</ul>\n</li>\n</ul>\n<hr />\n<p>这里介绍了 E-distance 这个概念，对于两组细胞，它描述了这两组细胞的分布的 distance。More precisely, it compares the mean pairwise distance of cells between two different perturbations to the mean pairwise distance of cells within each of the two distribution.</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/41592_2023_2144_Fig3_HTML.webp\" alt=\"\" /></p>\n<p>Fig (c) :This is in part caused by two-target perturbations using CRISPRa in that dataset: targeting the same gene with two single guides increases the chances of causing a considerable change in the transcript profile.</p>\n<p>The E-distance can also be used to quantify similarity between different perturbations.<br />\nFig (e): 观察 unperturbed 和其它的分布可以看出对于不同的 E-test 值可以明显区分出来。对于 CEBPA 和 KLF1+CEBPA 重叠的区域 is captured by a low E-distance:cells affected by these two perturbations are closer to each other than they are to unperturbed cells or to those from other perturbations.</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/41592_2023_2144_Fig4_HTML.webp\" alt=\"\" /></p>\n<p>这段话主要在说明：<strong>如何利用 E-distance（能量距离）分析扰动数据集中不同基因扰动之间的相似性，并验证其在免疫信号通路中的生物学一致性。</strong></p>\n<hr />\n<h3 id=\"具体讲了什么\"><a class=\"anchor\" href=\"#具体讲了什么\">#</a> 📌 具体讲了什么？</h3>\n<ol>\n<li>\n<p><strong>分析背景与数据集来源</strong></p>\n<ul>\n<li>研究选用了一个关于免疫抑制检查点的扰动数据集（见 Fig. 4），该数据集使用 <strong>CRISPR-Cas9</strong> 对多个调控 <strong>PD-L1 表达</strong> 的基因进行扰动（参考文献 [9]）。</li>\n</ul>\n</li>\n<li>\n<p><strong>方法：E-distance 计算扰动间的相似性</strong></p>\n<ul>\n<li>计算了所有基因扰动对之间的 <strong>两两 E-distance</strong>，即它们诱导的细胞状态差异有多大。</li>\n<li>然后对这个距离矩阵进行了<strong>层次聚类（hierarchical clustering）</strong>，发现出现了两个显著不同的扰动子群（clusters）。</li>\n</ul>\n</li>\n<li>\n<p><strong>观察与解释：形成一个具有相似表型的基因群</strong></p>\n<ul>\n<li>其中一个扰动群体（IFNGR1、IFNGR2、JAK2、STAT1）之间的 E-distance 较小，说明它们产生了<strong>相似的细胞转录组响应</strong>。</li>\n<li>而它们与 “未扰动对照组” 之间的 E-distance 较大，说明这些扰动引起了显著变化。</li>\n</ul>\n</li>\n<li>\n<p><strong>生物学一致性验证</strong></p>\n<ul>\n<li>\n<p>这组基因（IFNGR1, IFNGR2, JAK2, STAT1）正好都位于 <strong>IFNγ（干扰素 -γ）信号通路</strong>中，属于同一个上游 / 下游调控链条：</p>\n<ul>\n<li>它们都在 <strong>IFNγ → IRF1 → PD-L1 表达</strong> 的通路中起作用（参考文献 [50]）。</li>\n</ul>\n</li>\n<li>\n<p>因此扰动这些基因会引发相似的表型改变，是<strong>功能一致性的体现</strong>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<hr />\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/41592_2023_2144_Fig5_HTML.webp\" alt=\"\" /></p>\n<p>这段话讲的是：<strong>作者通过子采样（subsampling）实验系统评估了 E-distance 和 E-test 对样本数量变化的敏感性和鲁棒性（稳定性），并给出合理使用它们的建议。</strong></p>\n<hr />\n<h3 id=\"具体讲了什么-2\"><a class=\"anchor\" href=\"#具体讲了什么-2\">#</a> 📌 具体讲了什么？</h3>\n<h4 id=\"1-研究目的\"><a class=\"anchor\" href=\"#1-研究目的\">#</a> ✅ 1. <strong>研究目的</strong></h4>\n<ul>\n<li>使用 scPerturb 提供的统一注释的单细胞扰动数据集，评估 <strong>E-distance（用于量化扰动差异）和 E-test（用于显著性检验）</strong> 对实验设计和数据处理参数的鲁棒性（尤其是细胞数目的影响）。</li>\n</ul>\n<h4 id=\"2-实验方法人为减少细胞数进行测试\"><a class=\"anchor\" href=\"#2-实验方法人为减少细胞数进行测试\">#</a> ✅ 2. <strong>实验方法：人为减少细胞数进行测试</strong></h4>\n<ul>\n<li>人为<strong>下采样每个扰动条件中的细胞数</strong>，模拟 “小样本” 场景，观察这时 E-distance 和 E-test 分数如何变化。</li>\n</ul>\n<h4 id=\"3-偏差修正bias-correction\"><a class=\"anchor\" href=\"#3-偏差修正bias-correction\">#</a> ✅ 3. <strong>偏差修正（bias correction）</strong></h4>\n<ul>\n<li>提出了一种<strong> E-distance 的偏差修正方法</strong>，以提高在小样本条件下的准确性（详见补充材料第 1 节）。</li>\n</ul>\n<h4 id=\"4-发现-1即使修正后e-distance-在细胞数减少时仍上升\"><a class=\"anchor\" href=\"#4-发现-1即使修正后e-distance-在细胞数减少时仍上升\">#</a> ✅ 4. <strong>发现 1：即使修正后，E-distance 在细胞数减少时仍上升</strong></h4>\n<ul>\n<li>\n<p>即使使用了偏差修正，在<strong>每个扰动下的细胞数减少时，E-distance 仍会人为变大</strong>，这说明：</p>\n<ul>\n<li><strong>计算 E-distance 前需要对每个扰动的细胞数进行标准化</strong>（例如统一抽取相同数量的细胞），否则可能引入比较偏差。</li>\n<li>原因在于：<strong>PCA 在小样本情况下不能很好表示高维数据结构</strong>，从而扭曲了距离估计。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-发现-2显著性检验结果随着样本数下降而自然减少\"><a class=\"anchor\" href=\"#5-发现-2显著性检验结果随着样本数下降而自然减少\">#</a> ✅ 5. <strong>发现 2：显著性检验结果随着样本数下降而自然减少</strong></h4>\n<ul>\n<li>当细胞数下降时，能被识别为显著扰动的基因数量减少，这是符合预期的：样本越少，统计功效越低。</li>\n<li>同时观察到，并非所有数据集在 “全部细胞数” 时都达到了扰动检测的饱和状态（即：进一步增加细胞数可能还会发现新扰动）。</li>\n</ul>\n<h4 id=\"6-影响因素扰动强度与数据异质性\"><a class=\"anchor\" href=\"#6-影响因素扰动强度与数据异质性\">#</a> ✅ 6. <strong>影响因素：扰动强度与数据异质性</strong></h4>\n<ul>\n<li>\n<p>检测 “饱和点”（saturation point）取决于：</p>\n<ul>\n<li><strong>扰动的效应强度（effect size）</strong>：强效扰动易被发现，弱效扰动需要更多细胞。</li>\n<li><strong>数据集的异质性（heterogeneity）</strong>：如果细胞彼此非常相似，则较少样本就足以捕捉扰动的平均效应。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<p>这段话主要讲的是：<strong>评估单位细胞内的测序深度（即 UMI 数量）对扰动分析结果的影响，并提出实际实验设计的参考建议。</strong></p>\n<hr />\n<h3 id=\"具体内容逐句解析\"><a class=\"anchor\" href=\"#具体内容逐句解析\">#</a> 📌 具体内容逐句解析：</h3>\n<h4 id=\"1-umi-数越多e-distance-越大\"><a class=\"anchor\" href=\"#1-umi-数越多e-distance-越大\">#</a> ✅ 1. <strong>UMI 数越多，E-distance 越大</strong></h4>\n<blockquote>\n<p>“We subset the number of UMIs per cell, finding that E-distance increases as the UMI count per cell increases (Fig. 5c).”</p>\n</blockquote>\n<ul>\n<li>\n<p>作者控制变量，只改变每个细胞的 UMI 数（模拟不同测序深度）：</p>\n<ul>\n<li>结果发现：<strong>随着每个细胞的 UMI 数增加，E-distance（能量距离）也增加</strong>。</li>\n<li>原因可能是：高 UMI 会暴露出更多细微的扰动效应，使得扰动组与对照组在表达空间中的距离拉大。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-但-e-test-的显著性结果在-~500-umi-就饱和了\"><a class=\"anchor\" href=\"#2-但-e-test-的显著性结果在-~500-umi-就饱和了\">#</a> ✅ 2. <strong>但 E-test 的显著性结果在～500 UMI 就饱和了</strong></h4>\n<blockquote>\n<p>“The number of significant perturbations under the E-test, however, saturates at around 500 UMIs per cell...”</p>\n</blockquote>\n<ul>\n<li>\n<p>虽然 E-distance 随深度增加而变化，但用于判断扰动是否显著的 <strong>E-test（统计检验）</strong> 在 UMI 达到 500 左右时，显著性结果就趋于稳定（饱和）：</p>\n<ul>\n<li><strong>也就是说：即使 UMI 较少，统计显著的扰动大多数依然能被检测到</strong>。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-说明-e-test-更稳定-更实用\"><a class=\"anchor\" href=\"#3-说明-e-test-更稳定-更实用\">#</a> ✅ 3. <strong>说明 E-test 更稳定、更实用</strong></h4>\n<blockquote>\n<p>“The stability of E-test results... demonstrates the necessity of the E-test... as the appropriate statistical measure...”</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>E-test 比 E-distance 更稳健、不那么依赖测序深度</strong>，因为：</p>\n<ul>\n<li>它使用了 <strong>随机化对照（permutation control）</strong>，可以抵消一部分数据量波动带来的影响。</li>\n<li>所以在实际分析中，<strong>E-test 是更适合用来判断扰动是否有效的统计工具</strong>。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-实验设计建议干货\"><a class=\"anchor\" href=\"#4-实验设计建议干货\">#</a> ✅ 4. <strong>实验设计建议（干货！）</strong></h4>\n<blockquote>\n<p>“we suggest at least 200–500 cells per perturbation and an average of 1,000 UMIs per cell...”</p>\n</blockquote>\n<ul>\n<li>\n<p>综合分析后，作者给出一个<strong>推荐标准</strong>，用于指导单细胞扰动实验设计：</p>\n<ul>\n<li><strong>每个扰动条件下建议至少测序 200–500 个细胞</strong></li>\n<li><strong>每个细胞建议测出平均 1,000 个 UMI</strong></li>\n<li>这两个条件基本能保证对多数 “显著扰动” 的稳定检测。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-但最佳测序深度还要看任务\"><a class=\"anchor\" href=\"#5-但最佳测序深度还要看任务\">#</a> ✅ 5. <strong>但最佳测序深度还要看任务</strong></h4>\n<blockquote>\n<p>“The optimal lower bounds... depend on downstream specific modeling tasks...”</p>\n</blockquote>\n<ul>\n<li>\n<p>注意：这个 “推荐标准” 是用于 “检测扰动是否显著” 的一般性指导；</p>\n<ul>\n<li>若下游任务更复杂（如预测建模、轨迹分析等），所需的测序深度和细胞数可能更高。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h1 id=\"methods\"><a class=\"anchor\" href=\"#methods\">#</a> Methods</h1>\n<p>终于到方法的部分了。</p>\n<h2 id=\"scatac-seq\"><a class=\"anchor\" href=\"#scatac-seq\">#</a> scATAC-seq</h2>\n<p>scATAC-seq is a biomolecular technique to assess chromatin accessibility in single cells.</p>\n<p>这段话主要讲的是：<strong>作者如何处理 scATAC-seq 数据以提取标准化的特征，用于分析单细胞染色质可及性信息。</strong></p>\n<hr />\n<h3 id=\"逐句解释如下\"><a class=\"anchor\" href=\"#逐句解释如下\">#</a> 📌 逐句解释如下：</h3>\n<h4 id=\"1-技术背景\"><a class=\"anchor\" href=\"#1-技术背景\">#</a> ✅ 1. 技术背景</h4>\n<blockquote>\n<p><em>“scATAC-seq is a biomolecular technique to assess chromatin accessibility in single cells.”</em></p>\n</blockquote>\n<ul>\n<li><strong>scATAC-seq 是一种单细胞分辨率的技术</strong>，用于检测染色质的开放程度，即哪些 DNA 区域对转录因子等蛋白 “可及”（accessible）。</li>\n</ul>\n<hr />\n<h4 id=\"2-数据输入格式\"><a class=\"anchor\" href=\"#2-数据输入格式\">#</a> ✅ 2. 数据输入格式</h4>\n<blockquote>\n<p><em>“The starting point of our data processing pipeline is BED-like tabular fragment files...”</em></p>\n</blockquote>\n<ul>\n<li>数据处理流程的起点是类似 <strong>BED 格式的片段文件</strong>（tab-delimited），每一行代表一个被测序捕获到的 <strong>ATAC 片段（fragment）</strong>，包含它所在的基因组位置和对应的<strong>细胞条形码（cell barcode）</strong>。</li>\n</ul>\n<hr />\n<h4 id=\"3-数据处理目标\"><a class=\"anchor\" href=\"#3-数据处理目标\">#</a> ✅ 3. 数据处理目标</h4>\n<blockquote>\n<p><em>“The goal... is to extract standardized features from this information.”</em></p>\n</blockquote>\n<ul>\n<li>目标是从这些原始片段信息中提取出一系列<strong>标准化的、可用于分析的特征</strong>。</li>\n</ul>\n<hr />\n<h4 id=\"4-提取的五类特征如下\"><a class=\"anchor\" href=\"#4-提取的五类特征如下\">#</a> ✅ 4. 提取的五类特征如下：</h4>\n<ol>\n<li>\n<p><strong>LSI Embeddings（低维嵌入）</strong></p>\n<blockquote>\n<p><em>“embeddings derived from latent-semantic-indexing (LSI) with 30 dimensions...”</em></p>\n</blockquote>\n<ul>\n<li>使用 <strong>潜在语义索引（LSI）</strong> 方法将高维稀疏的 ATAC-seq 数据降维成每个细胞一个 <strong>30 维向量</strong>，适合稀疏性强的单细胞 ATAC 数据。</li>\n</ul>\n</li>\n<li>\n<p><strong>Gene Scores（基因开放性得分）</strong></p>\n<blockquote>\n<p><em>“gene scores that measure the chromatin accessibility around each gene...”</em></p>\n</blockquote>\n<ul>\n<li>每个细胞对每个基因，计算其 <strong>转录起始位点（TSS）邻近区域的开放程度加权和</strong>，即基因周围的染色质可及性，距离越远的片段权重越低。</li>\n</ul>\n</li>\n<li>\n<p><strong>Peak–Barcode Matrix（峰 × 细胞矩阵）</strong></p>\n<blockquote>\n<p><em>“a peak–barcode matrix that quantifies the chromatin accessibility at consensus peaks...”</em></p>\n</blockquote>\n<ul>\n<li>构建一个 <strong>细胞 × 共识峰（peaks）</strong> 的矩阵，用于表示各细胞在特定基因组区域（peaks）上的染色质开放强度。</li>\n</ul>\n</li>\n<li>\n<p><strong>chromVAR Scores（转录因子活性分数）</strong></p>\n<blockquote>\n<p><em>“chromVAR scores, which quantify the activity of a set of transcription factors...”</em></p>\n</blockquote>\n<ul>\n<li>利用 <strong>chromVAR 工具</strong> 计算每个细胞中一组转录因子对应的 DNA footprint 区域的活性变化，用来反映转录因子的功能活性水平。</li>\n</ul>\n</li>\n<li>\n<p><strong>Marker Peaks（扰动标志峰）</strong></p>\n<blockquote>\n<p><em>“marker-peaks per perturbation target, which quantifies the differential regulation...”</em></p>\n</blockquote>\n<ul>\n<li>对每种扰动条件，识别出<strong>差异化活跃的高变峰（highly variable peaks）</strong>，作为该扰动的 “标志性染色质调控区域”。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h2 id=\"scrna-seq\"><a class=\"anchor\" href=\"#scrna-seq\">#</a> scRNA-seq</h2>\n<p>这段话讲的是：<strong>作者如何处理和标准化各个原始单细胞扰动数据集，以便进行统一分析。</strong></p>\n<p>下面是逐句解释：</p>\n<hr />\n<h3 id=\"1-起始数据来源与处理方式\"><a class=\"anchor\" href=\"#1-起始数据来源与处理方式\">#</a> 📌 1. <strong>起始数据来源与处理方式</strong></h3>\n<blockquote>\n<p><em>“Analysis was initiated using unfiltered, unnormalized cell-by-gene matrices as provided by source papers.”</em></p>\n</blockquote>\n<ul>\n<li>分析从<strong>原始文献提供的 cell-by-gene 矩阵</strong>（即细胞 × 基因的表达矩阵）开始；</li>\n<li>使用的是<strong>未经过滤或归一化的原始版本</strong>，确保保留最大的信息量，便于统一处理。</li>\n</ul>\n<hr />\n<h3 id=\"2-针对缺少处理后的数据集\"><a class=\"anchor\" href=\"#2-针对缺少处理后的数据集\">#</a> 📌 2. <strong>针对缺少处理后的数据集</strong></h3>\n<blockquote>\n<p><em>“For one dataset, preprocessed cell-by-gene matrices were unavailable...”</em></p>\n</blockquote>\n<ul>\n<li>有一个数据集并未公开处理好的表达矩阵；</li>\n<li>作者就<strong>按照原论文中描述的流程</strong>，<strong>使用原作者提供的代码</strong>自行进行预处理。</li>\n</ul>\n<hr />\n<h3 id=\"3-细胞条形码barcode处理\"><a class=\"anchor\" href=\"#3-细胞条形码barcode处理\">#</a> 📌 3. <strong>细胞条形码（barcode）处理</strong></h3>\n<blockquote>\n<p><em>“For datasets with cell barcodes, barcode assignments for cells were taken from the original paper when available...”</em></p>\n</blockquote>\n<ul>\n<li>\n<p>对于包含细胞条形码（即识别每个细胞身份）的数据集：</p>\n<ul>\n<li>如果原论文提供了 barcode 到细胞的映射，作者就<strong>直接采用原始提供的数据</strong>；</li>\n<li>如果没提供，就<strong>按原论文方法部分自行分配 barcode（详见方法部分）</strong>。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"4-处理同一细胞含多个引导序列guide的情况\"><a class=\"anchor\" href=\"#4-处理同一细胞含多个引导序列guide的情况\">#</a> 📌 4. <strong>处理同一细胞含多个引导序列（guide）的情况</strong></h3>\n<blockquote>\n<p><em>“If multiple guides were assigned to the same cell...”</em></p>\n</blockquote>\n<ul>\n<li>\n<p>如果一个细胞中检测到多个干预（例如多个 CRISPR guide RNA）：</p>\n<ul>\n<li>作者将这些 guide 按照<strong>计数从高到低的顺序排列</strong>，记录在最终的分析对象中；</li>\n<li>这样可以保留 “主要扰动” 的信息，同时也不完全丢失次要扰动。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"5-代码开放性\"><a class=\"anchor\" href=\"#5-代码开放性\">#</a> 📌 5. <strong>代码开放性</strong></h3>\n<blockquote>\n<p><em>“The code used to process each individual dataset... is available in our code repository.”</em></p>\n</blockquote>\n<ul>\n<li>作者将所有数据处理过程的代码（包括 barcode 分配）<strong>公开在他们的代码仓库中</strong>，确保透明和可复现。</li>\n</ul>\n<hr />\n<h2 id=\"e-distance\"><a class=\"anchor\" href=\"#e-distance\">#</a> E-distance</h2>\n<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo>∈</mo><msup><mi mathvariant=\"double-struck\">R</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">x_1,...,x_N \\in \\R^d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msub><mi>y</mi><mi>M</mi></msub><mo>∈</mo><msup><mi mathvariant=\"double-struck\">R</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">y_1,...,y_M \\in \\R^d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span> be samples from two distributions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X,Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, corresponding to two sets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> cells, respectively.</p>\n<p>We define :</p>\n\\begin{equation}\n\\delta_{XY} = \\frac{1}{NM}\\sum^N_{i=1}\\sum^M_{j=1}{||x_i-y_j||}\n\\end{equation}\n\\begin{equation}\n\\sigma_X =  \\frac{1}{N^2}\\sum^N_{i=1}\\sum^M_{j=1}{||x_i-y_j||}\n\\end{equation}\n<p>and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mi>Y</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">Y</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> defined accordingly.</p>\n<p>Intuitively, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>X</mi><mi>Y</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\delta_{XY}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the mean distance between cells from the two distributions, while <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> describes the mean distance between a cell from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> to another cell from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. The energy distance between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is defined as:</p>\n\\begin{equation}\nE(X,Y):=2\\delta_{XY}-\\sigma_X-\\sigma_Y \n\\end{equation}\n<p>For the bias-corrected energy distance, we define</p>\n\\begin{equation}\n\\sigma_X =  \\frac{1}{N(N-1)}\\sum^N_{i=1}\\sum^M_{j=1}{||x_i-y_j||}\n\\end{equation}\n<p>这比原来的 $\\frac<ruby>1}{N<rp>(</rp><rt>2</rt><rp>)</rp></ruby>，因为：</p>\n<p>原公式包含了自己和自己的距离<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">||x_i-x_i||=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span></p>\n<p>而修正版本只考虑不同的样本对，避免了系统性低估组内变异性；</p>\n<p>修正后更适用于小样本（如每个扰动只有几十或几百个细胞）的情况。</p>\n<h2 id=\"e-test-calculation\"><a class=\"anchor\" href=\"#e-test-calculation\">#</a> E-test calculation</h2>\n<p>E 检验（E-test）作为一种 Monte Carlo 置换检验，以能量距离（E-distance）作为检验统计量进行实施。对于每个数据集中的每一个扰动条件，我们将该扰动组的细胞与未扰动对照组的细胞合并，然后随机打乱扰动标签，将细胞重新分为两组，并计算这两组之间的 E-distance。我们将这一过程重复 10,000 次。在这 10,000 次中，打乱标签后计算得到的 E-distance 大于原始未打乱标签所得到的 E-distance 的次数，除以 10,000，即得到了对应的 P 值，该值表示一个 单边检验（one-sided test） 的显著性水平。我们为本资源中几乎所有的数据集都报告了该检验的结果（见补充表 3）。</p>\n<p>对于每个数据集中的多重假设检验，我们采用 Holm–Sidak 方法 进行多重比较校正。</p>\n",
            "tags": [
                "论文",
                "生物",
                "学习笔记类",
                "算法"
            ]
        },
        {
            "id": "http://amentiraz.github.io/other/2025-4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/",
            "url": "http://amentiraz.github.io/other/2025-4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/",
            "title": "2025-4工作总结",
            "date_published": "2025-05-06T06:36:14.000Z",
            "content_html": "<p>对 2025 年 4 月的工作进行总结</p>\n<span id=\"more\"></span>\n<p>本月主要在完成毕业设计论文，部分文章的阅读与复现，系统学习生物信息学涉及到的一些 python 库。以下是具体的情况。</p>\n<p>一、 完成毕业设计论文<br />\n在完成毕业设计论文的过程中，对于部分概念以及部分数据集进行了梳理。</p>\n<p>首先针对我阅读过的文章，例如 BayesSpace、SpaGCN、STAGATE 等文章对于研究背景以及空间域的概念进行了梳理归纳并且整理成了文档，方便论文书写过程资料的收集与获取。其次对于这些论文具体的方法进行了回顾与归纳，明晰了之前阅读比较粗浅的在 BayesSpace 这篇论文中的概念，并重新对方法进行了认识。并且对于 BayesSpace、SpaGCN、STAGATE 这三篇论文的方法在论文中进行了总结。同时我也学习了对于 Leiden 和 Louvain 算法它们的具体实现方法和原理，并针对已有的数据集完成了复现。此外，对于评价指标也更深入的进行了了解。</p>\n<p>在数据方面，我对于各类数据集进行了更深入的了解，理解了各个数据集所代表的空间技术是什么，怎么去查看他们的样本数量、基因数量以及计算它们的稀疏性。特别的，对于小鼠嗅球数据进行了收集，并且学习了它的组织结构并且初步对于它的空间域划分结合组织学图像进行了描述；同时收集了 BARISTAseq 数据，这个数据集在各个模型上表现都不错，以后可以使用。</p>\n<p>二、 文章的阅读与复现<br />\n本月主要是对于 ENSDD 这篇论文进行了阅读与复现，收集了它对应的 Human Breast Cancer 数据并以此做了复现。了解了 R 语言中调用 Python 库的操作，并且深入了解了它的代码实验原理并且做了总结，汇总成文档。</p>\n<p>特别的对于这篇论文的核心函数，我进行了推到，粗浅的理解了在线性代数中对于矩阵求偏导的流程，并且对其进行了总结，同时对照代码进行了验证。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/2025-4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%931.png\" alt=\"\" /><br />\n目前复现的进展接近尾声，对于基因相关的 tutorial 还需要理解。</p>\n<p>三、 系统学习生物信息学涉及到的一些 python 库</p>\n<p>由于认识到自身对于 python 代码的书写还处于一种零散的，不成系统的情况，所以去系统学习了 Numpy、pandas 和 Anndata 相关库的函数和操作，并且汇总成了文档以便查阅。具体而言针对 AnnData 数据，我系统的了解了它的各个模块的结构，如何利用 pandas 和 numpy 的函数对其操作，并且学习了例如如何处理大规模数据，如何创建稀疏矩阵等操作。</p>\n<p>四、 后面工作的安排</p>\n<p>（1）阅读整理完 EnSDD 这篇文章，并且在组会前完成 ppt 等相关工作的整理。<br />\n（2）阅读其它的文献，例如《scPerturb: harmonized single-cell perturbation data》并且结合自身情况继续阅读其它文献<br />\n（3）继续整理 python 相关的操作，并且可以适当回顾以前文章是怎么利用这些操作形成方法的。<br />\n（4）完成毕业设计相关内容。</p>\n",
            "tags": [
                "其它",
                "工作总结",
                "工作总结",
                "生物信息学"
            ]
        },
        {
            "id": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python4/",
            "url": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python4/",
            "title": "系统学习python（四）对于Scanpy的整理",
            "date_published": "2025-05-05T03:20:06.000Z",
            "content_html": "<p>接着上文继续学习 Scanpy 的相关语法 ，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zY2FucHktdHV0b3JpYWxzLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC9iYXNpYy1zY3JuYS10dXRvcmlhbC5odG1s\">参考网页</span></p>\n<span id=\"more\"></span>\n<h1 id=\"preprocessing-and-clustering\"><a class=\"anchor\" href=\"#preprocessing-and-clustering\">#</a> Preprocessing and clustering</h1>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scanpy <span class=\"keyword\">as</span> sc</span><br><span class=\"line\"><span class=\"keyword\">import</span> anndata <span class=\"keyword\">as</span> ad</span><br><span class=\"line\"></span><br><span class=\"line\">sc.settings.set_figure_params(dpi=<span class=\"number\">50</span>, facecolor=<span class=\"string\">&quot;white&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># EXAMPLE_DATA = pooch.create(</span></span><br><span class=\"line\"><span class=\"comment\">#    path=pooch.os_cache(&quot;scverse_tutorials&quot;),</span></span><br><span class=\"line\"><span class=\"comment\">#    base_url=&quot;doi:10.6084/m9.figshare.22716739.v1/&quot;,</span></span><br><span class=\"line\"><span class=\"comment\"># )</span></span><br><span class=\"line\"><span class=\"comment\"># EXAMPLE_DATA.load_registry_from_doi()</span></span><br><span class=\"line\"></span><br><span class=\"line\">samples = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;s1d1&quot;</span>: <span class=\"string\">&quot;D:\\\\articleCode\\\\research\\\\s1d1_filtered_feature_bc_matrix.h5&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;s1d3&quot;</span>: <span class=\"string\">&quot;D:\\\\articleCode\\\\research\\\\s1d3_filtered_feature_bc_matrix.h5&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">adatas = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> sample_id, path <span class=\"keyword\">in</span> samples.items():</span><br><span class=\"line\">    sample_adata = sc.read_10x_h5(path)</span><br><span class=\"line\">    sample_adata.var_names_make_unique()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(sample_adata)</span><br><span class=\"line\">    adatas[sample_id] = sample_adata</span><br><span class=\"line\"></span><br><span class=\"line\">adata = ad.concat(adatas, label=<span class=\"string\">&quot;sample&quot;</span>)</span><br><span class=\"line\">adata.obs_names_make_unique()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata.obs[<span class=\"string\">&quot;sample&quot;</span>].value_counts())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata)</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "代码",
                "python",
                "学习笔记",
                "python"
            ]
        },
        {
            "id": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python3/",
            "url": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python3/",
            "title": "系统学习python（三）对于Anndata的整理",
            "date_published": "2025-05-04T08:51:40.000Z",
            "content_html": "<p>接着上文继续学习 Anndata 的相关语法，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbm5kYXRhLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC90dXRvcmlhbHMvbm90ZWJvb2tzL2dldHRpbmctc3RhcnRlZC5odG1s\"> 参考网页</span></p>\n<span id=\"more\"></span>\n<p><code>AnnData</code>  is specifically designed for matrix-like data. By this we mean that we have  <code>n</code> observations, each of which can be represented as  <code>d</code> -dimensional vectors, where each dimension corresponds to a variable or feature. Both the rows and columns of this <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>×</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">n \\times d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> matrix are special in the sense that they are indexed.</p>\n<p>For instance, in scRNA-seq data, each row corresponds to a cell with a barcode, and each column corresponds to a gene with a gene id. Furthermore, for each cell and each gene we might have additional metadata, like (1) donor information for each cell, or (2) alternative gene symbols for each gene.</p>\n<h1 id=\"initializing-anndata\"><a class=\"anchor\" href=\"#initializing-anndata\">#</a> Initializing AnnData</h1>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">counts = csr_matrix(np.random.poisson(<span class=\"number\">1</span>, size=(<span class=\"number\">100</span>, <span class=\"number\">2000</span>)), dtype=np.float32)</span><br><span class=\"line\"><span class=\"comment\"># 生成一个参数为1的泊松分布的稀疏矩阵</span></span><br><span class=\"line\">adata = ad.AnnData(counts)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata)</span><br><span class=\"line\"></span><br><span class=\"line\">adata.obs_names = [<span class=\"string\">f&quot;Cell_<span class=\"subst\">&#123;i:d&#125;</span>&quot;</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(adata.n_obs)]</span><br><span class=\"line\">adata.var_names = [<span class=\"string\">f&quot;Gene_<span class=\"subst\">&#123;i:d&#125;</span>&quot;</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(adata.n_vars)]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata.obs_names)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata[[<span class=\"string\">&quot;Cell_1&quot;</span>, <span class=\"string\">&quot;Cell_10&quot;</span>], [<span class=\"string\">&quot;Gene_5&quot;</span>, <span class=\"string\">&quot;Gene_1900&quot;</span>]])</span><br></pre></td></tr></table></figure>\n<h1 id=\"adding-aligned-metadata\"><a class=\"anchor\" href=\"#adding-aligned-metadata\">#</a> Adding aligned metadata</h1>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ct = np.random.choice([<span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;T&quot;</span>, <span class=\"string\">&quot;Monocyte&quot;</span>], size=(adata.n_obs))</span><br><span class=\"line\">adata.obs[<span class=\"string\">&quot;cell_type&quot;</span>] = pd.Categorical(ct)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata.obs)</span><br><span class=\"line\"></span><br><span class=\"line\">bdata = adata[adata.obs.cell_type == <span class=\"string\">&quot;B&quot;</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(bdata)</span><br></pre></td></tr></table></figure>\n<h1 id=\"observation-variable-level-matrices\"><a class=\"anchor\" href=\"#observation-variable-level-matrices\">#</a> Observation / variable-level matrices</h1>\n<p>We might also have metadata at either level that has many dimensions to it, such as a  <code>UMAP</code>  embedding of the data. For this type of metadata, AnnData has the  <code>.obsm/.varm</code>  attributes. We use keys to identify the different matrices we insert. The restriction of  <code>.obsm/.varm</code>  are that  <code>.obsm</code>  matrices must length equal to the number of observations as .n_obs and  <code>.varm</code>  matrices must length equal to  <code>.n_vars</code> . They can each independently have different number of dimensions.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata.obsm[<span class=\"string\">&quot;X_umap&quot;</span>] = np.random.normal(<span class=\"number\">0</span>,<span class=\"number\">1</span>,size=(adata.n_obs,<span class=\"number\">2</span>))</span><br><span class=\"line\">adata.varm[<span class=\"string\">&quot;gene_stuff&quot;</span>] = np.random.normal(<span class=\"number\">0</span>,<span class=\"number\">1</span>,size=(adata.n_vars,<span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata)</span><br></pre></td></tr></table></figure>\n<p>A few more notes about  <code>.obsm/.varm</code></p>\n<ul>\n<li>\n<p>The “array-like” metadata can originate from a Pandas DataFrame, scipy sparse matrix, or numpy dense array.</p>\n</li>\n<li>\n<p>When using scanpy, their values (columns) are not easily plotted, where instead items from .obs are easily plotted on, e.g., UMAP plots.</p>\n</li>\n</ul>\n<h1 id=\"unstructured-metadata\"><a class=\"anchor\" href=\"#unstructured-metadata\">#</a> Unstructured metadata</h1>\n<p>AnnData has  <code>.uns</code> , which allows for any unstructured metadata. This can be anything, like a list or a dictionary with some general information that was useful in the analysis of our data.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata.uns[<span class=\"string\">&quot;random&quot;</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">adata.uns</span><br></pre></td></tr></table></figure>\n<h1 id=\"layers\"><a class=\"anchor\" href=\"#layers\">#</a> Layers</h1>\n<p>Finally, we may have different forms of our original core data, perhaps one that is normalized and one that is not. These can be stored in different layers in AnnData. For example, let’s log transform the original data and store it in a layer:</p>\n<h1 id=\"conversion-to-dataframe\"><a class=\"anchor\" href=\"#conversion-to-dataframe\">#</a> Conversion to DataFrame</h1>\n<p>We can also ask AnnData to return us a DataFrame from one of the layers:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata.to_df(layer=<span class=\"string\">&quot;log_transformed&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>We see that the .obs_names/.var_names are used in the creation of this Pandas object.</p>\n<h1 id=\"writing-the-results-to-disk\"><a class=\"anchor\" href=\"#writing-the-results-to-disk\">#</a> Writing the results to disk</h1>\n<p>AnnData comes with its own persistent HDF5-based file format: h5ad. If string columns with small number of categories aren’t yet categoricals, AnnData will auto-transform to categoricals.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata.write(<span class=\"string\">&#x27;my_results.h5ad&#x27;</span>, compression=<span class=\"string\">&quot;gzip&quot;</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"views-and-copies\"><a class=\"anchor\" href=\"#views-and-copies\">#</a> Views and copies</h1>\n<p>Imagine that the observations come from instruments characterizing 10 readouts in a multi-year study with samples taken from different subjects at different sites. We’d typically get that information in some format and then store it in a DataFrame:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obs_meta = pd.DataFrame(&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;time_yr&#x27;</span>: np.random.choice([<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>], adata.n_obs),</span><br><span class=\"line\">        <span class=\"string\">&#x27;subject_id&#x27;</span>: np.random.choice([<span class=\"string\">&#x27;subject 1&#x27;</span>, <span class=\"string\">&#x27;subject 2&#x27;</span>, <span class=\"string\">&#x27;subject 4&#x27;</span>, <span class=\"string\">&#x27;subject 8&#x27;</span>], adata.n_obs),</span><br><span class=\"line\">        <span class=\"string\">&#x27;instrument_type&#x27;</span>: np.random.choice([<span class=\"string\">&#x27;type a&#x27;</span>, <span class=\"string\">&#x27;type b&#x27;</span>], adata.n_obs),</span><br><span class=\"line\">        <span class=\"string\">&#x27;site&#x27;</span>: np.random.choice([<span class=\"string\">&#x27;site x&#x27;</span>, <span class=\"string\">&#x27;site y&#x27;</span>], adata.n_obs),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    index=adata.obs.index,    <span class=\"comment\"># these are the same IDs of observations as above!</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>This is how we join the readout data with the metadata. Of course, the first argument of the following call for X could also just be a DataFrame.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata = ad.AnnData(adata.X, obs=obs_meta, var=adata.var)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># View</span></span><br><span class=\"line\">adata[:<span class=\"number\">5</span>, [<span class=\"string\">&quot;Gene_1&quot;</span>, <span class=\"string\">&quot;Gene_3&quot;</span>]]</span><br><span class=\"line\"><span class=\"comment\"># .toarray()表示转换为稠密的 NumPy数组，.tolist()表示转换成Python列表，方便查看</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata[:<span class=\"number\">3</span>, <span class=\"string\">&quot;Gene_1&quot;</span>].X.toarray().tolist())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata[:<span class=\"number\">3</span>, <span class=\"string\">&quot;Gene_1&quot;</span>].X.toarray())</span><br><span class=\"line\">adata[:<span class=\"number\">3</span>, <span class=\"string\">&quot;Gene_1&quot;</span>].X = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adata[:<span class=\"number\">3</span>, <span class=\"string\">&quot;Gene_1&quot;</span>].X.toarray().tolist())</span><br><span class=\"line\"><span class=\"comment\"># Copy</span></span><br><span class=\"line\">adata_subset = adata[:<span class=\"number\">5</span>, [<span class=\"string\">&quot;Gene_1&quot;</span>, <span class=\"string\">&quot;Gene_3&quot;</span>]].copy()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"partial-reading-of-large-data\"><a class=\"anchor\" href=\"#partial-reading-of-large-data\">#</a> Partial reading of large data</h1>\n<p>If a single  <code>.h5ad</code>  is very large, you can partially read it into memory by using backed mode:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata = ad.read(<span class=\"string\">&#x27;my_results.h5ad&#x27;</span>, backed=<span class=\"string\">&#x27;r&#x27;</span>)</span><br><span class=\"line\">adata.isbacked</span><br></pre></td></tr></table></figure>\n<p>If you do this, you’ll need to remember that the AnnData object has an open connection to the file used for reading:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata.filename</span><br><span class=\"line\">PosixPath(<span class=\"string\">&#x27;my_results.h5ad&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>As we’re using it in read-only mode, we can’t damage anything. To proceed with this tutorial, we still need to explicitly close it:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adata.file.close()</span><br></pre></td></tr></table></figure>\n<p>As usual, you should rather use with statements to avoid dangling open files (up-coming feature).</p>\n<p>Manipulating the object on disk is possible, but experimental for sparse data. Hence, we leave it out of this tutorial.</p>\n<p>上面包含了一些非常基础的操作，考虑到时间关系和后面的内容有些难，我先去学习一下 scanpy 的操作流程</p>\n",
            "tags": [
                "代码",
                "python",
                "学习笔记",
                "python"
            ]
        },
        {
            "id": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python2/",
            "url": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python2/",
            "title": "系统学习python（二）对于pandas的整理",
            "date_published": "2025-05-03T10:15:08.000Z",
            "content_html": "<p>接着上文继续学习 pandas 的相关语法</p>\n<span id=\"more\"></span>\n<p>简单的 pandas 实例</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个简单的 DataFrame</span></span><br><span class=\"line\">data = &#123;<span class=\"string\">&#x27;Name&#x27;</span>: [<span class=\"string\">&#x27;Google&#x27;</span>, <span class=\"string\">&#x27;Runoob&#x27;</span>, <span class=\"string\">&#x27;Taobao&#x27;</span>], <span class=\"string\">&#x27;Age&#x27;</span>: [<span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>]&#125;</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 DataFrame</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df)</span><br></pre></td></tr></table></figure>\n<p>可以使用 pd.Series () 构造函数创建一个 Series 对象，传递一个数据数组（可以是列表、NumPy 数组等）和一个可选的索引数组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pandas.Series(data=<span class=\"literal\">None</span>, index=<span class=\"literal\">None</span>, dtype=<span class=\"literal\">None</span>, name=<span class=\"literal\">None</span>, copy=<span class=\"literal\">False</span>, fastpath=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>data：Series 的数据部分，可以是列表、数组、字典、标量值等。如果不提供此参数，则创建一个空的 Series。</li>\n<li>index：Series 的索引部分，用于对数据进行标记。可以是列表、数组、索引对象等。如果不提供此参数，则创建一个默认的整数索引。</li>\n<li>dtype：指定 Series 的数据类型。可以是 NumPy 的数据类型，例如 np.int64、np.float64 等。如果不提供此参数，则根据数据自动推断数据类型。</li>\n<li>name：Series 的名称，用于标识 Series 对象。如果提供了此参数，则创建的 Series 对象将具有指定的名称。</li>\n<li>copy：是否复制数据。默认为 False，表示不复制数据。如果设置为 True，则复制输入的数据。</li>\n<li>fastpath：是否启用快速路径。默认为 False。启用快速路径可能会在某些情况下提高性能。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series = pd.Series([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], name=<span class=\"string\">&quot;A&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(series)</span><br><span class=\"line\"></span><br><span class=\"line\">custom_index = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">series_with_index = pd.Series([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], index=custom_index, name=<span class=\"string\">&quot;A&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(series_with_index)</span><br><span class=\"line\"></span><br><span class=\"line\">myvar = pd.Series([<span class=\"string\">&quot;Google&quot;</span>,<span class=\"string\">&quot;Runoob&quot;</span>,<span class=\"string\">&quot;Wiki&quot;</span>],index=[<span class=\"string\">&#x27;x&#x27;</span>,<span class=\"string\">&#x27;y&#x27;</span>,<span class=\"string\">&#x27;z&#x27;</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(myvar[<span class=\"string\">&#x27;x&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">sites = &#123;<span class=\"number\">1</span>:<span class=\"string\">&quot;Google&quot;</span>,<span class=\"number\">2</span>:<span class=\"string\">&quot;Runoob&quot;</span>,<span class=\"number\">3</span>:<span class=\"string\">&quot;Wiki&quot;</span>&#125;</span><br><span class=\"line\">myvar = pd.Series(sites)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(myvar)</span><br></pre></td></tr></table></figure>\n<p>下面是 Series 常用的方法：</p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>index</td>\n<td>获取 Series 的索引</td>\n</tr>\n<tr>\n<td>values</td>\n<td>获取 Series 的数据部分（返回 NumPy 数组）</td>\n</tr>\n<tr>\n<td>head(n)</td>\n<td>返回 Series 的前 n 行（默认为 5）</td>\n</tr>\n<tr>\n<td>tail(n)</td>\n<td>返回 Series 的后 n 行（默认为 5）</td>\n</tr>\n<tr>\n<td>dtype</td>\n<td>返回 Series 中数据的类型</td>\n</tr>\n<tr>\n<td>shape</td>\n<td>返回 Series 的形状（行数）</td>\n</tr>\n<tr>\n<td>describe()</td>\n<td>返回 Series 的统计描述（如均值、标准差、最小值等）</td>\n</tr>\n<tr>\n<td>isnull()</td>\n<td>返回一个布尔 Series，表示每个元素是否为 NaN</td>\n</tr>\n<tr>\n<td>notnull()</td>\n<td>返回一个布尔 Series，表示每个元素是否不是 NaN</td>\n</tr>\n<tr>\n<td>unique()</td>\n<td>返回 Series 中的唯一值（去重）</td>\n</tr>\n<tr>\n<td>value_counts()</td>\n<td>返回 Series 中每个唯一值的出现次数</td>\n</tr>\n<tr>\n<td>map(func)</td>\n<td>将指定函数应用于 Series 中的每个元素</td>\n</tr>\n<tr>\n<td>apply(func)</td>\n<td>将指定函数应用于 Series 中的每个元素，常用于自定义操作</td>\n</tr>\n<tr>\n<td>astype(dtype)</td>\n<td>将 Series 转换为指定的类型</td>\n</tr>\n<tr>\n<td>sort_values()</td>\n<td>对 Series 中的元素进行排序（按值排序）</td>\n</tr>\n<tr>\n<td>sort_index()</td>\n<td>对 Series 的索引进行排序</td>\n</tr>\n<tr>\n<td>dropna()</td>\n<td>删除 Series 中的缺失值（NaN）</td>\n</tr>\n<tr>\n<td>fillna(value)</td>\n<td>填充 Series 中的缺失值（NaN）</td>\n</tr>\n<tr>\n<td>replace(to_replace, value)</td>\n<td>替换 Series 中指定的值</td>\n</tr>\n<tr>\n<td>cumsum()</td>\n<td>返回 Series 的累计求和</td>\n</tr>\n<tr>\n<td>cumprod()</td>\n<td>返回 Series 的累计乘积</td>\n</tr>\n<tr>\n<td>shift(periods)</td>\n<td>将 Series 中的元素按指定的步数进行位移</td>\n</tr>\n<tr>\n<td>rank()</td>\n<td>返回 Series 中元素的排名</td>\n</tr>\n<tr>\n<td>corr(other)</td>\n<td>计算 Series 与另一个 Series 的相关性（皮尔逊相关系数）</td>\n</tr>\n<tr>\n<td>cov(other)</td>\n<td>计算 Series 与另一个 Series 的协方差</td>\n</tr>\n<tr>\n<td>to_list()</td>\n<td>将 Series 转换为 Python 列表</td>\n</tr>\n<tr>\n<td>to_frame()</td>\n<td>将 Series 转换为 DataFrame</td>\n</tr>\n<tr>\n<td>iloc[]</td>\n<td>通过位置索引来选择数据</td>\n</tr>\n<tr>\n<td>loc[]</td>\n<td>通过标签索引来选择数据</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建 Series</span></span><br><span class=\"line\">data = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\">index = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;f&#x27;</span>]</span><br><span class=\"line\">s = pd.Series(data, index=index)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看基本信息</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;索引：&quot;</span>, s.index)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数据：&quot;</span>, s.values)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数据类型：&quot;</span>, s.dtype)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;前两行数据：&quot;</span>, s.head(<span class=\"number\">2</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 map 函数将每个元素加倍</span></span><br><span class=\"line\">s_doubled = s.<span class=\"built_in\">map</span>(<span class=\"keyword\">lambda</span> x: x * <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;元素加倍后：&quot;</span>, s_doubled)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算累计和</span></span><br><span class=\"line\">cumsum_s = s.cumsum()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;累计求和：&quot;</span>, cumsum_s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查找缺失值（这里没有缺失值，所以返回的全是 False）</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;缺失值判断：&quot;</span>, s.isnull())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 排序</span></span><br><span class=\"line\">sorted_s = s.sort_values()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;排序后的 Series：&quot;</span>, sorted_s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用列表创建 Series</span></span><br><span class=\"line\">s = pd.Series([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 NumPy 数组创建 Series</span></span><br><span class=\"line\">s = pd.Series(np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用字典创建 Series</span></span><br><span class=\"line\">s = pd.Series(&#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"number\">2</span>, <span class=\"string\">&#x27;c&#x27;</span>: <span class=\"number\">3</span>, <span class=\"string\">&#x27;d&#x27;</span>: <span class=\"number\">4</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 算术运算</span></span><br><span class=\"line\">result = series * <span class=\"number\">2</span>  <span class=\"comment\"># 所有元素乘以2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 过滤</span></span><br><span class=\"line\">filtered_series = series[series &gt; <span class=\"number\">2</span>]  <span class=\"comment\"># 选择大于2的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 数学函数</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\">result = np.sqrt(series)  <span class=\"comment\"># 对每个元素取平方根</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.<span class=\"built_in\">sum</span>())  <span class=\"comment\"># 输出 Series 的总和</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.mean())  <span class=\"comment\"># 输出 Series 的平均值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.<span class=\"built_in\">max</span>())  <span class=\"comment\"># 输出 Series 的最大值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.<span class=\"built_in\">min</span>())  <span class=\"comment\"># 输出 Series 的最小值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.std())  <span class=\"comment\"># 输出 Series 的标准差</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取索引</span></span><br><span class=\"line\">index = s.index</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取值数组</span></span><br><span class=\"line\">values = s.values</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取描述统计信息</span></span><br><span class=\"line\">stats = s.describe()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取最大值和最小值的索引</span></span><br><span class=\"line\">max_index = s.idxmax()</span><br><span class=\"line\">min_index = s.idxmin()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 其他属性和方法</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.dtype)   <span class=\"comment\"># 数据类型</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.shape)   <span class=\"comment\"># 形状</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.size)    <span class=\"comment\"># 元素个数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.head())  <span class=\"comment\"># 前几个元素，默认是前 5 个</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.tail())  <span class=\"comment\"># 后几个元素，默认是后 5 个</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.<span class=\"built_in\">sum</span>())   <span class=\"comment\"># 求和</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.mean())  <span class=\"comment\"># 平均值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.std())   <span class=\"comment\"># 标准差</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.<span class=\"built_in\">min</span>())   <span class=\"comment\"># 最小值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s.<span class=\"built_in\">max</span>())   <span class=\"comment\"># 最大值</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"dataframe\"><a class=\"anchor\" href=\"#dataframe\">#</a> DataFrame</h1>\n<p>DataFrame 的构造方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pandas.DataFrame(data=<span class=\"literal\">None</span>, index=<span class=\"literal\">None</span>, columns=<span class=\"literal\">None</span>, dtype=<span class=\"literal\">None</span>, copy=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>data：DataFrame 的数据部分，可以是字典、二维数组、Series、DataFrame 或其他可转换为 DataFrame 的对象。如果不提供此参数，则创建一个空的 DataFrame。</li>\n<li>index：DataFrame 的行索引，用于标识每行数据。可以是列表、数组、索引对象等。如果不提供此参数，则创建一个默认的整数索引。</li>\n<li>columns：DataFrame 的列索引，用于标识每列数据。可以是列表、数组、索引对象等。如果不提供此参数，则创建一个默认的整数索引。</li>\n<li>dtype：指定 DataFrame 的数据类型。可以是 NumPy 的数据类型，例如 np.int64、np.float64 等。如果不提供此参数，则根据数据自动推断数据类型。</li>\n<li>copy：是否复制数据。默认为 False，表示不复制数据。如果设置为 True，则复制输入的数据。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\">data = &#123;<span class=\"string\">&#x27;Site&#x27;</span>:[<span class=\"string\">&#x27;Google&#x27;</span>, <span class=\"string\">&#x27;Runoob&#x27;</span>, <span class=\"string\">&#x27;Wiki&#x27;</span>], <span class=\"string\">&#x27;Age&#x27;</span>:[<span class=\"number\">10</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>]&#125;</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (df)<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\">data = [[<span class=\"string\">&#x27;Google&#x27;</span>, <span class=\"number\">10</span>], [<span class=\"string\">&#x27;Runoob&#x27;</span>, <span class=\"number\">12</span>], [<span class=\"string\">&#x27;Wiki&#x27;</span>, <span class=\"number\">13</span>]]</span><br><span class=\"line\"><span class=\"comment\"># 创建DataFrame</span></span><br><span class=\"line\">df = pd.DataFrame(data, columns=[<span class=\"string\">&#x27;Site&#x27;</span>, <span class=\"string\">&#x27;Age&#x27;</span>])</span><br><span class=\"line\"><span class=\"comment\"># 使用astype方法设置每列的数据类型</span></span><br><span class=\"line\">df[<span class=\"string\">&#x27;Site&#x27;</span>] = df[<span class=\"string\">&#x27;Site&#x27;</span>].astype(<span class=\"built_in\">str</span>)</span><br><span class=\"line\">df[<span class=\"string\">&#x27;Age&#x27;</span>] = df[<span class=\"string\">&#x27;Age&#x27;</span>].astype(<span class=\"built_in\">float</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(df)</span><br><span class=\"line\"></span><br><span class=\"line\">data = &#123;<span class=\"string\">&#x27;Site&#x27;</span>:[<span class=\"string\">&#x27;Google&#x27;</span>, <span class=\"string\">&#x27;Runoob&#x27;</span>, <span class=\"string\">&#x27;Wiki&#x27;</span>], <span class=\"string\">&#x27;Age&#x27;</span>:[<span class=\"number\">10</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>]&#125;</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (df)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个包含网站和年龄的二维ndarray</span></span><br><span class=\"line\">ndarray_data = np.array([</span><br><span class=\"line\">    [<span class=\"string\">&#x27;Google&#x27;</span>, <span class=\"number\">10</span>],</span><br><span class=\"line\">    [<span class=\"string\">&#x27;Runoob&#x27;</span>, <span class=\"number\">12</span>],</span><br><span class=\"line\">    [<span class=\"string\">&#x27;Wiki&#x27;</span>, <span class=\"number\">13</span>]</span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"comment\"># 使用DataFrame构造函数创建数据帧</span></span><br><span class=\"line\">df = pd.DataFrame(ndarray_data, columns=[<span class=\"string\">&#x27;Site&#x27;</span>, <span class=\"string\">&#x27;Age&#x27;</span>])</span><br><span class=\"line\"><span class=\"comment\"># 打印数据帧</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df)</span><br><span class=\"line\">data = [&#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"number\">2</span>&#125;,&#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">5</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"number\">10</span>, <span class=\"string\">&#x27;c&#x27;</span>: <span class=\"number\">20</span>&#125;]</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (df)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;calories&quot;</span>: [<span class=\"number\">420</span>, <span class=\"number\">380</span>, <span class=\"number\">390</span>],</span><br><span class=\"line\">  <span class=\"string\">&quot;duration&quot;</span>: [<span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">45</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 数据载入到 DataFrame 对象</span></span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"><span class=\"comment\"># 返回第一行和第二行</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.loc[[<span class=\"number\">0</span>, <span class=\"number\">1</span>]])</span><br></pre></td></tr></table></figure>\n<p>DataFrame 的常用操作和方法如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>head(n)</td>\n<td>返回 DataFrame 的前 n 行数据（默认前 5 行）</td>\n</tr>\n<tr>\n<td>tail(n)</td>\n<td>返回 DataFrame 的后 n 行数据（默认后 5 行）</td>\n</tr>\n<tr>\n<td>info()</td>\n<td>显示 DataFrame 的简要信息，包括列名、数据类型、非空值数量等</td>\n</tr>\n<tr>\n<td>describe()</td>\n<td>返回 DataFrame 数值列的统计信息，如均值、标准差、最小值等</td>\n</tr>\n<tr>\n<td>shape</td>\n<td>返回 DataFrame 的行数和列数（行数，列数）</td>\n</tr>\n<tr>\n<td>columns</td>\n<td>返回 DataFrame 的所有列名</td>\n</tr>\n<tr>\n<td>index</td>\n<td>返回 DataFrame 的行索引</td>\n</tr>\n<tr>\n<td>dtypes</td>\n<td>返回每一列的数值数据类型</td>\n</tr>\n<tr>\n<td>sort_values(by)</td>\n<td>按照指定列排序</td>\n</tr>\n<tr>\n<td>sort_index()</td>\n<td>按行索引排序</td>\n</tr>\n<tr>\n<td>dropna()</td>\n<td>删除含有缺失值（NaN）的行或列</td>\n</tr>\n<tr>\n<td>fillna(value)</td>\n<td>用指定的值填充缺失值</td>\n</tr>\n<tr>\n<td>isnull()</td>\n<td>判断缺失值，返回一个布尔值 DataFrame</td>\n</tr>\n<tr>\n<td>notnull()</td>\n<td>判断非缺失值，返回一个布尔值 DataFrame</td>\n</tr>\n<tr>\n<td>loc[]</td>\n<td>按标签索引选择数据</td>\n</tr>\n<tr>\n<td>iloc[]</td>\n<td>按位置索引选择数据</td>\n</tr>\n<tr>\n<td>at[]</td>\n<td>访问 DataFrame 中单个元素（比 loc [] 更高效）</td>\n</tr>\n<tr>\n<td>iat[]</td>\n<td>访问 DataFrame 中单个元素（比 iloc [] 更高效）</td>\n</tr>\n<tr>\n<td>apply(func)</td>\n<td>对 DataFrame 或 Series 应用一个函数</td>\n</tr>\n<tr>\n<td>applymap(func)</td>\n<td>对 DataFrame 的每个元素应用函数（仅对 DataFrame）</td>\n</tr>\n<tr>\n<td>groupby(by)</td>\n<td>分组操作，用于按某一列分组进行汇总统计</td>\n</tr>\n<tr>\n<td>pivot_table()</td>\n<td>创建透视表</td>\n</tr>\n<tr>\n<td>merge()</td>\n<td>合并多个 DataFrame（类似 SQL 的 JOIN 操作）</td>\n</tr>\n<tr>\n<td>concat()</td>\n<td>按行或按列连接多个 DataFrame</td>\n</tr>\n<tr>\n<td>to_csv()</td>\n<td>将 DataFrame 导出为 CSV 文件</td>\n</tr>\n<tr>\n<td>to_excel()</td>\n<td>将 DataFrame 导出为 Excel 文件</td>\n</tr>\n<tr>\n<td>to_json()</td>\n<td>将 DataFrame 导出为 JSON 格式</td>\n</tr>\n<tr>\n<td>to_sql()</td>\n<td>将 DataFrame 导出为 SQL 数据库</td>\n</tr>\n<tr>\n<td>query()</td>\n<td>使用 SQL 风格的语法查询 DataFrame</td>\n</tr>\n<tr>\n<td>duplicated()</td>\n<td>返回布尔值 DataFrame，指示每行是否是重复的</td>\n</tr>\n<tr>\n<td>drop_duplicates()</td>\n<td>删除重复的行</td>\n</tr>\n<tr>\n<td>set_index()</td>\n<td>设置 DataFrame 的索引</td>\n</tr>\n<tr>\n<td>reset_index()</td>\n<td>重置 DataFrame 的索引</td>\n</tr>\n<tr>\n<td>transpose()</td>\n<td>转置 DataFrame（行列交换）</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建 DataFrame</span></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;Name&#x27;</span>: [<span class=\"string\">&#x27;Alice&#x27;</span>, <span class=\"string\">&#x27;Bob&#x27;</span>, <span class=\"string\">&#x27;Charlie&#x27;</span>, <span class=\"string\">&#x27;David&#x27;</span>],</span><br><span class=\"line\">    <span class=\"string\">&#x27;Age&#x27;</span>: [<span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>],</span><br><span class=\"line\">    <span class=\"string\">&#x27;City&#x27;</span>: [<span class=\"string\">&#x27;New York&#x27;</span>, <span class=\"string\">&#x27;Los Angeles&#x27;</span>, <span class=\"string\">&#x27;Chicago&#x27;</span>, <span class=\"string\">&#x27;Houston&#x27;</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看前两行数据</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.head(<span class=\"number\">2</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 DataFrame 的基本信息</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.info())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取描述统计信息</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.describe())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按年龄排序</span></span><br><span class=\"line\">df_sorted = df.sort_values(by=<span class=\"string\">&#x27;Age&#x27;</span>, ascending=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(df_sorted)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 选择指定列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df[[<span class=\"string\">&#x27;Name&#x27;</span>, <span class=\"string\">&#x27;Age&#x27;</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按索引选择行</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.iloc[<span class=\"number\">1</span>:<span class=\"number\">3</span>])  <span class=\"comment\"># 选择第二到第三行（按位置）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按标签选择行</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.loc[<span class=\"number\">1</span>:<span class=\"number\">2</span>])  <span class=\"comment\"># 选择第二到第三行（按标签）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算分组统计（按城市分组，计算平均年龄）</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.groupby(<span class=\"string\">&#x27;City&#x27;</span>)[<span class=\"string\">&#x27;Age&#x27;</span>].mean())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 处理缺失值（填充缺失值）</span></span><br><span class=\"line\">df[<span class=\"string\">&#x27;Age&#x27;</span>] = df[<span class=\"string\">&#x27;Age&#x27;</span>].fillna(<span class=\"number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导出为 CSV 文件</span></span><br><span class=\"line\">df.to_csv(<span class=\"string\">&#x27;output.csv&#x27;</span>, index=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>创建 DataFrame</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过字典创建 DataFrame</span></span><br><span class=\"line\">df = pd.DataFrame(&#123;<span class=\"string\">&#x27;Column1&#x27;</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"string\">&#x27;Column2&#x27;</span>: [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]&#125;)</span><br><span class=\"line\">df = pd.DataFrame([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]],</span><br><span class=\"line\">                  columns=[<span class=\"string\">&#x27;Column1&#x27;</span>, <span class=\"string\">&#x27;Column2&#x27;</span>, <span class=\"string\">&#x27;Column3&#x27;</span>])</span><br><span class=\"line\"><span class=\"comment\"># 通过 NumPy 数组创建 DataFrame</span></span><br><span class=\"line\">df = pd.DataFrame(np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]]))</span><br><span class=\"line\">s1 = pd.Series([<span class=\"string\">&#x27;Alice&#x27;</span>, <span class=\"string\">&#x27;Bob&#x27;</span>, <span class=\"string\">&#x27;Charlie&#x27;</span>])</span><br><span class=\"line\">s2 = pd.Series([<span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>])</span><br><span class=\"line\">s3 = pd.Series([<span class=\"string\">&#x27;New York&#x27;</span>, <span class=\"string\">&#x27;Los Angeles&#x27;</span>, <span class=\"string\">&#x27;Chicago&#x27;</span>])</span><br><span class=\"line\">df = pd.DataFrame(&#123;<span class=\"string\">&#x27;Name&#x27;</span>: s1, <span class=\"string\">&#x27;Age&#x27;</span>: s2, <span class=\"string\">&#x27;City&#x27;</span>: s3&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># DataFrame 的属性和方法</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.shape)     <span class=\"comment\"># 形状</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.columns)   <span class=\"comment\"># 列名</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.index)     <span class=\"comment\"># 索引</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.head())    <span class=\"comment\"># 前几行数据，默认是前 5 行</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.tail())    <span class=\"comment\"># 后几行数据，默认是后 5 行</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.info())    <span class=\"comment\"># 数据信息</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.describe())<span class=\"comment\"># 描述统计信息</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.mean())    <span class=\"comment\"># 求平均值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.<span class=\"built_in\">sum</span>())     <span class=\"comment\"># 求和</span></span><br><span class=\"line\"><span class=\"comment\"># 通过列名访问</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df[<span class=\"string\">&#x27;Column1&#x27;</span>])</span><br><span class=\"line\"><span class=\"comment\"># 通过属性访问</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.Name)     </span><br><span class=\"line\"><span class=\"comment\"># 通过 .loc[] 访问</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.loc[:, <span class=\"string\">&#x27;Column1&#x27;</span>])</span><br><span class=\"line\"><span class=\"comment\"># 通过 .iloc[] 访问</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.iloc[:, <span class=\"number\">0</span>])  <span class=\"comment\"># 假设 &#x27;Column1&#x27; 是第一列</span></span><br><span class=\"line\"><span class=\"comment\"># 访问单个元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df[<span class=\"string\">&#x27;Name&#x27;</span>][<span class=\"number\">0</span>])</span><br><span class=\"line\"><span class=\"comment\"># 通过行标签访问</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.loc[<span class=\"number\">0</span>, <span class=\"string\">&#x27;Column1&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 loc 为特定索引添加新行</span></span><br><span class=\"line\">df.loc[<span class=\"number\">3</span>] = [<span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>]</span><br><span class=\"line\"><span class=\"comment\"># 使用 append 添加新行到末尾</span></span><br><span class=\"line\">new_row = &#123;<span class=\"string\">&#x27;Column1&#x27;</span>: <span class=\"number\">13</span>, <span class=\"string\">&#x27;Column2&#x27;</span>: <span class=\"number\">14</span>, <span class=\"string\">&#x27;NewColumn&#x27;</span>: <span class=\"number\">16</span>&#125;</span><br><span class=\"line\">df = df.append(new_row, ignore_index=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"comment\"># 使用concat添加新行</span></span><br><span class=\"line\">new_row = pd.DataFrame([[<span class=\"number\">4</span>, <span class=\"number\">7</span>]], columns=[<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>])  <span class=\"comment\"># 创建一个只包含新行的DataFrame</span></span><br><span class=\"line\">df = pd.concat([df, new_row], ignore_index=<span class=\"literal\">True</span>)  <span class=\"comment\"># 将新行添加到原始DataFrame</span></span><br><span class=\"line\">df_dropped = df.drop(<span class=\"string\">&#x27;Column1&#x27;</span>, axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">df_dropped = df.drop(<span class=\"number\">0</span>)  <span class=\"comment\"># 删除索引为 0 的行</span></span><br><span class=\"line\">df.describe()</span><br><span class=\"line\">df[<span class=\"string\">&#x27;Column1&#x27;</span>].<span class=\"built_in\">sum</span>()</span><br><span class=\"line\">df.mean()</span><br><span class=\"line\">df_reset = df.reset_index(drop=<span class=\"literal\">True</span>)</span><br><span class=\"line\">df_set = df.set_index(<span class=\"string\">&#x27;Column1&#x27;</span>)</span><br><span class=\"line\">df[df[<span class=\"string\">&#x27;Column1&#x27;</span>] &gt; <span class=\"number\">2</span>]</span><br><span class=\"line\">df.dtypes</span><br><span class=\"line\">df[<span class=\"string\">&#x27;Column1&#x27;</span>] = df[<span class=\"string\">&#x27;Column1&#x27;</span>].astype(<span class=\"string\">&#x27;float64&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 纵向合并</span></span><br><span class=\"line\">pd.concat([df1, df2], ignore_index=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"comment\"># 横向合并</span></span><br><span class=\"line\">pd.merge(df1, df2, on=<span class=\"string\">&#x27;Column1&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 索引和切片</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df[[<span class=\"string\">&#x27;Name&#x27;</span>, <span class=\"string\">&#x27;Age&#x27;</span>]])  <span class=\"comment\"># 提取多列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df[<span class=\"number\">1</span>:<span class=\"number\">3</span>])               <span class=\"comment\"># 切片行</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.loc[:, <span class=\"string\">&#x27;Name&#x27;</span>])     <span class=\"comment\"># 提取单列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.loc[<span class=\"number\">1</span>:<span class=\"number\">2</span>, [<span class=\"string\">&#x27;Name&#x27;</span>, <span class=\"string\">&#x27;Age&#x27;</span>]])  <span class=\"comment\"># 标签索引提取指定行列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.iloc[:, <span class=\"number\">1</span>:])        <span class=\"comment\"># 位置索引提取指定列</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"csv\"><a class=\"anchor\" href=\"#csv\">#</a> CSV</h1>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>功能描述</th>\n<th>常用参数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pd.read_csv()</td>\n<td>从 CSV 文件读取数据并加载为 DataFrame</td>\n<td>filepath_or_buffer (路径或文件对象)，sep (分隔符)，header (行标题)，names (自定义列名)，dtype (数据类型)，index_col (索引列)</td>\n</tr>\n<tr>\n<td>DataFrame.to_csv()</td>\n<td>将 DataFrame 写入到 CSV 文件</td>\n<td>path_or_buffer (目标路径或文件对象)，sep (分隔符)，index (是否写入索引)，columns (指定列)，header (是否写入列名)，mode (写入模式)</td>\n</tr>\n</tbody>\n</table>\n<p>read_csv 常用参数:</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>filepath_or_buffer</td>\n<td>CSV 文件的路径或文件对象（支持 URL、文件路径、文件对象等）</td>\n<td>必需参数</td>\n</tr>\n<tr>\n<td>sep</td>\n<td>定义字段分隔符，默认是逗号（,），可以改为其他字符，如制表符（\\t）</td>\n<td>','</td>\n</tr>\n<tr>\n<td>header</td>\n<td>指定行号作为列标题，默认为 0（表示第一行），或者设置为 None 没有标题</td>\n<td>0</td>\n</tr>\n<tr>\n<td>names</td>\n<td>自定义列名，传入列名列表</td>\n<td>None</td>\n</tr>\n<tr>\n<td>index_col</td>\n<td>用作行索引的列的列号或列名</td>\n<td>None</td>\n</tr>\n<tr>\n<td>usecols</td>\n<td>读取指定的列，可以是列的名称或列的索引</td>\n<td>None</td>\n</tr>\n<tr>\n<td>dtype</td>\n<td>强制将列转换为指定的数据类型</td>\n<td>None</td>\n</tr>\n<tr>\n<td>skiprows</td>\n<td>跳过文件开头的指定行数，或者传入一个行号的列表</td>\n<td>None</td>\n</tr>\n<tr>\n<td>nrows</td>\n<td>读取前 N 行数据</td>\n<td>None</td>\n</tr>\n<tr>\n<td>na_values</td>\n<td>指定哪些值应视为缺失值（NaN）</td>\n<td>None</td>\n</tr>\n<tr>\n<td>skipfooter</td>\n<td>跳过文件结尾的指定行数</td>\n<td>0</td>\n</tr>\n<tr>\n<td>encoding</td>\n<td>文件的编码格式（如 utf-8，latin1 等）</td>\n<td>None</td>\n</tr>\n</tbody>\n</table>\n<p>to_csv 常用参数</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>path_or_buffer</td>\n<td>CSV 文件的路径或文件对象（支持文件路径、文件对象）</td>\n<td>必需参数</td>\n</tr>\n<tr>\n<td>sep</td>\n<td>定义字段分隔符，默认是逗号（,），可以改为其他字符，如制表符（\\t）</td>\n<td>','</td>\n</tr>\n<tr>\n<td>index</td>\n<td>是否写入行索引，默认 True 表示写入索引</td>\n<td>True</td>\n</tr>\n<tr>\n<td>columns</td>\n<td>指定写入的列，可以是列的名称列表</td>\n<td>None</td>\n</tr>\n<tr>\n<td>header</td>\n<td>是否写入列名，默认 True 表示写入列名，设置为 False 表示不写列名</td>\n<td>True</td>\n</tr>\n<tr>\n<td>mode</td>\n<td>写入文件的模式，默认是 w（写模式），可以设置为 a（追加模式）</td>\n<td>'w'</td>\n</tr>\n<tr>\n<td>encoding</td>\n<td>文件的编码格式，如 utf-8，latin1 等</td>\n<td>None</td>\n</tr>\n<tr>\n<td>line_terminator</td>\n<td>定义行结束符，默认为 \\n</td>\n<td>None</td>\n</tr>\n<tr>\n<td>quoting</td>\n<td>设置如何对文件中的数据进行引号处理（0-3，具体引用方式可查文档）</td>\n<td>None</td>\n</tr>\n<tr>\n<td>quotechar</td>\n<td>设置用于引用的字符，默认为双引号 &quot;</td>\n<td>'&quot;'</td>\n</tr>\n<tr>\n<td>date_format</td>\n<td>自定义日期格式，如果列包含日期数据，则可以使用此参数指定日期格式</td>\n<td>None</td>\n</tr>\n<tr>\n<td>doublequote</td>\n<td>如果为 True，则在写入时会将包含引号的文本使用双引号括起来</td>\n<td>True</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"excel\"><a class=\"anchor\" href=\"#excel\">#</a> Excel</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pandas.read_excel(io, sheet_name=<span class=\"number\">0</span>, *, header=<span class=\"number\">0</span>, names=<span class=\"literal\">None</span>, index_col=<span class=\"literal\">None</span>, usecols=<span class=\"literal\">None</span>, dtype=<span class=\"literal\">None</span>, engine=<span class=\"literal\">None</span>, converters=<span class=\"literal\">None</span>, true_values=<span class=\"literal\">None</span>, false_values=<span class=\"literal\">None</span>, skiprows=<span class=\"literal\">None</span>, nrows=<span class=\"literal\">None</span>, na_values=<span class=\"literal\">None</span>, keep_default_na=<span class=\"literal\">True</span>, na_filter=<span class=\"literal\">True</span>, verbose=<span class=\"literal\">False</span>, parse_dates=<span class=\"literal\">False</span>, date_parser=&lt;no_default&gt;, date_format=<span class=\"literal\">None</span>, thousands=<span class=\"literal\">None</span>, decimal=<span class=\"string\">&#x27;.&#x27;</span>, comment=<span class=\"literal\">None</span>, skipfooter=<span class=\"number\">0</span>, storage_options=<span class=\"literal\">None</span>, dtype_backend=&lt;no_default&gt;, engine_kwargs=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>io</td>\n<td>这是必需的参数，指定了要读取的 Excel 文件的路径或文件对象。</td>\n<td>必需参数</td>\n</tr>\n<tr>\n<td>sheet_name</td>\n<td>指定要读取的工作表名称或索引。默认为 0，即第一个工作表。</td>\n<td>0</td>\n</tr>\n<tr>\n<td>header</td>\n<td>指定用作列名的行。默认为 0，即第一行。</td>\n<td>0</td>\n</tr>\n<tr>\n<td>names</td>\n<td>用于指定列名的列表。如果提供，将覆盖文件中的列名。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>index_col</td>\n<td>指定用作行索引的列。可以是列的名称或数字。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>usecols</td>\n<td>指定要读取的列。可以是列名的列表或列索引的列表。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>dtype</td>\n<td>指定列的数据类型。可以是字典格式，键为列名，值为数据类型。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>engine</td>\n<td>指定解析引擎。默认为 None，pandas 会自动选择。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>converters</td>\n<td>用于转换数据的函数字典。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>true_values</td>\n<td>指定应该被视为布尔值 True 的值。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>false_values</td>\n<td>指定应该被视为布尔值 False 的值。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>skiprows</td>\n<td>指定要跳过的行数或要跳过的行的列表。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>nrows</td>\n<td>指定要读取的行数。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>na_values</td>\n<td>指定应该被视为缺失值的值。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>keep_default_na</td>\n<td>指定是否要将默认的缺失值（例如 NaN）解析为 NA。</td>\n<td>True</td>\n</tr>\n<tr>\n<td>na_filter</td>\n<td>指定是否要将数据转换为 NA。</td>\n<td>True</td>\n</tr>\n<tr>\n<td>verbose</td>\n<td>指定是否要输出详细的进度信息。</td>\n<td>False</td>\n</tr>\n<tr>\n<td>parse_dates</td>\n<td>指定是否要解析日期。</td>\n<td>False</td>\n</tr>\n<tr>\n<td>date_parser</td>\n<td>用于解析日期的函数。</td>\n<td><code>&lt;no_default&gt;</code></td>\n</tr>\n<tr>\n<td>date_format</td>\n<td>指定日期的格式。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>thousands</td>\n<td>指定千位分隔符。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>decimal</td>\n<td>指定小数点字符。</td>\n<td>'.'</td>\n</tr>\n<tr>\n<td>comment</td>\n<td>指定注释字符。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>skipfooter</td>\n<td>指定要跳过的文件末尾的行数。</td>\n<td>0</td>\n</tr>\n<tr>\n<td>storage_options</td>\n<td>用于云存储的参数字典。</td>\n<td>None</td>\n</tr>\n<tr>\n<td>dtype_backend</td>\n<td>指定数据类型后端。</td>\n<td><code>&lt;no_default&gt;</code></td>\n</tr>\n<tr>\n<td>engine_kwargs</td>\n<td>传递给引擎的额外参数字典。</td>\n<td>None</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"数据清洗\"><a class=\"anchor\" href=\"#数据清洗\">#</a> 数据清洗</h2>\n<p>如果我们要删除包含空字段的行，可以使用 dropna () 方法:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DataFrame.dropna(axis=<span class=\"number\">0</span>, how=<span class=\"string\">&#x27;any&#x27;</span>, thresh=<span class=\"literal\">None</span>, subset=<span class=\"literal\">None</span>, inplace=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>axis：默认为 0，表示逢空值剔除整行，如果设置参数 axis＝1 表示逢空值去掉整列。</li>\n<li>how：默认为 'any' 如果一行（或一列）里任何一个数据有出现 NA 就去掉整行，如果设置 how='all' 一行（或列）都是 NA 才去掉这整行。</li>\n<li>thresh：设置需要多少非空值的数据才可以保留下来的。</li>\n<li>subset：设置想要检查的列。如果是多个列，可以使用列名的 list 作为参数。</li>\n<li>inplace：如果设置 True，将计算得到的值直接覆盖之前的值并返回 None，修改的是源数据。</li>\n</ul>\n<p>我们可以通过 isnull () 判断各个单元格是否为空。</p>\n<p>我们也可以 fillna () 方法来替换一些空字段： <code>df.fillna(12345, inplace = True)</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\">df = pd.read_csv(<span class=\"string\">&#x27;property-data.csv&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">x = df[<span class=\"string\">&quot;ST_NUM&quot;</span>].mean()</span><br><span class=\"line\"></span><br><span class=\"line\">df[<span class=\"string\">&quot;ST_NUM&quot;</span>].fillna(x, inplace = <span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.to_string())</span><br></pre></td></tr></table></figure>\n<p>Pandas 使用 mean ()、median () 和 mode () 方法计算列的均值（所有值加起来的平均值）、中位数值（排序后排在中间的数）和众数（出现频率最高的数）。</p>\n<p>如果我们要清洗重复数据，可以使用 duplicated () 和 drop_duplicates () 方法。</p>\n<p>如果对应的数据是重复的，duplicated () 会返回 True，否则返回 False。</p>\n<h1 id=\"数据预处理操作汇总\"><a class=\"anchor\" href=\"#数据预处理操作汇总\">#</a> 数据预处理操作汇总</h1>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>方法 / 步骤</th>\n<th>说明</th>\n<th>常用函数 / 方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>缺失值处理</td>\n<td>填充缺失值</td>\n<td>使用指定的值（如均值、中位数、众数等）填充缺失值。</td>\n<td><code>df.fillna(value)</code></td>\n</tr>\n<tr>\n<td></td>\n<td>删除缺失值</td>\n<td>删除包含缺失值的行或列。</td>\n<td><code>df.dropna()</code></td>\n</tr>\n<tr>\n<td>重复数据处理</td>\n<td>删除重复数据</td>\n<td>删除 DataFrame 中的重复行。</td>\n<td><code>df.drop_duplicates()</code></td>\n</tr>\n<tr>\n<td>异常值处理</td>\n<td>异常值检测（基于统计方法）</td>\n<td>通过 Z-score 或 IQR 方法识别并处理异常值。</td>\n<td>自定义函数（如基于 Z-score 或 IQR）</td>\n</tr>\n<tr>\n<td></td>\n<td>替换异常值</td>\n<td>使用合适的值（如均值或中位数）替换异常值。</td>\n<td>自定义函数（如替换异常值）</td>\n</tr>\n<tr>\n<td>数据格式转换</td>\n<td>转换数据类型</td>\n<td>将数据类型从一个类型转换为另一个类型，如将字符串转换为日期。</td>\n<td><code>df.astype()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>日期时间格式转换</td>\n<td>转换字符串或数字为日期时间类型。</td>\n<td><code>pd.to_datetime()</code></td>\n</tr>\n<tr>\n<td>标准化与归一化</td>\n<td>标准化</td>\n<td>将数据转换为均值为 0，标准差为 1 的分布。</td>\n<td><code>StandardScaler()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>归一化</td>\n<td>将数据缩放到指定的范围（如 [0, 1]）。</td>\n<td><code>MinMaxScaler()</code></td>\n</tr>\n<tr>\n<td>类别数据编码</td>\n<td>标签编码</td>\n<td>将类别变量转换为整数形式。</td>\n<td><code>LabelEncoder()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>独热编码（One-Hot Encoding）</td>\n<td>将每个类别转换为一个新的二进制特征。</td>\n<td><code>pd.get_dummies()</code></td>\n</tr>\n<tr>\n<td>文本数据处理</td>\n<td>去除停用词</td>\n<td>从文本中去除无关紧要的词，如 &quot;the&quot; 、 &quot;is&quot; 等。</td>\n<td>自定义函数（基于  <code>nltk</code>  或  <code>spaCy</code> ）</td>\n</tr>\n<tr>\n<td></td>\n<td>词干化与词形还原</td>\n<td>提取词干或恢复单词的基本形式。</td>\n<td><code>nltk.stem.PorterStemmer()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>分词</td>\n<td>将文本分割成单词或子词。</td>\n<td><code>nltk.word_tokenize()</code></td>\n</tr>\n<tr>\n<td>数据抽样</td>\n<td>随机抽样</td>\n<td>从数据中随机抽取一定比例的样本。</td>\n<td><code>df.sample()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>上采样与下采样</td>\n<td>通过过采样或欠采样来平衡数据集中的类别分布。</td>\n<td><code>SMOTE()</code> （上采样）； <code>RandomUnderSampler()</code> （下采样）</td>\n</tr>\n<tr>\n<td>特征工程</td>\n<td>特征选择</td>\n<td>选择对目标变量有影响的特征，去除冗余或无关特征。</td>\n<td><code>SelectKBest()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>特征提取</td>\n<td>从原始数据中创建新的特征，提升模型的预测能力。</td>\n<td><code>PolynomialFeatures()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>特征缩放</td>\n<td>对数值特征进行缩放，使其具有相同的量级。</td>\n<td><code>MinMaxScaler()</code> 、 <code>StandardScaler()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>类别特征映射</td>\n<td>将类别变量映射为对应的数字编码。</td>\n<td>自定义映射函数</td>\n</tr>\n<tr>\n<td>数据合并与连接</td>\n<td>合并数据</td>\n<td>将多个 DataFrame 按照某些列合并在一起，支持内连接、外连接、左连接、右连接等。</td>\n<td><code>pd.merge()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>连接数据</td>\n<td>将多个 DataFrame 进行行或列拼接。</td>\n<td><code>pd.concat()</code></td>\n</tr>\n<tr>\n<td>数据重塑</td>\n<td>数据透视表</td>\n<td>将数据根据某些维度进行分组并计算聚合结果。</td>\n<td><code>pd.pivot_table()</code></td>\n</tr>\n<tr>\n<td></td>\n<td>数据变形</td>\n<td>改变数据的形状，如从长格式转为宽格式或从宽格式转为长格式。</td>\n<td><code>df.melt()</code> 、 <code>df.pivot()</code></td>\n</tr>\n<tr>\n<td>数据类型转换与处理</td>\n<td>字符串处理</td>\n<td>对字符串数据进行处理，如去除空格、转换大小写等。</td>\n<td><code>str.replace()</code> 、 <code>str.upper()</code>  等</td>\n</tr>\n<tr>\n<td>分组计算</td>\n<td></td>\n<td>按照某个特征分组后进行聚合计算。</td>\n<td><code>df.groupby()</code></td>\n</tr>\n<tr>\n<td>缺失值预测填充</td>\n<td>使用模型预测填充缺失值</td>\n<td>使用机器学习模型（如回归模型）预测缺失值，并填充缺失数据。</td>\n<td>自定义模型（如  <code>sklearn.linear_model.LinearRegression</code> ）</td>\n</tr>\n<tr>\n<td>时间序列处理</td>\n<td>时间序列缺失值填充</td>\n<td>使用时间序列的方法（如前向填充、后向填充）填充缺失值。</td>\n<td><code>df.fillna(method='ffill')</code></td>\n</tr>\n<tr>\n<td></td>\n<td>滚动窗口计算</td>\n<td>使用滑动窗口进行时间序列数据的统计计算（如均值、标准差等）。</td>\n<td><code>df.rolling(window=5).mean()</code></td>\n</tr>\n<tr>\n<td>数据转换与映射</td>\n<td>数据映射与替换</td>\n<td>将数据中的某些值替换为其他值。</td>\n<td><code>df.replace()</code></td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.preprocessing <span class=\"keyword\">import</span> StandardScaler</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例数据</span></span><br><span class=\"line\">data = &#123;<span class=\"string\">&#x27;Age&#x27;</span>: [<span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">45</span>],</span><br><span class=\"line\">        <span class=\"string\">&#x27;Salary&#x27;</span>: [<span class=\"number\">50000</span>, <span class=\"number\">60000</span>, <span class=\"number\">70000</span>, <span class=\"number\">80000</span>, <span class=\"number\">90000</span>]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 标准化数据</span></span><br><span class=\"line\">scaler = StandardScaler()</span><br><span class=\"line\">df_scaled = scaler.fit_transform(df)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df_scaled)</span><br></pre></td></tr></table></figure>\n<h2 id=\"相关性分析\"><a class=\"anchor\" href=\"#相关性分析\">#</a> 相关性分析</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">df.corr(method=<span class=\"string\">&#x27;pearson&#x27;</span>, min_periods=<span class=\"number\">1</span>)</span><br><span class=\"line\">spearman_correlation = df.corr(method=<span class=\"string\">&#x27;spearman&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 计算肯德尔秩相关系数</span></span><br><span class=\"line\">kendall_correlation = df.corr(method=<span class=\"string\">&#x27;kendall&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 计算相关性矩阵</span></span><br><span class=\"line\">correlation_matrix = df.corr()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 绘制相关性热图</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">8</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\">sns.heatmap(df.corr(), annot=<span class=\"literal\">True</span>, cmap=<span class=\"string\">&#x27;coolwarm&#x27;</span>, fmt=<span class=\"string\">&#x27;.2f&#x27;</span>, vmin=-<span class=\"number\">1</span>, vmax=<span class=\"number\">1</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Correlation Heatmap&#x27;</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>apply () — 应用函数到 DataFrame 或 Series 上<br />\n apply () 方法允许在 DataFrame 或 Series 上应用自定义函数，支持对行或列进行操作。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例数据</span></span><br><span class=\"line\">df = pd.DataFrame(&#123;<span class=\"string\">&#x27;A&#x27;</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"string\">&#x27;B&#x27;</span>: [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>]&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义自定义函数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">custom_func</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在列上应用函数</span></span><br><span class=\"line\">df[<span class=\"string\">&#x27;A&#x27;</span>] = df[<span class=\"string\">&#x27;A&#x27;</span>].apply(custom_func)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(df)</span><br></pre></td></tr></table></figure>\n<p>对于具有重复值的字符串列，可以使用 category 类型来减少内存消耗。category 类型在内存中存储的是整数索引，而不是字符串本身。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 示例数据</span></span><br><span class=\"line\">df = pd.DataFrame(&#123;<span class=\"string\">&#x27;Category&#x27;</span>: [<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>]&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 category 类型</span></span><br><span class=\"line\">df[<span class=\"string\">&#x27;Category&#x27;</span>] = df[<span class=\"string\">&#x27;Category&#x27;</span>].astype(<span class=\"string\">&#x27;category&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df.dtypes)</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "代码",
                "python",
                "学习笔记",
                "python"
            ]
        },
        {
            "id": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python/",
            "url": "http://amentiraz.github.io/code/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0python/",
            "title": "系统学习python(一）对于NumPy的整理",
            "date_published": "2025-05-02T07:59:00.000Z",
            "content_html": "<p>重新系统学习一下 python</p>\n<span id=\"more\"></span>\n<p>首先我们对于 AnnData 的结构进行回顾</p>\n<h3 id=\"1-anndata-的结构\"><a class=\"anchor\" href=\"#1-anndata-的结构\">#</a> <strong>1.  <code>AnnData</code>  的结构</strong></h3>\n<p><code>AnnData</code>  是一种基于矩阵的数据结构，专为处理大规模高维数据设计。它将表达矩阵和注释信息结合起来，支持存储和处理实验数据的多个层面。</p>\n<p><strong>核心组成部分：</strong></p>\n<ul>\n<li>\n<p><strong> <code>X</code>  (主矩阵)</strong>：存储主要的数据，例如基因表达矩阵。</p>\n<ul>\n<li>数据类型：通常是 NumPy 数组 ( <code>numpy.ndarray</code> ) 或稀疏矩阵 ( <code>scipy.sparse</code> )，以节省内存。</li>\n<li>维度：形状为  <code>(n_obs, n_vars)</code> ，即细胞数 × 基因数。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>obs</code>  (观测样本注释)</strong>：存储细胞的元数据。</p>\n<ul>\n<li>类型： <code>pandas.DataFrame</code></li>\n<li>行：对应细胞，列：存储细胞的注释信息（如细胞类型、实验条件等）。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>var</code>  (变量注释)</strong>：存储基因的元数据。</p>\n<ul>\n<li>类型： <code>pandas.DataFrame</code></li>\n<li>行：对应基因，列：存储基因的注释信息（如基因名称、功能分类等）。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>obsm</code>  (观测样本多维数据)</strong>：存储额外的细胞数据，例如降维结果（如 PCA、t-SNE 或 UMAP）。</p>\n<ul>\n<li>类型：字典，值通常是 NumPy 数组或稀疏矩阵。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>varm</code>  (变量多维数据)</strong>：存储额外的基因数据，例如 PCA 的基因负载矩阵。</p>\n<ul>\n<li>类型：字典。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>uns</code>  (未分类信息)</strong>：存储任意未分类的附加信息，例如绘图参数或聚类结果的元数据。</p>\n<ul>\n<li>类型：字典。</li>\n</ul>\n</li>\n<li>\n<p><strong> <code>layers</code> </strong>：支持存储多个版本的主矩阵  <code>X</code> ，例如原始数据、归一化数据、去噪数据等。</p>\n<ul>\n<li>类型：字典，键为层的名称，值为矩阵。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"numpy\"><a class=\"anchor\" href=\"#numpy\">#</a> NumPy</h1>\n<p>然后我们发现我们并没有系统的学习过 Numpy 是个什么东西，这里我们补充一下相关的知识。</p>\n<p>这里我们根据 RUNOOB 上的教程进行补充学习。</p>\n<h2 id=\"numpy-ndarray对象\"><a class=\"anchor\" href=\"#numpy-ndarray对象\">#</a> NumPy ndarray 对象</h2>\n<p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。</p>\n<p>ndarray 对象是用于存放同类型元素的多维数组。</p>\n<p>ndarray 中的每个元素在内存中都有相同存储大小的区域。</p>\n<p>ndarray 内部由以下内容组成：</p>\n<p>一个指向数据（内存或内存映射文件中的一块数据）的指针。</p>\n<p>数据类型或 dtype，描述在数组中的固定大小值的格子。</p>\n<p>一个表示数组形状（shape）的元组，表示各维度大小的元组。</p>\n<p>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要 &quot;跨过&quot; 的字节数。</p>\n<p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>object 表示数组或嵌套的数列</li>\n<li>dtype 表示数组元素的数据类型</li>\n<li>copy 表示对象是否需要复制</li>\n<li>order 表示创建数组的样式，C 为行方向，F 为列方向，A 为任意方向 (默认)</li>\n<li>subok 默认返回一个与积累类型一致的数组</li>\n<li>ndmin 指定生成数组的最小维度</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\">b = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"></span><br><span class=\"line\">c = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], ndmin=<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"></span><br><span class=\"line\">d = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], dtype=<span class=\"built_in\">complex</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(d)</span><br></pre></td></tr></table></figure>\n<h2 id=\"numpy-数据类型\"><a class=\"anchor\" href=\"#numpy-数据类型\">#</a> NumPy 数据类型</h2>\n<p>下表列举了常用的 NumPy 的基本类型</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bool</td>\n<td>略</td>\n</tr>\n<tr>\n<td>int</td>\n<td>...</td>\n</tr>\n<tr>\n<td>float</td>\n<td>...</td>\n</tr>\n<tr>\n<td>complex</td>\n<td>...</td>\n</tr>\n</tbody>\n</table>\n<p>数据类型对象（numpy.dtype 类的实例）用来描述与数组对应的内存区域是如何使用，它描述了数据的以下几个方面：：</p>\n<p>数据的类型（整数，浮点数或者 Python 对象）<br />\n数据的大小（例如， 整数使用多少个字节存储）<br />\n数据的字节顺序（小端法或大端法）<br />\n在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分<br />\n如果数据类型是子数组，那么它的形状和数据类型是什么。<br />\n字节顺序是通过对数据类型预先设定 &lt;或&gt; 来决定的。 &lt; 意味着小端法 (最小值存储在最小的地址，即低位组放在最前面)。&gt; 意味着大端法 (最重要的字节存储在最小的地址，即高位组放在最前面)。</p>\n<p>dtype 对象是使用以下语法构造的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.dtype(<span class=\"built_in\">object</span>, align, copy)</span><br></pre></td></tr></table></figure>\n<p>object - 要转换为的数据类型对象<br />\n align - 如果为 true，填充字段使其类似 C 的结构体。<br />\ncopy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">dt = np.dtype(np.int8)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(dt)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结构化数据类型</span></span><br><span class=\"line\">dt = np.dtype([(<span class=\"string\">&quot;age&quot;</span>, np.int8)])</span><br><span class=\"line\">a = np.array([(<span class=\"number\">10</span>,), (<span class=\"number\">20</span>,), (<span class=\"number\">30</span>,)], dtype=dt)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[<span class=\"string\">&quot;age&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">student = np.dtype([(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;S20&quot;</span>), (<span class=\"string\">&quot;age&quot;</span>, <span class=\"string\">&quot;i4&quot;</span>), (<span class=\"string\">&quot;marks&quot;</span>, <span class=\"string\">&quot;f4&quot;</span>)])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(student)</span><br><span class=\"line\">b = np.array([(<span class=\"string\">&quot;abc&quot;</span>, <span class=\"number\">21</span>, <span class=\"number\">50</span>), (<span class=\"string\">&quot;xyz&quot;</span>, <span class=\"number\">18</span>, <span class=\"number\">75</span>)], dtype=student)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>对应类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b</td>\n<td>布尔型</td>\n</tr>\n<tr>\n<td>i</td>\n<td>有符号整形</td>\n</tr>\n<tr>\n<td>u</td>\n<td>无符号整形 integer</td>\n</tr>\n<tr>\n<td>f</td>\n<td>浮点型</td>\n</tr>\n<tr>\n<td>c</td>\n<td>复数浮点型</td>\n</tr>\n<tr>\n<td>m</td>\n<td>timedelta</td>\n</tr>\n<tr>\n<td>M</td>\n<td>datatime</td>\n</tr>\n<tr>\n<td>O</td>\n<td>（python）对象</td>\n</tr>\n<tr>\n<td>S，a</td>\n<td>（byte-）字符串</td>\n</tr>\n<tr>\n<td>U</td>\n<td>Unicode</td>\n</tr>\n<tr>\n<td>V</td>\n<td>原始数据（void)</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"数组属性\"><a class=\"anchor\" href=\"#数组属性\">#</a> 数组属性</h1>\n<p>NumPy 数组的维数称为秩（rank），秩就是轴的数量，即数组的维度，一维数组的秩为 1，二维数组的秩为 2，以此类推。</p>\n<p>在 NumPy 中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量 —— 秩，就是数组的维数。</p>\n<p>很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第 1 轴进行操作，即对每一行进行操作。</p>\n<p>NumPy 的数组中比较重要 ndarray 对象属性有：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ndarray.ndim</td>\n<td>数组的秩（rank），即数组的维度数量或轴的数量。</td>\n</tr>\n<tr>\n<td>ndarray.shape</td>\n<td>数组的维度，表示数组在每个轴上的大小。对于二维数组（矩阵），表示其行数和列数。</td>\n</tr>\n<tr>\n<td>ndarray.size</td>\n<td>数组中元素的总个数，等于 ndarray.shape 中各个轴上大小的乘积。</td>\n</tr>\n<tr>\n<td>ndarray.dtype</td>\n<td>数组中元素的数据类型。</td>\n</tr>\n<tr>\n<td>ndarray.itemsize</td>\n<td>数组中每个元素的大小，以字节为单位。</td>\n</tr>\n<tr>\n<td>ndarray.flags</td>\n<td>包含有关内存布局的信息，如是否为 C 或 Fortran 连续存储，是否为只读等。</td>\n</tr>\n<tr>\n<td>ndarray.real</td>\n<td>数组中每个元素的实部（如果元素类型为复数）。</td>\n</tr>\n<tr>\n<td>ndarray.imag</td>\n<td>数组中每个元素的虚部（如果元素类型为复数）。</td>\n</tr>\n<tr>\n<td>ndarray.data</td>\n<td>实际存储数组元素的缓冲区，一般通过索引访问元素，不直接使用该属性。</td>\n</tr>\n</tbody>\n</table>\n<p>ndarray.flags 返回 ndarray 对象的内存信息，包含以下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C_CONTIGUOUS (C)</td>\n<td>数据是在一个单一的 C 风格的连续段中</td>\n</tr>\n<tr>\n<td>F_CONTIGUOUS (F)</td>\n<td>数据是在一个单一的 Fortran 风格的连续段中</td>\n</tr>\n<tr>\n<td>OWNDATA (O)</td>\n<td>数组拥有它所使用的内存或从另一个对象中借用它</td>\n</tr>\n<tr>\n<td>WRITEABLE (W)</td>\n<td>数据区域可以被写入，将该值设置为 False，则数据为只读</td>\n</tr>\n<tr>\n<td>ALIGNED (A)</td>\n<td>数据和所有元素都适当地对齐到硬件上</td>\n</tr>\n<tr>\n<td>UPDATEIFCOPY (U)</td>\n<td>这个数组是其它数组的一个副本，当这个数组被释放时，原数组的内容将被更新</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">24</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.ndim)</span><br><span class=\"line\">b = a.reshape(<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b.ndim)</span><br><span class=\"line\"></span><br><span class=\"line\">c = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c.shape)</span><br><span class=\"line\"></span><br><span class=\"line\">d = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\">d.shape = (<span class=\"number\">3</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(d)</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], dtype=np.int8)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x.itemsize)</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x.flags)</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建数组\"><a class=\"anchor\" href=\"#创建数组\">#</a> 创建数组</h2>\n<p>numpy.empty 方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.empty(shape, dtype = <span class=\"built_in\">float</span>, order = <span class=\"string\">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\">x = np.empty([<span class=\"number\">3</span>,<span class=\"number\">2</span>], dtype = <span class=\"built_in\">int</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span> (x)</span><br></pre></td></tr></table></figure>\n<p>numpy.zeros<br />\n 创建指定大小的数组，数组元素以 0 来填充：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.zeros(shape, dtype = <span class=\"built_in\">float</span>, order = <span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">```numpy.ones_like</span><br><span class=\"line\">numpy.ones_like 用于创建一个与给定数组具有相同形状的数组，数组元素以 <span class=\"number\">1</span> 来填充。</span><br><span class=\"line\"></span><br><span class=\"line\">numpy.ones 和 numpy.ones_like 都是用于创建一个指定形状的数组，其中所有元素都是 <span class=\"number\">1</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">它们之间的区别在于：numpy.ones 可以直接指定要创建的数组的形状，而 numpy.ones_like 则是创建一个与给定数组具有相同形状的数组。</span><br><span class=\"line\"></span><br><span class=\"line\">numpy.ones</span><br><span class=\"line\">创建指定形状的数组，数组元素以 <span class=\"number\">1</span> 来填充：</span><br><span class=\"line\"></span><br><span class=\"line\">```python</span><br><span class=\"line\">numpy.ones(shape, dtype = <span class=\"literal\">None</span>, order = <span class=\"string\">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>numpy.zeros_like 用于创建一个与给定数组具有相同形状的数组，数组元素以 0 来填充。</p>\n<p>numpy.zeros 和 numpy.zeros_like 都是用于创建一个指定形状的数组，其中所有元素都是 0。</p>\n<p>它们之间的区别在于：numpy.zeros 可以直接指定要创建的数组的形状，而 numpy.zeros_like 则是创建一个与给定数组具有相同形状的数组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.zeros_like(a, dtype=<span class=\"literal\">None</span>, order=<span class=\"string\">&#x27;K&#x27;</span>, subok=<span class=\"literal\">True</span>, shape=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<p>numpy.ones_like<br />\nnumpy.ones_like 用于创建一个与给定数组具有相同形状的数组，数组元素以 1 来填充。</p>\n<p>numpy.ones 和 numpy.ones_like 都是用于创建一个指定形状的数组，其中所有元素都是 1。</p>\n<p>它们之间的区别在于：numpy.ones 可以直接指定要创建的数组的形状，而 numpy.ones_like 则是创建一个与给定数组具有相同形状的数组。</p>\n<h2 id=\"从数值范围创建数组\"><a class=\"anchor\" href=\"#从数值范围创建数组\">#</a> 从数值范围创建数组</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.arange(start, stop, step, dtype)</span><br></pre></td></tr></table></figure>\n<p>numpy.linspace 函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.linspace(start, stop, num=<span class=\"number\">50</span>, endpoint=<span class=\"literal\">True</span>, retstep=<span class=\"literal\">False</span>, dtype=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>start</td>\n<td>序列的起始值</td>\n</tr>\n<tr>\n<td>stop</td>\n<td>序列的终止值，如果 endpoint 为 true，该值包含于数列中</td>\n</tr>\n<tr>\n<td>num</td>\n<td>要生成的等步长的样本数量，默认为 50</td>\n</tr>\n<tr>\n<td>endpoint</td>\n<td>该值为 true 时，数列中包含 stop 值，反之不包含，默认是 True。</td>\n</tr>\n<tr>\n<td>retstep</td>\n<td>如果为 True 时，生成的数组中会显示间距，反之不显示。</td>\n</tr>\n<tr>\n<td>dtype</td>\n<td>ndarray 的数据类型</td>\n</tr>\n</tbody>\n</table>\n<p>numpy.logspace 函数用于创建一个于等比数列。格式如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.logspace(start, stop, num=<span class=\"number\">50</span>, endpoint=<span class=\"literal\">True</span>, base=<span class=\"number\">10.0</span>, dtype=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<p>base 参数意思是取对数的时候 log 的下标。</p>\n<h2 id=\"引索与切片\"><a class=\"anchor\" href=\"#引索与切片\">#</a> 引索与切片</h2>\n<p>冒号：的解释：如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 [2:7]，那么则提取两个索引 (不包括停止索引) 之间的项。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">10</span>)</span><br><span class=\"line\">s = <span class=\"built_in\">slice</span>(<span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[s])</span><br><span class=\"line\"></span><br><span class=\"line\">b = np.arange(<span class=\"number\">10</span>)</span><br><span class=\"line\">c = b[<span class=\"number\">2</span>:<span class=\"number\">7</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"></span><br><span class=\"line\">d = np.arange(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(d[<span class=\"number\">2</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\">e = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(e)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;从数组引索a[1:]处开始切割&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(e[<span class=\"number\">1</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\">f = e.copy()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(f)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(f[..., <span class=\"number\">1</span>])  <span class=\"comment\"># 第二列元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(f[<span class=\"number\">1</span>, ...])  <span class=\"comment\"># 第二列元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(f[..., <span class=\"number\">1</span>:])</span><br></pre></td></tr></table></figure>\n<h2 id=\"高级引索\"><a class=\"anchor\" href=\"#高级引索\">#</a> 高级引索</h2>\n<p>整数数组索引是指使用一个数组来访问另一个数组的元素。这个数组中的每个元素都是目标数组中某个维度上的索引值。</p>\n<p>以下实例获取数组中 (0,0)，(1,1) 和 (2,0) 位置处的元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">x = np.array([[<span class=\"number\">1</span>,  <span class=\"number\">2</span>],  [<span class=\"number\">3</span>,  <span class=\"number\">4</span>],  [<span class=\"number\">5</span>,  <span class=\"number\">6</span>]]) </span><br><span class=\"line\">y = x[[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>],  [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>]]  </span><br><span class=\"line\"><span class=\"built_in\">print</span> (y)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>], [<span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\">y = x[[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>]]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.array([[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>], [<span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">rows = np.array([[<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">3</span>, <span class=\"number\">3</span>]])</span><br><span class=\"line\">cols = np.array([[<span class=\"number\">0</span>, <span class=\"number\">2</span>], [<span class=\"number\">0</span>, <span class=\"number\">2</span>]])</span><br><span class=\"line\">y = x[rows, cols]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]])</span><br><span class=\"line\">b = a[<span class=\"number\">1</span>:<span class=\"number\">3</span>, <span class=\"number\">1</span>:<span class=\"number\">3</span>]</span><br><span class=\"line\">c = a[<span class=\"number\">1</span>:<span class=\"number\">3</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]]</span><br><span class=\"line\">d = a[..., <span class=\"number\">1</span>:]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(d)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">x = np.array([[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>], [<span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x&gt;5&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x[x &gt; <span class=\"number\">5</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([np.nan, <span class=\"number\">1</span>, <span class=\"number\">2</span>, np.nan, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[~np.isnan(a)])</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span> + <span class=\"number\">6j</span>, <span class=\"number\">5</span>, <span class=\"number\">3.5</span> + <span class=\"number\">5j</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[np.iscomplex(a)])</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.arange(<span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\">x2 = x[[<span class=\"number\">0</span>, <span class=\"number\">6</span>]]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x2)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x2[<span class=\"number\">0</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x2[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.arange(<span class=\"number\">32</span>).reshape((<span class=\"number\">8</span>, <span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;读取下标对应的行&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x[[<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;倒序索引&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x[[-<span class=\"number\">4</span>, -<span class=\"number\">2</span>, -<span class=\"number\">1</span>, -<span class=\"number\">7</span>]])</span><br></pre></td></tr></table></figure>\n<h2 id=\"广播\"><a class=\"anchor\" href=\"#广播\">#</a> 广播</h2>\n<p>广播 (Broadcast) 是 numpy 对不同形状 (shape) 的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p>\n<p>如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">a = np.array([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]) </span><br><span class=\"line\">b = np.array([<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>,<span class=\"number\">40</span>]) </span><br><span class=\"line\">c = a * b </span><br><span class=\"line\"><span class=\"built_in\">print</span> (c)</span><br></pre></td></tr></table></figure>\n<p>输出结果： <code>[ 10  40  90 160]</code> <br />\n 当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">a = np.array([[ <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">           [<span class=\"number\">10</span>,<span class=\"number\">10</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">           [<span class=\"number\">20</span>,<span class=\"number\">20</span>,<span class=\"number\">20</span>],</span><br><span class=\"line\">           [<span class=\"number\">30</span>,<span class=\"number\">30</span>,<span class=\"number\">30</span>]])</span><br><span class=\"line\">b = np.array([<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a + b)</span><br></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[ 0  1  2]</span><br><span class=\"line\"> [10 11 12]</span><br><span class=\"line\"> [20 21 22]</span><br><span class=\"line\"> [30 31 32]]</span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代数组\"><a class=\"anchor\" href=\"#迭代数组\">#</a> 迭代数组</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">6</span>).reshape(<span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;迭代输出元素：&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> np.nditer(a):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(x, end=<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> np.nditer(a.T):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(x, end=<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> np.nditer(a.T.copy(order=<span class=\"string\">&quot;C&quot;</span>)):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(x, end=<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># output</span></span><br><span class=\"line\"><span class=\"comment\"># 0, 1, 2, 3, 4, 5,</span></span><br><span class=\"line\"><span class=\"comment\"># 0, 3, 1, 4, 2, 5,</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># for x in np.nditer(a, order=&#x27;F&#x27;):Fortran order，即是列序优先；</span></span><br><span class=\"line\"><span class=\"comment\"># for x in np.nditer(a.T, order=&#x27;C&#x27;):C order，即是行序优先；</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">0</span>, <span class=\"number\">60</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">a = a.reshape(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原始数组是：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;以 C 风格顺序排序：&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> np.nditer(a, order=<span class=\"string\">&quot;C&quot;</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(x, end=<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;以 F 风格顺序排序：&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> np.nditer(a, order=<span class=\"string\">&quot;F&quot;</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(x, end=<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># nditer 对象有另一个可选参数 op_flags。 默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值的修改，必须指定 readwrite 或者 writeonly 的模式。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">0</span>, <span class=\"number\">60</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">a = a.reshape(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原始数组是：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># for x in np.nditer(a, op_flags=[&quot;readwrite&quot;]):</span></span><br><span class=\"line\"><span class=\"comment\">#    x[...] = 2 * x</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;修改后的数组是：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">0</span>, <span class=\"number\">60</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">a = a.reshape(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第一个数组为：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第二个数组为：&quot;</span>)</span><br><span class=\"line\">b = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], dtype=<span class=\"built_in\">int</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;修改后的数组为：&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> x, y <span class=\"keyword\">in</span> np.nditer([a, b]):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;%d:%d&quot;</span> % (x, y), end=<span class=\"string\">&quot;, &quot;</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组操作\"><a class=\"anchor\" href=\"#数组操作\">#</a> 数组操作</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原始数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\">b = a.reshape(<span class=\"number\">4</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;修改后的数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">9</span>).reshape((<span class=\"number\">3</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原始数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> a:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(row)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;迭代后的数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> a.flat:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(element)</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">8</span>).reshape(<span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;展开后的数组:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.flatten())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;以F风格顺序展开的数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.flatten(order=<span class=\"string\">&quot;F&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.ravel() 展平的数组元素，顺序通常是&quot;C风格&quot;，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">8</span>).reshape(<span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用 ravel 函数之后：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.ravel())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;以 F 风格顺序调用 ravel 函数之后：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.ravel(order=<span class=\"string\">&quot;F&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">12</span>).reshape(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.transpose(a))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.T)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建了三维的 ndarray</span></span><br><span class=\"line\">a = np.arange(<span class=\"number\">8</span>).reshape(<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;获取数组中一个值：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.where(a == <span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>])  <span class=\"comment\"># 为 6</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将轴 2 滚动到轴 0（宽度到深度）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用 rollaxis 函数：&quot;</span>)</span><br><span class=\"line\">b = np.rollaxis(a, <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"comment\"># 查看元素 a[1,1,0]，即 6 的坐标，变成 [0, 1, 1]</span></span><br><span class=\"line\"><span class=\"comment\"># 最后一个 0 移动到最前面</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.where(b == <span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将轴 2 滚动到轴 1：（宽度到高度）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用 rollaxis 函数：&quot;</span>)</span><br><span class=\"line\">c = np.rollaxis(a, <span class=\"number\">2</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"><span class=\"comment\"># 查看元素 a[1,1,0]，即 6 的坐标，变成 [1, 0, 1]</span></span><br><span class=\"line\"><span class=\"comment\"># 最后的 0 和 它前面的 1 对换位置</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.where(c == <span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建了三维的 ndarray</span></span><br><span class=\"line\">a = np.arange(<span class=\"number\">8</span>).reshape(<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 现在交换轴 0（深度方向）到轴 2（宽度方向）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用 swapaxes 函数后的数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.swapaxes(a, <span class=\"number\">2</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.broadcast_to 函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">4</span>).reshape(<span class=\"number\">1</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;原数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用 broadcast_to 函数之后：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.broadcast_to(a, (<span class=\"number\">4</span>, <span class=\"number\">4</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.expand_dims 函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下:</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">x = np.array(([<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数组 x：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">y = np.expand_dims(x, axis=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数组 y：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数组 x 和 y 的形状：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x.shape, y.shape)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 在位置 1 插入轴</span></span><br><span class=\"line\">y = np.expand_dims(x, axis=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;在位置 1 插入轴之后的数组 y：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x.ndim 和 y.ndim：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x.ndim, y.ndim)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;x.shape 和 y.shape：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x.shape, y.shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.squeeze 函数从给定数组的形状中删除一维的条目，函数格式如下：</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">x = np.arange(<span class=\"number\">9</span>).reshape(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数组 x：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">y = np.squeeze(x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数组 y：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;数组 x 和 y 的形状：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x.shape, y.shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.concatenate 函数用于沿指定轴连接相同形状的两个或多个数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\">b = np.array([[<span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;沿着轴0链接两个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.concatenate((a, b)))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;沿着轴1链接两个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.concatenate((a, b), axis=<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.concatenate((a, b), axis=<span class=\"number\">1</span>).shape)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.stack 函数用于沿新轴连接数组序列</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第一个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">b = np.array([[<span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第二个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;沿轴 0 堆叠两个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.stack((a, b), <span class=\"number\">0</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;沿轴 1 堆叠两个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.stack((a, b), <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.stack((a, b), <span class=\"number\">0</span>).shape)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.stack((a, b), <span class=\"number\">1</span>).shape)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>数组及操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>split</td>\n<td>将一个数组分割为多个子数组</td>\n</tr>\n<tr>\n<td>hsplit</td>\n<td>将一个数组水平分割为多个子数组（按列）</td>\n</tr>\n<tr>\n<td>vsplit</td>\n<td>将一个数组垂直分割为多个子数组（按行）</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第一个数组：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;将数组分为三个大小相等的数组:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.split(a, <span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;标明位置的分割：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.split(a, [<span class=\"number\">4</span>, <span class=\"number\">7</span>]))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;rest&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.split(a, <span class=\"number\">3</span>)[<span class=\"number\">2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">16</span>).reshape(<span class=\"number\">4</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;第一个数组：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;默认分割（0轴）：&#x27;</span>)</span><br><span class=\"line\">b = np.split(a,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;沿水平方向分割：&#x27;</span>)</span><br><span class=\"line\">c = np.split(a,<span class=\"number\">2</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;沿水平方向分割：&#x27;</span>)</span><br><span class=\"line\">d= np.hsplit(a,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(d)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"数组元素的添加与删除\"><a class=\"anchor\" href=\"#数组元素的添加与删除\">#</a> 数组元素的添加与删除</h2>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>元素及描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>resize</td>\n<td>返回指定形状的新数组</td>\n</tr>\n<tr>\n<td>append</td>\n<td>将值添加到数组末尾</td>\n</tr>\n<tr>\n<td>insert</td>\n<td>沿指定轴将值插入到指定下标之前</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>删掉某个轴的子数组，并返回删除后的新数组</td>\n</tr>\n<tr>\n<td>unique</td>\n<td>查找数组内的唯一元素</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\">b = np.resize(a, (<span class=\"number\">3</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">c = np.resize(a, (<span class=\"number\">4</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;b:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;c:&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.append(a, [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.append(a, [[<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]], axis=<span class=\"number\">0</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.append(a, [[<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]], axis=<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>], [<span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;未传递Axis参数，在删除之前输入数组会被展开&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.insert(a, <span class=\"number\">3</span>, [<span class=\"number\">11</span>, <span class=\"number\">12</span>]))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;未传递Axis参数，会广播值数组来匹配输入数组&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.insert(a, <span class=\"number\">1</span>, <span class=\"number\">11</span>, axis=<span class=\"number\">0</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.insert(a, <span class=\"number\">1</span>, <span class=\"number\">11</span>, axis=<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.arange(<span class=\"number\">12</span>).reshape(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;未传递Axis参数，在删除之前输入数组会被展开&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.delete(a, <span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;删除第二列：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.delete(a, <span class=\"number\">1</span>, axis=<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;包含从数组中删除的替代值的切片：&quot;</span>)</span><br><span class=\"line\">a = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.delete(a, np.s_[::<span class=\"number\">2</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = np.array([<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;第一个数组的去重值：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.unique(a))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;去重数组的索引数组：&quot;</span>)</span><br><span class=\"line\">u, indices = np.unique(a, return_index=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(indices)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;去重数组的下标：&quot;</span>)</span><br><span class=\"line\">u, indices = np.unique(a, return_inverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(indices)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(u[indices])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;返回去重元素的重复数量：&quot;</span>)</span><br><span class=\"line\">u, indices = np.unique(a, return_counts=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(u)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(indices)</span><br></pre></td></tr></table></figure>\n<h2 id=\"位运算\"><a class=\"anchor\" href=\"#位运算\">#</a> 位运算</h2>\n<p>略</p>\n<h2 id=\"字符串函数\"><a class=\"anchor\" href=\"#字符串函数\">#</a> 字符串函数</h2>\n<p>虽然似乎用不上（主要是看累了），但还是把表列出来</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add()</td>\n<td>对两个数组的逐个字符串元素进行连接</td>\n</tr>\n<tr>\n<td>multiply()</td>\n<td>返回按元素多重连接后的字符串</td>\n</tr>\n<tr>\n<td>center()</td>\n<td>居中字符串</td>\n</tr>\n<tr>\n<td>capitalize()</td>\n<td>将字符串第一个字母转换为大写</td>\n</tr>\n<tr>\n<td>title()</td>\n<td>将字符串的每个单词的第一个字母转换为大写</td>\n</tr>\n<tr>\n<td>lower()</td>\n<td>数组元素转换为小写</td>\n</tr>\n<tr>\n<td>upper()</td>\n<td>数组元素转换为大写</td>\n</tr>\n<tr>\n<td>split()</td>\n<td>指定分隔符对字符串进行分割，并返回数组列表</td>\n</tr>\n<tr>\n<td>splitlines()</td>\n<td>返回元素中的行列表，以换行符分割</td>\n</tr>\n<tr>\n<td>strip()</td>\n<td>移除元素开头或者结尾处的特定字符</td>\n</tr>\n<tr>\n<td>join()</td>\n<td>通过指定分隔符来连接数组中的元素</td>\n</tr>\n<tr>\n<td>replace()</td>\n<td>使用新字符串替换字符串中的所有子字符串</td>\n</tr>\n<tr>\n<td>decode()</td>\n<td>数组元素依次调用 str.decode</td>\n</tr>\n<tr>\n<td>encode()</td>\n<td>数组元素依次调用 str.encode</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;连接两个字符串：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.char.add([<span class=\"string\">&quot;hello&quot;</span>], [<span class=\"string\">&quot; xyz&quot;</span>]))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;连接示例：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.char.add([<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;hi&quot;</span>], [<span class=\"string\">&quot; abc&quot;</span>, <span class=\"string\">&quot; xyz&quot;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.char.multiply(<span class=\"string\">&quot;Runoob &quot;</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分隔符默认为空格</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.char.split(<span class=\"string\">&quot;i love you&quot;</span>))</span><br><span class=\"line\"><span class=\"comment\"># 分隔符指定</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.char.split(<span class=\"string\">&quot;www.baidu.com&quot;</span>, sep=<span class=\"string\">&quot;.&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># numpy.char.splitlines() 函数以换行符作为分隔符来分割字符串，并返回数组。</span></span><br><span class=\"line\"><span class=\"comment\"># 换行符 \\n</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.char.splitlines(<span class=\"string\">&#x27;i\\nlike runoob?&#x27;</span>)) </span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.char.splitlines(<span class=\"string\">&#x27;i\\rlike runoob?&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 操作字符串</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.char.join(<span class=\"string\">&#x27;:&#x27;</span>,<span class=\"string\">&#x27;runoob&#x27;</span>))</span><br><span class=\"line\"><span class=\"comment\"># 指定多个分隔符操作数组元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.char.join([<span class=\"string\">&#x27;:&#x27;</span>,<span class=\"string\">&#x27;-&#x27;</span>],[<span class=\"string\">&#x27;runoob&#x27;</span>,<span class=\"string\">&#x27;google&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.char.replace (<span class=\"string\">&#x27;i like runoob&#x27;</span>, <span class=\"string\">&#x27;oo&#x27;</span>, <span class=\"string\">&#x27;cc&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"数学函数\"><a class=\"anchor\" href=\"#数学函数\">#</a> 数学函数</h2>\n<ul>\n<li>np.sin()</li>\n<li>np.cos()</li>\n<li>np.tan()</li>\n<li>np.around () 四舍五入</li>\n<li>np.floor()</li>\n<li>np.ceil()</li>\n</ul>\n<h2 id=\"算术函数\"><a class=\"anchor\" href=\"#算术函数\">#</a> 算术函数</h2>\n<ul>\n<li>np.add()</li>\n<li>np.subtract()</li>\n<li>np.multiply()</li>\n<li>np.divide()</li>\n<li>np.reciprocal () 求倒数</li>\n<li>np.power () 幂函数</li>\n<li>np.mod () 取模</li>\n</ul>\n<h2 id=\"统计函数\"><a class=\"anchor\" href=\"#统计函数\">#</a> 统计函数</h2>\n<p>numpy.amin () 用于计算数组中的元素沿指定轴的最小值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.amin(a, axis=<span class=\"literal\">None</span>, out=<span class=\"literal\">None</span>, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</span><br></pre></td></tr></table></figure>\n<p>numpy.amax () 用于计算数组中的元素沿指定轴的最大值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.amax(a, axis=<span class=\"literal\">None</span>, out=<span class=\"literal\">None</span>, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li>a: 输入的数组，可以是一个 NumPy 数组或类似数组的对象。</li>\n<li>axis: 可选参数，用于指定在哪个轴上计算最小值。如果不提供此参数，则返回整个数组的最小值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴。</li>\n<li>out: 可选参数，用于指定结果的存储位置。</li>\n<li>keepdims: 可选参数，如果为 True，将保持结果数组的维度数目与输入数组相同。如果为 False（默认值），则会去除计算后维度为 1 的轴。</li>\n<li>initial: 可选参数，用于指定一个初始值，然后在数组的元素上计算最小值。</li>\n<li>where: 可选参数，一个布尔数组，用于指定仅考虑满足条件的元素。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">a = np.array([[<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">5</span>],[<span class=\"number\">8</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>]])  </span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;我们的数组是：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (a)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;调用 amin() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.amin(a,<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;再次调用 amin() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.amin(a,<span class=\"number\">0</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;调用 amax() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.amax(a))</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;再次调用 amax() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.amax(a, axis =  <span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure>\n<p>numpy.ptp () 函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.ptp(a, axis=<span class=\"literal\">None</span>, out=<span class=\"literal\">None</span>, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</span><br></pre></td></tr></table></figure>\n<p>numpy.percentile()<br />\n 百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数 numpy.percentile () 接受以下参数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.percentile(a, q, axis)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">a = np.array([[<span class=\"number\">10</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>], [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;我们的数组是：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (a)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;调用 percentile() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 50% 的分位数，就是 a 里排序之后的中位数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.percentile(a, <span class=\"number\">50</span>)) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># axis 为 0，在纵列上求</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.percentile(a, <span class=\"number\">50</span>, axis=<span class=\"number\">0</span>)) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># axis 为 1，在横行上求</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.percentile(a, <span class=\"number\">50</span>, axis=<span class=\"number\">1</span>)) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 保持维度不变</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.percentile(a, <span class=\"number\">50</span>, axis=<span class=\"number\">1</span>, keepdims=<span class=\"literal\">True</span>))</span><br></pre></td></tr></table></figure>\n<p>numpy.median () 函数用于计算数组 a 中元素的中位数（中值）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.median(a, axis=<span class=\"literal\">None</span>, out=<span class=\"literal\">None</span>, overwrite_input=<span class=\"literal\">False</span>, keepdims=&lt;no value&gt;)</span><br></pre></td></tr></table></figure>\n<p>numpy.mean () 函数返回数组中元素的算术平均值，如果提供了轴，则沿其计算。</p>\n<p>算术平均值是沿轴的元素的总和除以元素的数量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.mean(a, axis=<span class=\"literal\">None</span>, dtype=<span class=\"literal\">None</span>, out=<span class=\"literal\">None</span>, keepdims=&lt;no value&gt;)</span><br></pre></td></tr></table></figure>\n<p>numpy.average () 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。</p>\n<p>该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。</p>\n<p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。</p>\n<p>考虑数组 [1,2,3,4] 和相应的权重 [4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.average(a, axis=<span class=\"literal\">None</span>, weights=<span class=\"literal\">None</span>, returned=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">a = np.array([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>])  </span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;我们的数组是：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (a)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;调用 average() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.average(a))</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 不指定权重时相当于 mean 函数</span></span><br><span class=\"line\">wts = np.array([<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>])  </span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;再次调用 average() 函数：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.average(a,weights = wts))</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 如果 returned 参数设为 true，则返回权重的和  </span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;权重的和：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.average([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,  <span class=\"number\">4</span>],weights =  [<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>], returned =  <span class=\"literal\">True</span>))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>标准差：np.std ()<br />\n 方差：np.var ()</p>\n<h2 id=\"排序-条件筛选函数\"><a class=\"anchor\" href=\"#排序-条件筛选函数\">#</a> 排序、条件筛选函数</h2>\n<table>\n<thead>\n<tr>\n<th>种类</th>\n<th>速度</th>\n<th>最坏情况</th>\n<th>工作空间</th>\n<th>稳定性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>'quicksort'（快速排序）</td>\n<td>1</td>\n<td>O(n^2)</td>\n<td>0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>'mergesort'（归并排序）</td>\n<td>2</td>\n<td>O(n*log(n))</td>\n<td>~n/2</td>\n<td>是</td>\n</tr>\n<tr>\n<td>'heapsort'（堆排序）</td>\n<td>3</td>\n<td>O(n*log(n))</td>\n<td>0</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numpy.sort(a, axis, kind, order)</span><br></pre></td></tr></table></figure>\n<p>numpy.argsort () 函数返回的是数组值从小到大的索引值。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>msort(a)</td>\n<td>数组按第一个轴排序，返回排序后的数组副本。np.msort (a) 相等于 np.sort (a, axis=0)。</td>\n</tr>\n<tr>\n<td>sort_complex(a)</td>\n<td>对复数按照先实部后虚部的顺序进行排序。</td>\n</tr>\n<tr>\n<td>partition(a, kth[, axis, kind, order])</td>\n<td>指定一个数，对数组进行分区</td>\n</tr>\n<tr>\n<td>argpartition(a, kth[, axis, kind, order])</td>\n<td>可以通过关键字 kind 指定算法沿着指定轴对数组进行分区</td>\n</tr>\n</tbody>\n</table>\n<p>numpy.argmax () 和 numpy.argmin () 函数分别沿给定轴返回最大和最小元素的索引。</p>\n<p>numpy.nonzero () 函数返回输入数组中非零元素的索引。</p>\n<p>numpy.where () 函数返回输入数组中满足给定条件的元素的索引。</p>\n<p>numpy.extract () 函数根据某个条件从数组中抽取元素，返回满条件的元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\">x = np.arange(<span class=\"number\">9.</span>).reshape(<span class=\"number\">3</span>,  <span class=\"number\">3</span>)  </span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;我们的数组是：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (x)</span><br><span class=\"line\"><span class=\"comment\"># 定义条件, 选择偶数元素</span></span><br><span class=\"line\">condition = np.mod(x,<span class=\"number\">2</span>)  ==  <span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;按元素的条件值：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (condition)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;使用条件提取元素：&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (np.extract(condition, x))</span><br></pre></td></tr></table></figure>\n<h2 id=\"矩阵库npmatlib\"><a class=\"anchor\" href=\"#矩阵库npmatlib\">#</a> 矩阵库 np.matlib</h2>\n<ul>\n<li>matlib.empty () 函数返回一个新的矩阵</li>\n<li>numpy.matlib.zeros () 函数创建一个以 0 填充的矩阵。</li>\n<li>numpy.matlib.ones () 函数创建一个以 1 填充的矩阵。</li>\n<li>numpy.matlib.eye () 函数返回一个矩阵，对角线元素为 1，其他位置为零。</li>\n<li>numpy.matlib.identity () 函数返回给定大小的单位矩阵。</li>\n<li>numpy.matlib.rand () 函数创建一个给定大小的矩阵，数据是随机填充的。</li>\n</ul>\n<h2 id=\"线性代数\"><a class=\"anchor\" href=\"#线性代数\">#</a> 线性代数</h2>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dot</td>\n<td>两个数组的点积，即元素对应相乘。</td>\n</tr>\n<tr>\n<td>vdot</td>\n<td>两个向量的点积</td>\n</tr>\n<tr>\n<td>inner</td>\n<td>两个数组的内积</td>\n</tr>\n<tr>\n<td>matmul</td>\n<td>两个数组的矩阵积</td>\n</tr>\n<tr>\n<td>determinant</td>\n<td>数组的行列式</td>\n</tr>\n<tr>\n<td>solve</td>\n<td>求解线性矩阵方程</td>\n</tr>\n<tr>\n<td>inv</td>\n<td>计算矩阵的乘法逆矩阵</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"io\"><a class=\"anchor\" href=\"#io\">#</a> IO</h2>\n<p>savetxt () 函数是以简单的文本文件格式存储数据，对应的使用 loadtxt () 函数来获取数据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.loadtxt(FILENAME, dtype=<span class=\"built_in\">int</span>, delimiter=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">np.savetxt(FILENAME, a, fmt=<span class=\"string\">&quot;%d&quot;</span>, delimiter=<span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">a=np.arange(<span class=\"number\">0</span>,<span class=\"number\">10</span>,<span class=\"number\">0.5</span>).reshape(<span class=\"number\">4</span>,-<span class=\"number\">1</span>)</span><br><span class=\"line\">np.savetxt(<span class=\"string\">&quot;out.txt&quot;</span>,a,fmt=<span class=\"string\">&quot;%d&quot;</span>,delimiter=<span class=\"string\">&quot;,&quot;</span>) <span class=\"comment\"># 改为保存为整数，以逗号分隔</span></span><br><span class=\"line\">b = np.loadtxt(<span class=\"string\">&quot;out.txt&quot;</span>,delimiter=<span class=\"string\">&quot;,&quot;</span>) <span class=\"comment\"># load 时也要指定为逗号分隔</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br></pre></td></tr></table></figure>\n<h2 id=\"matlibplot\"><a class=\"anchor\" href=\"#matlibplot\">#</a> matlibPlot</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt </span><br><span class=\"line\"> </span><br><span class=\"line\">x = np.arange(<span class=\"number\">1</span>,<span class=\"number\">11</span>) </span><br><span class=\"line\">y =  <span class=\"number\">2</span>  * x +  <span class=\"number\">5</span> </span><br><span class=\"line\">plt.title(<span class=\"string\">&quot;Matplotlib demo&quot;</span>) </span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&quot;x axis caption&quot;</span>) </span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&quot;y axis caption&quot;</span>) </span><br><span class=\"line\">plt.plot(x,y) </span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt </span><br><span class=\"line\"><span class=\"comment\"># 计算正弦和余弦曲线上的点的 x 和 y 坐标 </span></span><br><span class=\"line\">x = np.arange(<span class=\"number\">0</span>,  <span class=\"number\">3</span>  * np.pi,  <span class=\"number\">0.1</span>) </span><br><span class=\"line\">y_sin = np.sin(x) </span><br><span class=\"line\">y_cos = np.cos(x)  </span><br><span class=\"line\"><span class=\"comment\"># 建立 subplot 网格，高为 2，宽为 1  </span></span><br><span class=\"line\"><span class=\"comment\"># 激活第一个 subplot</span></span><br><span class=\"line\">plt.subplot(<span class=\"number\">2</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>)  </span><br><span class=\"line\"><span class=\"comment\"># 绘制第一个图像 </span></span><br><span class=\"line\">plt.plot(x, y_sin) </span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Sine&#x27;</span>)  </span><br><span class=\"line\"><span class=\"comment\"># 将第二个 subplot 激活，并绘制第二个图像</span></span><br><span class=\"line\">plt.subplot(<span class=\"number\">2</span>,  <span class=\"number\">1</span>,  <span class=\"number\">2</span>) </span><br><span class=\"line\">plt.plot(x, y_cos) </span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Cosine&#x27;</span>)  </span><br><span class=\"line\"><span class=\"comment\"># 展示图像</span></span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"><span class=\"comment\"># pyplot 子模块提供 bar() 函数来生成条形图。</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt </span><br><span class=\"line\">x =  [<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>] </span><br><span class=\"line\">y =  [<span class=\"number\">12</span>,<span class=\"number\">16</span>,<span class=\"number\">6</span>] </span><br><span class=\"line\">x2 =  [<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">11</span>] </span><br><span class=\"line\">y2 =  [<span class=\"number\">6</span>,<span class=\"number\">15</span>,<span class=\"number\">7</span>] </span><br><span class=\"line\">plt.bar(x, y, align =  <span class=\"string\">&#x27;center&#x27;</span>) </span><br><span class=\"line\">plt.bar(x2, y2, color =  <span class=\"string\">&#x27;g&#x27;</span>, align =  <span class=\"string\">&#x27;center&#x27;</span>) </span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Bar graph&#x27;</span>) </span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&#x27;Y axis&#x27;</span>) </span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&#x27;X axis&#x27;</span>) </span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "代码",
                "python",
                "学习笔记",
                "python"
            ]
        },
        {
            "id": "http://amentiraz.github.io/life/MeetingJazz2025-04-26/",
            "url": "http://amentiraz.github.io/life/MeetingJazz2025-04-26/",
            "title": "MeetingJazz2025-04-26",
            "date_published": "2025-04-26T09:26:02.000Z",
            "content_html": "<p>不仅是第一次来爵士酒吧，也是第一次来酒吧，有吧台，有调酒师，舞台上面摆着乐器，总共有 60、70 个观众的席位，意外的是座位基本都是满的，可能是周日晚上大家都来最后的放纵了吧。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/MeetingJazz2025-04-26-1.jpg\" alt=\"\" /><br />\n先说酒，点的 “古典”（old fashion），外表上看，在酒吧内昏暗的灯光下散发着橘子皮的光芒，里面融着一块冰块，冰块上点缀着柠檬皮。第一口下去没怎么注意，喝的稍许偏多，且没怎么过舌头的味蕾。酒水在口腔中荡漾时不知是不是冰的原因，显得十分润滑且没品出酒味，直到酒水过到喉咙里味道才绽放出来。第一反应是很润滑，感觉酒水是粘稠在一起的，伴随而来的便是一阵苦涩的味道来对酒味进行中和，而这苦味也显得很合适，刚好在酸味中和的差不多时便随之消散。酒味并没有那么冲，直到酒水入肚，酒气才慢慢上到头脑，整体来说还是很不错的。等喝着差不多一半的时候，那种又冰所带来的润滑的感觉逐渐消散了，苦味占据了高地，喝下去虽然没有那种涩的感觉，而且苦味消散的也很快，但确实是缺少了最开始粘稠的感觉。喝到最后的时候，得益于冰的融化，甜味重新占领了味觉，不知是不是柠檬的原因，口感十分的清爽。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/MeetingJazz2025-04-26-2.jpg\" alt=\"\" /><br />\n来的时候我并不知道演出的内容是什么，表演者是两位男士，也没有什么预热，直接便开始了演奏。一位负责弹奏电子琴，另一位则负责 voicing 的部分。第一首曲子是十分经典的《Autumn Leaves》。说实话，一开始我并没有听出来，最开始的旋律比起《Autumn Leaves》更像是《贝加尔湖畔》，正当我困惑的时候，也不是因为旋律很明显，反倒是因为和弦走向比较熟悉，很快便意识到了他们在弹什么。他们也没有背稿，很明显就是全程的即兴。虽然我听不出来他们弹的是什么音阶，但是很多地方都很有个人的色彩，例如钢琴师总是不舒舒服服的去解决和弦，而是留有一些余地就紧接着下面的乐句了。人声部分主要是那个人在哼哼，利用人声去模拟 Bass 或者吉他的那种弹 solo 的感觉。That's True Music。我目前的音乐鉴赏水平来说，或者说我的音乐审美来说，我是比较排斥人声的。音乐难道不就是音高、音响和音色的组合吗，为什么非要假如歌词这种其它形式的类似诗词的东西进来。在我看来，虽然歌词能够辅助人去理解音乐，但就像人透过语言去了解一个人一样，虽然门槛降低了，这难道不也是一种对事物本身的一种阉割吗？当然可能是我偏激了。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/MeetingJazz2025-04-26-3.png\" alt=\"\" /><br />\n虽说有 60 多个观众，但大部分人目测是没怎么接触过爵士的，更多是来作为一个清净的，看起来还很高雅的地方来供人们社交。也有能看出来是冲着爵士来的，最前面有一位男大学生，一个人来的，坐的笔直；坐在我们右边的应该是一对俄罗斯夫妇，当演奏出现那种很有意思的段子的时候他们发自内心的笑容也让人感到音乐的魅力。还有一对情侣一个外国男生和一个中国女生，看起来那个外国男生比较拘束，但不时和女生在聊演奏的内容。坐的靠远的地方是 5、6 位男大学生，有一位卖弄地向他的朋友说着曲子。</p>\n<p>我只听了四首歌，从 8：30 开始的演奏听到 10：40 实在熬不住便先行离开了。中间除了开始的《Autumn Leaves》，中间的两首歌都没有听出来是什么标准曲，这里面其中一首是 voicing 报幕时坦言自己很喜欢的曲目，他演奏起来也是十分的惬意，和钢琴手相互呼应，你哼一段乐句，我对上一段 solo，炫技成分很高但大家都玩的开心，观众也看得开心。最后一首是《All of Me》，由于我也没听太多的爵士曲，险些没有听出来，虽然都是标准曲，也都是即兴的演奏，但也挺不错的了。</p>\n<p>以后应该还会来，下次挑一场有吉他的学学技术。综合评价来说能给到 7 分。</p>\n",
            "tags": [
                "生活",
                "演奏会",
                "生活",
                "音乐"
            ]
        },
        {
            "id": "http://amentiraz.github.io/code/NeoVim%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/",
            "url": "http://amentiraz.github.io/code/NeoVim%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/",
            "title": "LazyVim学习笔记-安装LazyVim",
            "date_published": "2025-04-24T06:33:12.000Z",
            "content_html": "<p>感觉这个东西配起来十分的恶心，我打算按照<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sYXp5dmltLWFtYml0aW91cy1kZXZzLnBoaWxsaXBzLmNvZGVzL2NvdXJzZS9jaGFwdGVyLTEvI19pbnN0YWxsX2xhenl2aW0=\">官方</span>的操作来做一遍。</p>\n<p>一方面自己大四闲的要死，找点事做总是好的，另一方面网络上确实关于 lazyvim 的教程要么收费，要么浅尝辄止没有深入或系统的指导，所以我自己开个坑，希望能系统而全面的介绍在 windows 系统下的对于 LazyVim 和 NeoVim 的使用和书写方法。</p>\n<p>当然我也没学过 lua，若有不够严谨的地方多多包涵。</p>\n<h1 id=\"windows-terminal\"><a class=\"anchor\" href=\"#windows-terminal\">#</a> Windows Terminal</h1>\n<p>首先我们参考官方推荐的在 Windows 使用的终端。</p>\n<p>推荐安装 Windows Terminal，然后再打开系统自带的 PowerShell，这里可以直接在<em>开始菜单</em>搜索 Power Shell，效果如下：</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim1.png\" alt=\"neovim1\" /></p>\n<p>然后可以去<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmVyZGZvbnRzLmNvbS9mb250LWRvd25sb2Fkcw==\"> Nerd Font</span> 中下载自己感兴趣的字体，这里我使用的是<em> JetBrainsMono Nerd Font</em>, 解压安装包，双击其中一个 ttf 文件，点击安装。然后重新打开 PowerShell，点击上方的倒三角，点击设置，即可设置字体。<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim2.png\" alt=\"\" /></p>\n<h1 id=\"neovim安装\"><a class=\"anchor\" href=\"#neovim安装\">#</a> NeoVim 安装</h1>\n<p>去<span class=\"exturl\" data-url=\"aHR0cHM6Ly9uZW92aW0uaW8v\">官网</span>安装。<br />\n我的 Windows 杂七杂八安装了太多东西，例如 WSL，所以有的问题可能我没遇到但是作者提及了。</p>\n<blockquote>\n<p>在 Windows 上，我建议使用 Windows Linux 子系统 (WSL) 并在其中进行所有开发。WSL 远远超出了本书的讨论范围，但微软和许多在线教程都对它进行了详尽的说明。选择兼容 WSL 的 Linux 发行版、进行设置并在所选终端中运行后，即可按照以下 Linux 说明安装 Neovim。</p>\n<p>如果您有理由（或偏好）在原生 Windows 上进行开发，最简单的方法是从 GitHub 上的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25lb3ZpbS9uZW92aW0v\"> neovim/neovim</span> 存储库的发布部分获取 MSI 安装程序。</p>\n<p>如果您已经使用 Winget、Chocolatey 或 Scoop 来管理 Windows 机器上的包，那么它们每个中都有一个 Neovim 包。</p>\n<p>请注意，如果您使用的 Windows 系统没有 WSL，则还需要安装 C 编译器才能获得 treesitter 支持（这基本上意味着更好的语法高亮和代码导航支持）。遗憾的是，这并非易事。相关文档已记录在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL252aW0tdHJlZXNpdHRlci9udmltLXRyZWVzaXR0ZXI=\">nvim-treesitter/nvim-treesitter</span> GitHub 仓库中，因此我在此不再赘述。</p>\n</blockquote>\n<p>这里可以先跳过这个所谓的 C 语言编译的板块，后面遇到了再做处理。</p>\n<h1 id=\"安装lazyvim\"><a class=\"anchor\" href=\"#安装lazyvim\">#</a> 安装 LazyVim</h1>\n<p>一般我们涉及到的文件夹是在  <code>C:\\Users\\你的名字\\AppData\\Local</code>  下的 nvim (自己创建的) 和 nvim-data 文件夹，这里先对它们进行清空。<br />\n然后我们便可以克隆 LazyVim 的启动模板，然后删除.git 文件夹（要是 powershell 内删不了直接手动定位过去删除一样的）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/LazyVim/starter <span class=\"variable\">$env</span>:LOCALAPPDATA\\nvim</span><br><span class=\"line\">Remove-Item <span class=\"variable\">$env</span>:LOCALAPPDATA\\nvim\\.git -Recurse -Force</span><br></pre></td></tr></table></figure>\n<p>在 PowerShell 中输入 nvim 回车，等待它下载。</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim3.png\" alt=\"\" /><br />\n然后就进入到 LazyVim 界面了<br />\n<img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim4.png\" alt=\"\" /></p>\n<p>按 l 键可以进入插件管理界面，Lazy.nvim 拥有众多实用功能，其中最引人注目的是仅在需要时加载插件（因此得名 “Lazy”），这样你的编辑器启动速度就能飞快。它还拥有一个美观的用户界面，方便管理插件的安装和更新。如下图所示</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim5.png\" alt=\"\" /></p>\n<h1 id=\"插件的安装\"><a class=\"anchor\" href=\"#插件的安装\">#</a> 插件的安装</h1>\n<h2 id=\"markdown-preview\"><a class=\"anchor\" href=\"#markdown-preview\">#</a> markdown-preview</h2>\n<p>我自己有写日志的习惯，所以我首先安装了对于 Markdown 的相关配置<br />\n我在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3RmeWxlLmNvbS9uZW92aW0vcGx1Z2lucy90cmVuZGluZw==\">这个网站</span>搜索 markdown，并选择了 markdown-preview 插件，然后我们可以看到它提供的相关代码：</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim6.png\" alt=\"\" /></p>\n<p>接下来我们可以在./lua/plugins/ 下创建 markdown-preview.lua 文件，并在文件中写入 return 加上大括号里面的内容即可。同时我们也可以进入它提供的 github 的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lhbWNjby9tYXJrZG93bi1wcmV2aWV3Lm52aW0=\">官网</span>。在 MarkdownPreview Config 中可以看到它默认的配置和相关的键位。这里我认为 MarkdownPreview 指令太长了，于是我改了一下键位，并且设置了不自动预览和当离开 markdown buffer 时 Zion 给关闭浏览器预览。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;iamcco/markdown-preview.nvim&quot;</span>,</span><br><span class=\"line\">  build = <span class=\"string\">&quot;cd app &amp;&amp; npm install&quot;</span>,</span><br><span class=\"line\">  ft = &#123; <span class=\"string\">&quot;markdown&quot;</span> &#125;,</span><br><span class=\"line\">  cmd = &#123; <span class=\"string\">&quot;MarkdownPreview&quot;</span>, <span class=\"string\">&quot;MarkdownPreviewStop&quot;</span>, <span class=\"string\">&quot;MarkdownPreviewToggle&quot;</span> &#125;,</span><br><span class=\"line\">  init = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    vim.g.mkdp_auto_start = <span class=\"number\">0</span></span><br><span class=\"line\">    vim.g.mkdp_auto_close = <span class=\"number\">1</span></span><br><span class=\"line\">    vim.g.mkdp_refresh_slow = <span class=\"number\">0</span></span><br><span class=\"line\">    vim.g.mkdp_open_to_the_world = <span class=\"literal\">false</span></span><br><span class=\"line\">    vim.g.mkdp_browser = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    vim.g.mkdp_theme = <span class=\"string\">&quot;dark&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span>,</span><br><span class=\"line\">  keys = &#123;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;&lt;leader&gt;mp&quot;</span>, <span class=\"string\">&quot;&lt;cmd&gt;MarkdownPreviewToggle&lt;cr&gt;&quot;</span>, desc = <span class=\"string\">&quot;Toggle Markdown Preview&quot;</span> &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中文标红的解决\"><a class=\"anchor\" href=\"#中文标红的解决\">#</a> 中文标红的解决</h2>\n<p>在写 markdown 文档时我发现中文的字符往往由于拼写检查标红了。我又添加了拼写检查英文、中日韩都合法的操作，完整的代码如下</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;iamcco/markdown-preview.nvim&quot;</span>,</span><br><span class=\"line\">  build = <span class=\"string\">&quot;cd app &amp;&amp; npm install&quot;</span>,</span><br><span class=\"line\">  ft = &#123; <span class=\"string\">&quot;markdown&quot;</span> &#125;,</span><br><span class=\"line\">  cmd = &#123; <span class=\"string\">&quot;MarkdownPreview&quot;</span>, <span class=\"string\">&quot;MarkdownPreviewStop&quot;</span>, <span class=\"string\">&quot;MarkdownPreviewToggle&quot;</span> &#125;,</span><br><span class=\"line\">  init = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    vim.g.mkdp_auto_start = <span class=\"number\">0</span></span><br><span class=\"line\">    vim.g.mkdp_auto_close = <span class=\"number\">1</span></span><br><span class=\"line\">    vim.g.mkdp_refresh_slow =  <span class=\"number\">0</span></span><br><span class=\"line\">    vim.g.mkdp_open_to_the_world = <span class=\"literal\">false</span></span><br><span class=\"line\">    vim.g.mkdp_browser = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    vim.g.mkdp_theme = <span class=\"string\">&quot;dark&quot;</span></span><br><span class=\"line\">    vim.api.nvim_create_autocmd(<span class=\"string\">&quot;FileType&quot;</span>, &#123;</span><br><span class=\"line\">      pattern = <span class=\"string\">&quot;markdown&quot;</span>,</span><br><span class=\"line\">      callback = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">        vim.opt.spell = <span class=\"literal\">true</span></span><br><span class=\"line\">        vim.opt.spelllang = &#123; <span class=\"string\">&quot;en&quot;</span>, <span class=\"string\">&quot;cjk&quot;</span> &#125;</span><br><span class=\"line\">      <span class=\"keyword\">end</span>,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">end</span>,</span><br><span class=\"line\">  keys = &#123;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;&lt;leader&gt;mp&quot;</span>, <span class=\"string\">&quot;&lt;cmd&gt;\\begin&#123;figure&#125;</span></span><br><span class=\"line\"><span class=\"string\">    \\centering</span></span><br><span class=\"line\"><span class=\"string\">    \\includegraphics[width=1\\linewidth]&#123;bioPic.png&#125;</span></span><br><span class=\"line\"><span class=\"string\">    \\caption&#123;Human Liver和Stereo-seq的空间域划分&#125;</span></span><br><span class=\"line\"><span class=\"string\">    \\label&#123;fig:enter-label&#125;</span></span><br><span class=\"line\"><span class=\"string\">\\end&#123;figure&#125;MarkdownPreviewToggle&lt;cr&gt;&quot;</span>, desc = <span class=\"string\">&quot;Toggle Markdown Preview&quot;</span> &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;\\begin&#123;figure&#125;</span><br><span class=\"line\">    \\centering</span><br><span class=\"line\">    \\includegraphics[width=<span class=\"number\">1</span>\\linewidth]&#123;bioPic.png&#125;</span><br><span class=\"line\">    \\caption&#123;Human Liver和Stereo-seq的空间域划分&#125;</span><br><span class=\"line\">    \\label&#123;fig:enter-label&#125;</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置ai\"><a class=\"anchor\" href=\"#配置ai\">#</a> 配置 AI</h2>\n<p>在 PowerShell 中输入 nvim 回车，输入 x 进入 Lazy Extras，然后找到 copilot，定位到对应的位置输入 x 启用。重新进入 nvim。输入 <code>:Copilot auth</code>  启用账户并按照提示操作，具体是找到对应的弹窗，进入它提示的网址，输入弹窗给出的验证码进入 github 进行验证。验证完毕后即可使用。具体操作我简单试了一下 Copilot-bot，应该还具有代码补全的操作：</p>\n<p><img data-src=\"https://amentirazblogpic.oss-cn-hangzhou.aliyuncs.com/blogpic/neovim7.png\" alt=\"\" /></p>\n<h1 id=\"个性化的一些设置\"><a class=\"anchor\" href=\"#个性化的一些设置\">#</a> 个性化的一些设置</h1>\n<h2 id=\"打开terminal时自动定位到当前文件夹\"><a class=\"anchor\" href=\"#打开terminal时自动定位到当前文件夹\">#</a> 打开 terminal 时自动定位到当前文件夹</h2>\n<p>考虑到跑 python 代码时，重新 ding</p>\n",
            "tags": [
                "代码",
                "NeoVim",
                "代码",
                "neoVim",
                "LazyVim"
            ]
        }
    ]
}