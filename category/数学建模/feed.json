{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amentiraz • All posts by \"数学建模\" category",
    "description": "",
    "home_page_url": "http://Amentiraz.github.io",
    "items": [
        {
            "id": "http://amentiraz.github.io/2021/10/03/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/",
            "url": "http://amentiraz.github.io/2021/10/03/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/",
            "title": "插值算法",
            "date_published": "2021-10-03T08:21:52.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-jiymPaoF\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"502455381\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>插值算法主要运用于在数学建模竞赛中，现有的数据极少，不足以支撑分析的进行，这时候就需要使用一些数学的方法<br>\n插值的作用，“模拟产生” 一些新的但又比较靠谱的值来满足需求</p>\n<span id=\"more\"></span>\n<h3 id=\"一维插值问题\"><a class=\"markdownIt-Anchor\" href=\"#一维插值问题\">#</a> 一维插值问题</h3>\n<h4 id=\"问题如下\"><a class=\"markdownIt-Anchor\" href=\"#问题如下\">#</a> 问题如下：</h4>\n<p>已经有 n+1 个节点 (xi,yi)(i=0,1,…,n), 其中 xi 互不相同，不妨设 a &lt;= x0 &lt; x1 &lt; … &lt; xn &lt;= b , 求任一插值点 x * （不等于 xi）处的插值 y *<br>\n 思路：构造 y=f (x), 使得 f (x) 过所有节点，即可得到 y *</p>\n<h4 id=\"插值法的概念\"><a class=\"markdownIt-Anchor\" href=\"#插值法的概念\">#</a> 插值法的概念</h4>\n<p>设函数 y=f (x) 在区间 [a,b] 上有定义，且已知在点 a&lt;= x0 &lt; x1 &lt; … &lt; xn &lt;= b 上的值分别为 y0 , y1 , … , yn<br>\n 若存在一简单函数 P (x) 使 P (xi) = yi ( i = 0 , 1 , 2 , … , n ) 则称 P (x) 为 f (x) 的插值函数，点 x0,x1,…,xn 称为插值节点，包含插值节点的区间 [a,b] 称为插值区间<br>\n求插值函数 P (x) 的方法称为插值法<br>\n插值法是不唯一的<br>\n代数多项式：若 P (x) 是次数不超过 n 的代数多项式，即 P (x) = a0 + a1x + … + anx^n<br>\n 分段插值：若 P (x) 为分段多项式，就称为分段插值<br>\n三角插值：若 P (x) 为三角多项式，就称为三角插值（不予讨论）（一般要用到傅立叶变换等复杂的数学工具）<br>\n一般来讲三角插值适用于对周期函数的插值（三角函数嘛）</p>\n<h4 id=\"插值法原理\"><a class=\"markdownIt-Anchor\" href=\"#插值法原理\">#</a> 插值法原理</h4>\n<p>定理：设有 n+1 个互不相同的节点 (xi,yi)(i=0,1,2,…,n) 则存在唯一的多项式：<br>\nLn (x) = a0 + a1x + … + anx^n   使得 Ln (xj) = yj (j=0,1,2,…n)<br>\n 证 构造方程组<br>\n「a0 + a1x0 + … + anx0^n = y0<br>\na0 + a1x1 + … + anx1^n = y1<br>\n…<br>\na0 + a1xn + … + anxn^n = yn  」</p>\n<p>图片：</p>\n<h4 id=\"拉格朗日插值法\"><a class=\"markdownIt-Anchor\" href=\"#拉格朗日插值法\">#</a> 拉格朗日插值法</h4>\n<p>在数值分析中，拉格朗日插值法是以法国十八世纪数学家约瑟夫・拉格朗日命名的一种多项式插值方法。如对实践中的某个物理量进行观测，在若干个不同的地方得到相应的观测值，拉格朗日插值法可以找到一个多项式，其恰好在各个观测的点取到观测到的值。这样的多项式称为拉格朗日（插值）多项式。<br>\n对于两个点：(x0,y0) , (x1,y1)<br>\nf(x) = ( x - x1 ) y0 / ( x0 - x1 ) + ( x - x0 ) y1 / ( x1 - x0 )<br>\n 对于三个点：(x0,y0),(x1,y1),(x2,y2)<br>\nf(x) = [ ( x - x1 ) ( x - x2 ) y0 ] / [ ( x0 - x1 ) ( x0 - x2 ) ]</p>\n<ul>\n<li>[ ( x - x0 ) ( x - x2 ) y1 ] / [ ( x1 - x0 ) ( x1 - x2 ) ]</li>\n<li>[ ( x - x0 ) ( x - x1 ) y2 ] / [ ( x2 - x0 ) ( x2 - x1 ) ]<br>\n 我们可以归纳发现，这种式子如果取其中的一个 xi 取得的值必定是 yi，因为其它项为 0，对应的 xi 的 yi 的系数必定为 1<br>\n<img data-src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gv3e0n9uf2j60mt09774y02.jpg\" alt=\"\"><br>\n 然而我们实际情况中却不可能用拉格朗日插值法，他有很多问题</li>\n</ul>\n<h4 id=\"龙格现象\"><a class=\"markdownIt-Anchor\" href=\"#龙格现象\">#</a> 龙格现象</h4>\n<p>图片 1:<br>\n 图片 2:<br>\n 这引出了两个问题</p>\n<ol>\n<li>插值多项式次数高，精度未必显著提高</li>\n<li>插值多项式次数越高，摄入误差可能显著增大<br>\n我们可以得到，对于高次的多项式插值时，如果我们不确定曲线的类型，我们尽量不要使用<br>\n那么如何提高插值精度呢<br>\n采用分段线性插值</li>\n</ol>\n<h3 id=\"分段插值\"><a class=\"markdownIt-Anchor\" href=\"#分段插值\">#</a> 分段插值</h3>\n<h4 id=\"分段线性插值\"><a class=\"markdownIt-Anchor\" href=\"#分段线性插值\">#</a> 分段线性插值</h4>\n<p>如果我们要在中间找一个值，我们找距离它最近的两点，两点之间连一条线段，直接在这条线段上找 x 对应的 y 值即可<br>\n这种插值是十分简单的，也是不精准的</p>\n<h4 id=\"分段二次插值\"><a class=\"markdownIt-Anchor\" href=\"#分段二次插值\">#</a> 分段二次插值</h4>\n<p>分段二次插值也是非常简单的，我们可以寻找距离这个插入点最近的三个点，三个点可以形成一个二次函数，同理可以直接取二次函数的值<br>\n分段二次插值又称为分段抛物线插值</p>\n<h4 id=\"牛顿插值法\"><a class=\"markdownIt-Anchor\" href=\"#牛顿插值法\">#</a> 牛顿插值法・</h4>\n",
            "tags": [
                "数学建模",
                "插值算法"
            ]
        },
        {
            "id": "http://amentiraz.github.io/2021/09/22/TOPSIS-MATLAB/",
            "url": "http://amentiraz.github.io/2021/09/22/TOPSIS-MATLAB/",
            "title": "TOPSIS-MATLAB",
            "date_published": "2021-09-22T10:35:13.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-NKUgVpPc\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"1401456829\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>代码如下</p>\n<span id=\"more\"></span>\n<h3 id=\"主函数代码\"><a class=\"markdownIt-Anchor\" href=\"#主函数代码\">#</a> 主函数代码</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;clc</span><br><span class=\"line\">load data_water_quality.mat</span><br><span class=\"line\">//正向化</span><br><span class=\"line\">[n,m] = size ( X ) ;</span><br><span class=\"line\">disp ( [&#x27;共有&#x27;num2str ( n ) &#x27;个评价对象,&#x27;num2str ( m ) &#x27;个评价指标] ) </span><br><span class=\"line\">Judge = input ([&#x27;这&#x27;num2str(m)&#x27;个指标是否需要经过正向化处理，需要输入1，不需要输入0:&#x27;]);</span><br><span class=\"line\">if Judge == 1 </span><br><span class=\"line\">    Position = input (&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]:&#x27;) ; </span><br><span class=\"line\">    disp ( &#x27;请输入需要处理的这些列的指标类型（1:极小型，2:中间型，3:区间型）&#x27;) </span><br><span class=\"line\">    Type = input (&#x27;例如2极小，3区间，6中间就输入[1,3,2]:&#x27; ) ;</span><br><span class=\"line\">    for i = 1 : size ( Position , 2 ) </span><br><span class=\"line\">    X ( : , Position ( i ) ) = Positivization ( X ( : , Position ( i )  ) , Type ( i ) , Position ( i ) ) ;</span><br><span class=\"line\">    //Positization是我们定义的函数</span><br><span class=\"line\">    end</span><br><span class=\"line\">    disp (&#x27;正向化后的举证X=&#x27; ) </span><br><span class=\"line\">    disp ( X ) </span><br><span class=\"line\">end</span><br><span class=\"line\">//对正向化对举证进行标准化</span><br><span class=\"line\">Z = X ./ repmat ( sum ( X .* X ) .^ 0.5 , n , 1 ) ;</span><br><span class=\"line\">disp ( &#x27;标准化矩阵Z=&#x27; ） </span><br><span class=\"line\">disp (Z) </span><br><span class=\"line\">//计算最大值与最小值的距离，并算出得分</span><br><span class=\"line\">D_P = sum ( [Z - repmat ( max ( Z ) , n , 1 ) .^ 2 ] , 2 ) .^ 0.5 ; </span><br><span class=\"line\">D_N = sum ( [Z - repmat ( min ( Z ) , n , 1 ) .^ 2 ] , 2 ) .^ 0.5 ;   </span><br><span class=\"line\">S = D_N ./ ( D_P + D_N ) ; </span><br><span class=\"line\">disp ( &#x27;最后的得分为：&#x27; ) </span><br><span class=\"line\">stand_S = S / sum ( S ) </span><br><span class=\"line\">[sorted_S , index] = sort ( stand_S , &#x27;descend&#x27; ) </span><br></pre></td></tr></table></figure>\n<h3 id=\"positivization函数\"><a class=\"markdownIt-Anchor\" href=\"#positivization函数\">#</a> Positivization 函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ posit_x ] = Positivization ( x , type , i ) </span><br><span class=\"line\">    if type == 1 </span><br><span class=\"line\">    disp([&#x27;第&#x27;num2str ( i ) &#x27;列是极小型，正在正向化&#x27;]) </span><br><span class=\"line\">    posit_x = Min2Max ( x ) ; </span><br><span class=\"line\">    disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成])</span><br><span class=\"line\">    disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;)</span><br><span class=\"line\">    else if type == 2 </span><br><span class=\"line\">    dis ( [&#x27;第&#x27;num2str ( i ) &#x27;列是中间型&#x27;])</span><br><span class=\"line\">    best = input (&#x27;请输入最佳的那一个值:&#x27;) ; </span><br><span class=\"line\">    posit_x = Mid2Max ( x , best ) ; </span><br><span class=\"line\">    disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成]) ;</span><br><span class=\"line\">    disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;)</span><br><span class=\"line\">    else if type == 3                                          </span><br><span class=\"line\">    dis ( [&#x27;第&#x27;num2str ( i ) &#x27;列是区间型&#x27;])                    </span><br><span class=\"line\">    a = input (&#x27;请输入区间的下界&#x27;) ;                   </span><br><span class=\"line\">    b = input (&#x27;请输入区间的上界&#x27;) ;         </span><br><span class=\"line\">    posit_x = Inter2Max ( x , a , b ) ;                           </span><br><span class=\"line\">    disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成]) ;              </span><br><span class=\"line\">    disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;)</span><br><span class=\"line\">    else </span><br><span class=\"line\">    disp (&#x27;没有这种类型的指标请检查Type向量中是否有除了1、2、3以外的其他值&#x27;) </span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"min2maxx函数\"><a class=\"markdownIt-Anchor\" href=\"#min2maxx函数\">#</a> Min2Max (x) 函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ posit_x ] = Min2Max ( x ) </span><br><span class=\"line\">    posit_x = max ( x ) - x ; </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"mid2maxxbest函数\"><a class=\"markdownIt-Anchor\" href=\"#mid2maxxbest函数\">#</a> Mid2Max (x,best) 函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ posit_x ] = Mid2Max ( x , best )  </span><br><span class=\"line\">    M = max ( abs ( x - best ) ) ; </span><br><span class=\"line\">    posit_x = 1 - abs ( x - best ) / M ; </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"inter2maxxab函数\"><a class=\"markdownIt-Anchor\" href=\"#inter2maxxab函数\">#</a> Inter2Max (x,a,b) 函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ posit_x ] = Inter2Max ( x , a , b ) ; </span><br><span class=\"line\">    M = max ([ a - min ( x ) , max ( x ) - b ] ) ; </span><br><span class=\"line\">    r_x = size ( x , 1 ) ; </span><br><span class=\"line\">    posit_x = zeros ( r_x , 1 ) ; </span><br><span class=\"line\">    for i = 1 : r_x</span><br><span class=\"line\">        if x(i) &lt; a </span><br><span class=\"line\">            posit_x(i) = 1 - ( a - x(i) ) / M ;</span><br><span class=\"line\">        else if x(i) &gt; b </span><br><span class=\"line\">            posit_x(i) = 1 - ( x(i) - b ) / M ; </span><br><span class=\"line\">        else posit_x(i) = 1 ; </span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"原始矩阵正向化\"><a class=\"markdownIt-Anchor\" href=\"#原始矩阵正向化\">#</a> 原始矩阵正向化</h3>\n<p>将 Excel 内的数据直接粘贴进 matlab 里，赋值给变量<br>\n将此变量另存为至与代码相同的目录下<br>\n调用直接用 load xxx.mat</p>\n<h3 id=\"sort函数\"><a class=\"markdownIt-Anchor\" href=\"#sort函数\">#</a> sort 函数</h3>\n<p>sort (A) 若 A 是向量不管是列还是行向量，默认都是对 A 进行升序排序，sort (A) 是默认的升序，而 sort (A,‘descend’) 是降序<br>\n若 A 是矩阵，默认对 A 的割裂进行升序排列<br>\n sort (A , dim) ;<br>\ndim = 1 时 等效于 sort (A) ;<br>\ndim = 2 时 表示对 A 的各列进行升序排列<br>\n若欲爆裂排列前的索引，则可用 [sA,index] = sort ( A , ‘decend’ ) ;<br>\nA = [ 2 , 1 , 3 , 8 ]<br>\nsA = [ 8 , 3 , 2 , 1 ]<br>\nindex = [ 4 , 3 , 1 , 2 ]</p>\n<h3 id=\"定义函数\"><a class=\"markdownIt-Anchor\" href=\"#定义函数\">#</a> 定义函数</h3>\n<p>function [输出变量] = 函数名称（输入变量）<br>\n函数的中间部分都是函数体<br>\n函数的最后要用 end 结尾<br>\n输出变量和输入变量可以有多个，用逗号隔开<br>\n例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ a , b , c ] = test ( d , e , f ) </span><br><span class=\"line\">a = d + e ;</span><br><span class=\"line\">b = e + f ; </span><br><span class=\"line\">c = f + d ; </span><br><span class=\"line\">end </span><br></pre></td></tr></table></figure>\n<h3 id=\"zeros-ones函数\"><a class=\"markdownIt-Anchor\" href=\"#zeros-ones函数\">#</a> zeros, ones 函数</h3>\n<p>zeros ( 3 ) ;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans = </span><br><span class=\"line\">0 0 0 </span><br><span class=\"line\">0 0 0 </span><br><span class=\"line\">0 0 0 </span><br></pre></td></tr></table></figure>\n<p>zeros ( 3 , 1 ) ;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans = </span><br><span class=\"line\">0 </span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p>ones 同理</p>\n",
            "tags": [
                "数学建模",
                "TOPSIS",
                "Matlab"
            ]
        },
        {
            "id": "http://amentiraz.github.io/2021/09/22/TOPSIS%E6%B3%95/",
            "url": "http://amentiraz.github.io/2021/09/22/TOPSIS%E6%B3%95/",
            "title": "TOPSIS法",
            "date_published": "2021-09-22T06:32:59.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-qujocUSI\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"537854742\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>TOPSIS 法 (Technique for Order Preference by Similarity to Ideal Solution)<br>\n 可翻译为逼近理想解排序法，也称优劣解距离法<br>\n TOPSIS 法是一种常用的综合评价方法，其能充分利用原始数据的信息，其结果能精确的反映各评价方案之间的差距</p>\n<span id=\"more\"></span>\n<h3 id=\"层次分析法的局限性\"><a class=\"markdownIt-Anchor\" href=\"#层次分析法的局限性\">#</a> 层次分析法的局限性</h3>\n<p>1） 决策层不能太多，太多 n 会很大，潘多矩阵和一致矩阵差距大<br>\n 2）对于已知的指标数据，我们如何利用数据使之更加准确</p>\n<h3 id=\"一个例子\"><a class=\"markdownIt-Anchor\" href=\"#一个例子\">#</a> 一个例子</h3>\n<p>对于如下表格</p>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th>成绩</th>\n<th>排名</th>\n<th>修正后的排名</th>\n<th>评分</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>小明</td>\n<td>89</td>\n<td>2</td>\n<td>3</td>\n<td>3/10=0.3</td>\n</tr>\n<tr>\n<td>小王</td>\n<td>60</td>\n<td>4</td>\n<td>1</td>\n<td>1/10=0.1</td>\n</tr>\n<tr>\n<td>小张</td>\n<td>74</td>\n<td>3</td>\n<td>2</td>\n<td>2/10=0.2</td>\n</tr>\n<tr>\n<td>我</td>\n<td>99</td>\n<td>1</td>\n<td>4</td>\n<td>4/10=0.4</td>\n</tr>\n</tbody>\n</table>\n<p>对于这种评价系统我们可以发现，只要保证排名不变，那么评分就不会改变</p>\n<h4 id=\"优化的想法\"><a class=\"markdownIt-Anchor\" href=\"#优化的想法\">#</a> 优化的想法</h4>\n<p>我们可以取最高的成绩 max = 99<br>\n 最低的成绩 min = 60<br>\n 构造计算评分的公式: (x - min) / ( max - min )<br>\n 然后对于每一个数据进行归一化处理即可<br>\n但同时最高分与最低分的评价是一定的，1&amp;0</p>\n<h4 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\">#</a> 说明</h4>\n<p>为什么不直接将各自的分数除以 100 再进行归一化处理，这样对于数据的关联性还更强<br>\n原因有三点</p>\n<ol>\n<li>比较对象一般远大于两个</li>\n<li>比较的指标往往不是一个方面的</li>\n<li>有很多指标不存在理论上的最大值和最小值，例如衡量经济增长水平的指标：GDP 增速<br>\n故我们最好使用上述优化的想法</li>\n</ol>\n<h4 id=\"拓展问题增加指标个数\"><a class=\"markdownIt-Anchor\" href=\"#拓展问题增加指标个数\">#</a> 拓展问题：增加指标个数</h4>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th>成绩</th>\n<th>与他人争吵的次数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>小明</td>\n<td>89</td>\n<td>2</td>\n</tr>\n<tr>\n<td>小王</td>\n<td>60</td>\n<td>0</td>\n</tr>\n<tr>\n<td>小张</td>\n<td>74</td>\n<td>1</td>\n</tr>\n<tr>\n<td>清风</td>\n<td>99</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>成绩是越大越好，这样的指标称为极大型指标（效益型指标）<br>\n与他人争吵的次数越少越好，这样的指标称为极小型指标（成本型指标）</p>\n<p>如果我们直接将这些数据加以利用显然是不合适的，因为指标类型不一样<br>\n所以我们应当统一指标类型<br>\n一般我们将所有的指标转化为极大型称为指标正向化（最常用）</p>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th>成绩</th>\n<th>与他人争吵的次数</th>\n<th>正向化后的争吵次数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>小明</td>\n<td>89</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>小王</td>\n<td>60</td>\n<td>0</td>\n<td>3</td>\n</tr>\n<tr>\n<td>小张</td>\n<td>74</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>清风</td>\n<td>99</td>\n<td>3</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>极小型指标转换为极大型指标的公式：max - x</p>\n<h4 id=\"标准化处理\"><a class=\"markdownIt-Anchor\" href=\"#标准化处理\">#</a> 标准化处理</h4>\n<p>显然成绩的大小与争吵次数的大小不是一个量级上的比较<br>\n为了消去不同指标量纲的影响，需要对已经正向化的矩阵进行标准化处理<br>\n图像链接：<br>\n我们得到了标准化处理后的指标，那么我们怎么去联系这些值呢</p>\n<h4 id=\"如何计算得分\"><a class=\"markdownIt-Anchor\" href=\"#如何计算得分\">#</a> 如何计算得分</h4>\n<p>我们对于最开始的式子：(x - min) / ( max - min )<br>\n 我们可以将其变形 = (x - min) / [ ( max - x ) + ( x - min ) ]<br>\n 可以看作是：x 与最小值的距离 /  (x 与最大值的距离 + x 与最小值的距离)<br>\n 类比可以得出：<br>\n图像链接：</p>\n<p>上面的一大串公式可以这样理解，我们对于只有一个指标时，我们将这一列的数据找出它的最大值和最小值，对于多个指标，同理，我们先将每一列的最大值和最小值找出来。<br>\n对于每一个评价对象，我们要找出它与最小值的距离可以看成一个平面直角坐标系，它的值所对应的点距离原点（最小值）的距离长度，也就是他的我们所要找的值<br>\n对于最大值的寻找也同理</p>\n<p>计算出未归一化的得分后我们将其进行归一化处理，就可得到他们的排名了</p>\n<p>这下子再回到 TOPSIS 算法，我们就不难理解它为什么是优劣解距离法了吧</p>\n<h3 id=\"梳理\"><a class=\"markdownIt-Anchor\" href=\"#梳理\">#</a> 梳理</h3>\n<h4 id=\"第一步将原始矩阵正向化\"><a class=\"markdownIt-Anchor\" href=\"#第一步将原始矩阵正向化\">#</a> 第一步将原始矩阵正向化</h4>\n<p>最常见的四种指标</p>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>名称</th>\n<th>指标特点</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>极大型（效益型）</td>\n<td>指标越大越好</td>\n<td>成绩、GDP 增速、企业利润</td>\n</tr>\n<tr>\n<td>极小型（成本型）</td>\n<td>指标越小越好</td>\n<td>费用、坏品率、污染程度</td>\n</tr>\n<tr>\n<td>中间型指标</td>\n<td>越接近某个值越好</td>\n<td>水质量评估 ph 值</td>\n</tr>\n<tr>\n<td>区间型指标</td>\n<td>落在某个区间最好</td>\n<td>体温、水中植物性营养物量</td>\n</tr>\n</tbody>\n</table>\n<p>正向化就是将所有指标类型转化为极大型指标</p>\n<p>我们介绍了极小型转化为极大型，那么另外两种指标该如何转换呢</p>\n<h5 id=\"中间型指标\"><a class=\"markdownIt-Anchor\" href=\"#中间型指标\">#</a> 中间型指标</h5>\n<p>{xi} 是一组中间型指标序列，且最佳的数值为 xbest，那么正向化的公式如下<br>\n M = max {| xi - xbest |} , xi’ = 1 - | xi - xbest | / M<br>\n 我们可以画图去理解这个公式，也是利用距离去计算，思想大致与极小型相同</p>\n<h5 id=\"区间型指标\"><a class=\"markdownIt-Anchor\" href=\"#区间型指标\">#</a> 区间型指标</h5>\n<p>我们设最佳区间为 [a,b]<br>\nM = max { a - min { xi } , max { xi } - b }<br>\nxi = 1 - ( a - x ) / M , x &lt; a<br>\n1                 , a &lt;= x &lt;= b<br>\n1 - ( x - b ) / M , x &gt; b<br>\n 思路与中间型指标也是差不多的，画图也可以理解</p>\n<h4 id=\"第二步正向化矩阵标准化\"><a class=\"markdownIt-Anchor\" href=\"#第二步正向化矩阵标准化\">#</a> 第二步：正向化矩阵标准化</h4>\n<h4 id=\"第三步归一化处理并排名\"><a class=\"markdownIt-Anchor\" href=\"#第三步归一化处理并排名\">#</a> 第三步：归一化处理并排名</h4>\n<h3 id=\"带权重的topsis\"><a class=\"markdownIt-Anchor\" href=\"#带权重的topsis\">#</a> 带权重的 TOPSIS</h3>\n<p>对于之前我们所用到的 TOPSIS 我们默认了指标之间的权重为 1 ，然而实际情况可能更为复杂<br>\n有 n 个要评价的对象，m 个评价指标的标准化矩阵<br>\n可以利用层次分析法给这 m 个评价指标确定权重，每个指标的权重加起来显然是为 1 的。<br>\n我们在计算评价对象与最大值之间的距离是可以直接针对每个 j（即每个指标）乘以响应的权重 wj 再进行开方<br>\n可能有人就要问了，那你这样加起来的距离显然是要小于之前的距离呀，会对得出正确的结论有影响吗<br>\n其实是没有影响的<br>\n我们可以理解为对于我们建立的直角坐标系对于某个轴进行了压缩，压缩后虽然大小改变了，但是并不影响我们得出正确的结论</p>\n<p>关于 TOPSIS 的代码见下一篇博客</p>\n",
            "tags": [
                "数学建模",
                "TOPSIS"
            ]
        },
        {
            "id": "http://amentiraz.github.io/2021/09/18/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/",
            "url": "http://amentiraz.github.io/2021/09/18/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/",
            "title": "层次分析法",
            "date_published": "2021-09-18T07:40:58.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-KzXaMBCq\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"1447594669\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<blockquote>\n<p>态度可以转变，生活却不可逆转。- 学层次分析法有感</p>\n</blockquote>\n<p>此文章用于记录我学习数学建模的十大模型中层次分析法的学习笔记与自己的理解，本文大多数是由清风老师的数学建模的指导归纳总结得到的，以备今后的数学建模。如果遇到了类似的题目可以尽快的找到相应的模型进行解决。<br>\n如果本文能帮助到其他阅读到此文章的同志，我也是不胜荣幸。<br>\n如果文章有所纰漏，也欢迎大家指出。</p>\n<span id=\"more\"></span>\n<h3 id=\"用途解决评价性问题\"><a class=\"markdownIt-Anchor\" href=\"#用途解决评价性问题\">#</a> 用途：解决评价性问题</h3>\n<p>层次分析法主要用于解决评价性问题，比如问你，选择哪种方案最好，哪个人或事物更为优秀。<br>\n需要注意的是，这种问题不包括已经给出具体数据的问题，更多的是比较模糊、较为主观的问题。你需要根据自己的生活经历，网络上搜集的评价资料和结合背景材料去得到相关的评价指标。<br>\n值得注意的是，我们可以在例如知网等比较权威的网站上去查找相关的论文资料并加以引用，可以让你的文章显得更为专业且结合其他人的观点可以让你的文章更为全面。</p>\n<h3 id=\"评判标准\"><a class=\"markdownIt-Anchor\" href=\"#评判标准\">#</a> 评判标准</h3>\n<p>那么评价类问题怎么去评判呢，我们使用打分来解决，根据权重表格计算得分</p>\n<table>\n<thead>\n<tr>\n<th>指标与方案</th>\n<th>指标权重</th>\n<th>方案 1</th>\n<th>方案 2</th>\n<th>…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>指标 1</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n</tr>\n<tr>\n<td>指标 2</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody>\n</table>\n<p>我们不妨定义 $a_{i j}&amp; 表示为第 i 行第 j 列的元素<br>\n显然针对每个因素所占的权重必定和为 1，指标权重的和为 1<br>\n 即 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>−</mo><mi>n</mi><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{1-n 1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 之和为 1<br>\n 对于每个指标 k, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mrow><mi>k</mi><mn>2</mn><mo>−</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{k 2-n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mtight\">2</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 的和同样为 1.<br>\n 而我们评判每个方案时，是不是就可以通过计算指标权重 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>×</mo></mrow><annotation encoding=\"application/x-tex\">\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">×</span></span></span></span> 方案对应指标的值。通过比较每个方案所对应的结果，我们就可以得知最佳的方案是什么了。</p>\n<h3 id=\"重要程度表\"><a class=\"markdownIt-Anchor\" href=\"#重要程度表\">#</a> 重要程度表</h3>\n<table>\n<thead>\n<tr>\n<th>标度</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>A 对于 B 同样重要</td>\n</tr>\n<tr>\n<td>3</td>\n<td>A 对于 B 稍微重要</td>\n</tr>\n<tr>\n<td>5</td>\n<td>A 对于 B 明显重要</td>\n</tr>\n<tr>\n<td>7</td>\n<td>A 对于 B 强烈重要</td>\n</tr>\n<tr>\n<td>9</td>\n<td>A 对于 B 极端重要</td>\n</tr>\n<tr>\n<td>2,4,6,8</td>\n<td>两个相邻判断的中值</td>\n</tr>\n</tbody>\n</table>\n<p>其中，1/3 表示 B 对于 A 稍微重要，以此类推</p>\n<h3 id=\"制作判断指标权重的表格\"><a class=\"markdownIt-Anchor\" href=\"#制作判断指标权重的表格\">#</a> 制作判断指标权重的表格</h3>\n<p>通过以上的重要程度表，我们可以根据专家（自己）的判断，制定一份这样的表格</p>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>景色</th>\n<th>花费</th>\n<th>居住</th>\n<th>饮食</th>\n<th>交通</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>景色</td>\n<td>1</td>\n<td>1/2</td>\n<td>4</td>\n<td>3</td>\n<td>3</td>\n</tr>\n<tr>\n<td>花费</td>\n<td>2</td>\n<td>1</td>\n<td>7</td>\n<td>5</td>\n<td>5</td>\n</tr>\n<tr>\n<td>居住</td>\n<td>1/4</td>\n<td>1/7</td>\n<td>1</td>\n<td>1/2</td>\n<td>1/3</td>\n</tr>\n<tr>\n<td>饮食</td>\n<td>1/3</td>\n<td>1/5</td>\n<td>2</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>交通</td>\n<td>1/3</td>\n<td>1/5</td>\n<td>3</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 表示与 j 指标相比，i 的重要程度<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> &gt;0 且 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>  * <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{j i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord mathnormal mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> = 1 称之为正互反矩阵。<br>\n此矩阵为判断矩阵</p>\n<h3 id=\"一致矩阵\"><a class=\"markdownIt-Anchor\" href=\"#一致矩阵\">#</a> 一致矩阵</h3>\n<p>由于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> = i 的重要程度 /j 的重要程度<br>\n我们可以知道 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> * <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mrow><mi>j</mi><mi>k</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{j k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>  = <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">a_{i k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ，列出数学计算公式即可得到<br>\n而满足上述关系的矩阵我们称之为一致矩阵<br>\n一致矩阵有一个特点，各行或者各列之间成倍数关系，利用这个我们可以直接得出这个矩阵是不是一致矩阵</p>\n<h3 id=\"最大特征值\"><a class=\"markdownIt-Anchor\" href=\"#最大特征值\">#</a> 最大特征值</h3>\n<p>由于本人大一，太菜，没有学过线性代数，我只能复制清风老师上课给的一个性质。<br>\n这个最大特征值你可以不用了解它究竟是个啥，怎么去计算，matlab 上面有它的计算函数<br>\n我们目前只需要知道对于特征值 λ：n 阶正互反矩阵 A 为一致矩阵时当且仅当最大特征值 λmax=n 否则 λmax 必定大于 n</p>\n<h3 id=\"一致性检验\"><a class=\"markdownIt-Anchor\" href=\"#一致性检验\">#</a> 一致性检验</h3>\n<p>步骤：</p>\n<ol>\n<li>计算一致性指标 CI = （ λmax - n ) / (n - 1)</li>\n<li>查找对应的平均随机一致性指标 RI</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>阶数</th>\n<th>RI</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>3</td>\n<td>0.52</td>\n</tr>\n<tr>\n<td>4</td>\n<td>0.89</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1.12</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1.26</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1.36</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1.41</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1.46</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1.49</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1.52</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1.54</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1.56</td>\n</tr>\n<tr>\n<td>14</td>\n<td>1.58</td>\n</tr>\n<tr>\n<td>15</td>\n<td>1.59</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>计算一致性比例 CR=CI/RI<br>\n 如果 CR&lt;0.1 则一致性检验可以接受，否则需要修正<br>\n什么，你问我怎么去修正？你是专家，肯定你来修正啊。</li>\n</ol>\n<h3 id=\"计算一致矩阵的权重\"><a class=\"markdownIt-Anchor\" href=\"#计算一致矩阵的权重\">#</a> 计算一致矩阵的权重</h3>\n<p>直接对第一列进行归一化处理，因为第一列与其他列都是成比例的，直接对第一列进行归一化处理是等于其他列对<br>\n归一化处理：<br>\n比如说对于如下矩阵</p>\n<p>PD|A|B<br>\nA|1|2<br>\nB|1/2|1</p>\n<p>我们直接计算 A：1/（1+1/2） B：（1/2）/（1+1/2）即可</p>\n<h3 id=\"计算判断矩阵的权重\"><a class=\"markdownIt-Anchor\" href=\"#计算判断矩阵的权重\">#</a> 计算判断矩阵的权重</h3>\n<p>我们不妨先假设矩阵 A=<br>\na11 a12 … a1n<br>\na21 a22 … a2n<br>\n… … … …<br>\nan1 an2 … ann</p>\n<h4 id=\"算术平均法求权重\"><a class=\"markdownIt-Anchor\" href=\"#算术平均法求权重\">#</a> 算术平均法求权重</h4>\n<ol>\n<li>分别对每一列进行归一化处理</li>\n<li>把每一行的数据分别加起来</li>\n<li>把 2 得到的数据除以 n<br>\n 这种方法称之为算术平均法求权重<br>\n那么算术平均法求得得权重向量 wi</li>\n</ol>\n",
            "tags": [
                "数学建模",
                "层次分析法"
            ]
        }
    ]
}