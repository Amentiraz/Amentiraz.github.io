{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amentiraz • All posts by \"学习笔记\" category",
    "description": "",
    "home_page_url": "http://Amentiraz.github.io",
    "items": [
        {
            "id": "http://amentiraz.github.io/2022/01/12/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/",
            "url": "http://amentiraz.github.io/2022/01/12/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/",
            "title": "python学习笔记1",
            "date_published": "2022-01-12T11:55:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-FVVRxfLT\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"1458550\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>除开函数外的 python 基础知识总汇，用于复习及查看，写的会很简略</p>\n<span id=\"more\"></span>\n<h3 id=\"基础知识\"><a class=\"markdownIt-Anchor\" href=\"#基础知识\">#</a> 基础知识</h3>\n<p>普通的除法：1/2  0.5<br>\n 整除: 1//2 0<br>\n 取模：%<br>\n 乘方：2<strong>3 (-3</strong>2 等同于 -(3**2))</p>\n<p>十六进制：0xAF<br>\n 八进制：010</p>\n<p>变量无需声明即可使用</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">3</span> </span><br><span class=\"line\">x * <span class=\"number\">2</span> </span><br><span class=\"line\">output : <span class=\"number\">6</span> </span><br></pre></td></tr></table></figure>\n<p>变量名命名同 C 语言</p>\n<p>print 在 python2 是语句，在 python3 中是函数，所以应当加上（）</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">input</span> ( <span class=\"string\">&quot;The meaning of life: &quot;</span> )</span><br><span class=\"line\">The meaning of life <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = <span class=\"built_in\">input</span> ( <span class=\"string\">&quot;x: &quot;</span> ) </span><br><span class=\"line\">x: <span class=\"number\">34</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = <span class=\"built_in\">input</span> ( <span class=\"string\">&quot;y: &quot;</span> ) </span><br><span class=\"line\">y : <span class=\"number\">42</span> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> ( x * y ) </span><br><span class=\"line\"><span class=\"number\">1428</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">pow</span> ( <span class=\"number\">2</span> , <span class=\"number\">3</span> ) </span><br><span class=\"line\"><span class=\"number\">8</span> </span><br></pre></td></tr></table></figure>\n<p>round 函数会把浮点数四舍五入为最接近的整数值 （ py2 与 py3 对于 0.5 的取值有所不同）<br>\nabs 绝对值函数</p>\n<p>可以用变量来引用函数</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math </span><br><span class=\"line\">math.floor( <span class=\"number\">32.9</span> ) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> floor</span><br><span class=\"line\">floor</span><br><span class=\"line\"></span><br><span class=\"line\">foo = math.sqrt </span><br><span class=\"line\">foo ( <span class=\"number\">4</span> ) </span><br></pre></td></tr></table></figure>\n<p>math 中的 sqrt 不支持复数运算而 cmath 中支持</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> cmath</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>cmath.sqrt ( -<span class=\"number\">1</span> ) </span><br><span class=\"line\"><span class=\"number\">1j</span></span><br><span class=\"line\"><span class=\"comment\"># 没有使用from 。。。import 。。。是因为一旦使用了这个语句那么就无法使用普通的sqrt了</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>(<span class=\"number\">1</span>+<span class=\"number\">3j</span>) * (<span class=\"number\">9</span>+<span class=\"number\">4j</span>) </span><br><span class=\"line\">(-<span class=\"number\">3</span>+<span class=\"number\">31j</span>) </span><br></pre></td></tr></table></figure>\n<p>字符串是值，就像数字一样，单引号和双引号没有本质区别<br>\n \\ 与 C 语言中一样使用<br>\n字符串之间可以拼接</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;hello,&quot;</span> + <span class=\"string\">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>\n<p>转换成字符串有两种方式<br>\n str 将对象转换成用户看的，repr 转换成 python 表达式</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span> ( <span class=\"built_in\">repr</span> ( <span class=\"string\">&quot;hello world&quot;</span> ) )</span><br><span class=\"line\"><span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> ( <span class=\"built_in\">str</span> ( <span class=\"string\">&quot;hello world &quot;</span> ) )</span><br><span class=\"line\">hello world </span><br></pre></td></tr></table></figure>\n<p>长字符串：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span> ( <span class=\"string\">&quot;&quot;&quot; This is a very long string</span></span><br><span class=\"line\"><span class=\"string\">It continues here </span></span><br><span class=\"line\"><span class=\"string\">And it&#x27;s not over yet</span></span><br><span class=\"line\"><span class=\"string\">Still here &quot;&quot;&quot;</span> )</span><br><span class=\"line\"><span class=\"comment\"># 换行符可以被转义</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> ( <span class=\"string\">&quot;&quot;&quot; hello \\ </span></span><br><span class=\"line\"><span class=\"string\">world &quot;&quot;&quot;</span> ) </span><br></pre></td></tr></table></figure>\n<p>原始字符串</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path = <span class=\"string\">&#x27;c:\\\\program\\\\fnord&#x27;</span></span><br><span class=\"line\">path = <span class=\"string\">r&#x27;c:\\ll&quot;</span></span><br><span class=\"line\"><span class=\"string\"># r紧贴&#x27;</span>且字符串末尾不是\\</span><br></pre></td></tr></table></figure>\n<h3 id=\"序列\"><a class=\"markdownIt-Anchor\" href=\"#序列\">#</a> 序列</h3>\n<p>列表和元组的区别在于列表可以修改而元组不可以</p>\n<p>通用的序列操作：索引，分片，加，乘<br>\n索引同数组，数组最后一个元素的位置标号为 - 1 如：greeting [-1]<br>\n print 的返回值是一个序列，所以我们可以如此调用</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fourth = <span class=\"built_in\">input</span> ( <span class=\"string\">&quot;Year: &quot;</span> )[<span class=\"number\">3</span>] </span><br></pre></td></tr></table></figure>\n<p>列表可以相加与相乘，例如</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">endings = [<span class=\"string\">&#x27;st&#x27;</span>,<span class=\"string\">&#x27;nd&#x27;</span>,<span class=\"string\">&#x27;rd&#x27;</span>]+<span class=\"number\">17</span> * [<span class=\"string\">&#x27;th&#x27;</span>,] \\ </span><br><span class=\"line\">+    [<span class=\"string\">&#x27;st&#x27;</span>,<span class=\"string\">&#x27;nd&#x27;</span>,<span class=\"string\">&#x27;rd&#x27;</span>]+ <span class=\"number\">7</span> * [<span class=\"string\">&#x27;th&#x27;</span>,]  \\</span><br><span class=\"line\">+ [<span class=\"string\">&#x27;st]</span></span><br><span class=\"line\"><span class=\"string\">[1,2,3] + [4,5,6]</span></span><br><span class=\"line\"><span class=\"string\">= [1,2,3,4,5,6]</span></span><br><span class=\"line\"><span class=\"string\"># 初始化一个长度为10 的列表</span></span><br><span class=\"line\"><span class=\"string\">sequence = [None] * 10 </span></span><br></pre></td></tr></table></figure>\n<p>分片<br>\n numbers [-3:-1]<br>\nnumbers[-3:]<br>\nnumbers[0::2]<br>\nnumbers[-1:0:-2]</p>\n<p>成员资格：in 函数</p>\n<p>长度：len<br>\n 最大值：max<br>\n 最小值：min</p>\n<h4 id=\"列表\"><a class=\"markdownIt-Anchor\" href=\"#列表\">#</a> 列表</h4>\n<p>list 函数 对立： ‘’.join (somelist)<br>\n 删除元素 del names [2]<br>\n 分片赋值：可以使用与原序列不等长的序列将分片替换（可以用来删除某一段）</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numbers[<span class=\"number\">1</span>:<span class=\"number\">1</span>] = [<span class=\"number\">2</span>, <span class=\"number\">3</span> ,<span class=\"number\">4</span> ]</span><br><span class=\"line\">numbers[<span class=\"number\">1</span>:<span class=\"number\">5</span>] = [] </span><br></pre></td></tr></table></figure>\n<p>.append( )<br>\n.count ( )<br>\n.extend ( ) 追加一个序列<br>\n.index ( ) 找出第一个匹配项索引位置<br>\n.insert (i , value) 插入<br>\n.pop ( ) 移除最后一个值并返回值<br>\n.remove ( ) 移除第一个匹配项<br>\n.reserve ( ) 反向存放<br>\n.sort ( ) 会该表原来的列表修改，也就是说修改副本不会影响原本，反之不然<br>\n<strong> sort 里面可以有参数如 cmp，key=len，reserve=True</strong><br>\nsorted ( ) 返回已排序的列表副本</p>\n<h4 id=\"元组\"><a class=\"markdownIt-Anchor\" href=\"#元组\">#</a> 元组</h4>\n<p>如果你用逗号分隔了一些值，那么你就自动创建了元组<br>\n tuple ( ) 类比于 list</p>\n<h3 id=\"字符串\"><a class=\"markdownIt-Anchor\" href=\"#字符串\">#</a> 字符串</h3>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">format</span> = <span class=\"string\">&quot;hello , %s , %s enough for ya!&quot;</span> </span><br><span class=\"line\">values = ( <span class=\"string\">&#x27;world&#x27;</span> , <span class=\"string\">&#x27;Hot&#x27;</span> ) </span><br><span class=\"line\"><span class=\"built_in\">print</span> ( <span class=\"built_in\">format</span> % values ) </span><br></pre></td></tr></table></figure>\n<p>模板字符串：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> string <span class=\"keyword\">import</span> Template</span><br><span class=\"line\">s = Template ( <span class=\"string\">&#x27;$x , glorious $x &#x27;</span> ) </span><br><span class=\"line\">s.substitute ( x = <span class=\"string\">&#x27;slum&#x27;</span> ) </span><br><span class=\"line\"></span><br><span class=\"line\">s = Template ( <span class=\"string\">&quot;It&#x27;s $&#123;x&#125;tatic&quot;</span> ) </span><br><span class=\"line\">s.substitute ( x = <span class=\"string\">&#x27;slum&#x27;</span> ) </span><br><span class=\"line\"></span><br><span class=\"line\">s = Template ( <span class=\"string\">&#x27;A $thing must never $action&#x27;</span> ) </span><br><span class=\"line\">d = &#123; &#125; </span><br><span class=\"line\">d[<span class=\"string\">&#x27;thing&#x27;</span>] = <span class=\"string\">&#x27;gentleman&#x27;</span> </span><br><span class=\"line\">d[<span class=\"string\">&#x27;action&#x27;</span>] = <span class=\"string\">&#x27;show his socks&#x27;</span> </span><br><span class=\"line\">s.substitute ( d ) </span><br></pre></td></tr></table></figure>\n<p>转换符包括（注意顺序）</p>\n<ol>\n<li>%</li>\n<li>转换标志 ，- : 左对齐，+ : 正负号，&quot;&quot; 正数前保留空格，0：位数不够用零来凑</li>\n<li>最小值宽（若为 * 则从元组读入）例如’%. * s’ % (5 , ‘dada’)</li>\n<li>. 后跟精确度</li>\n</ol>\n<p>字符串方法：<br>\n.find (“target” ,start ,end ) 查找字串 (start end 可忽略)<br>\nsth.join ( )<br>\n.lower ( ) 转换成小写<br>\n.title ()  //.capwords () 标题<br>\n.replace (A , B) 查找并替换<br>\n.split ( ) join 的逆运算<br>\n.strip () 去除两侧空格，可自己添加例如.strip ( ’ * !’)<br>\n.translate ( ) &amp;&amp; .maketrans python3 有所区别，运用时自己网上查</p>\n<h3 id=\"字典\"><a class=\"markdownIt-Anchor\" href=\"#字典\">#</a> 字典</h3>\n<p>创建： phonebook = {‘A’ : 1 , ‘B’ : 2 …}<br>\n dict (序列)<br>\nlen ( )<br>\nd[k]<br>\nd[k] = v<br>\ndel d[k]<br>\n k in d 检查 d 中是否有含有键为 k 的项<br>\n字典可以嵌套，类比于多维数组</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template = <span class=\"string\">&quot;%(title)s , %(ooo)d &quot;</span> </span><br><span class=\"line\">data = &#123; <span class=\"string\">&#x27;title&#x27;</span> : <span class=\"string\">&#x27;fff&#x27;</span> , <span class=\"string\">&#x27;ooo&#x27;</span> : <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span> ( template % data )  </span><br></pre></td></tr></table></figure>\n<p>.clear ( ) 原本操作<br>\n.copy ( ) 替换值不变原本，修改值会变<br>\n.deepcopy (copy 函数库中) 复制其包含的所有值<br>\n.fromkeys ([] , ‘default’ ) or dict.fromkeys ( [ ] , ‘default’ ) 给给定的键建立新的字典<br>\n.get (‘value’) 访问不存在的项返回 None<br>\n.has_key (‘value’) 查询是否有此键，py3 中被__contains__(key) 替代<br>\n.items () 把所有项以列表形式返回，且每一项返回 (键，值) 的形式<br>\n.iteritems ( ) 返回迭代器<br>\n.keys ( ) 返回键 ， 同上<br>\n.itereys ( ) 同上<br>\n.values ( ) 同上<br>\n.itervalues ( ) 同上<br>\n.pop (‘键’) 删除对应的键值对<br>\n.popitem ( ) 随机弹出项<br>\n.setdefault (键，‘default’)<br>\n.update (x) 有则不变，无则加之</p>\n<h3 id=\"条件-循环和其它语句\"><a class=\"markdownIt-Anchor\" href=\"#条件-循环和其它语句\">#</a> 条件、循环和其它语句</h3>\n<p>print: , 即空格，print 即换行（除非在最后加，)<br>\nimport somemodule<br>\nfrom sm import sf<br>\nfrom sm import sf as (可避免重名)</p>\n<p>解包时可在最后用 * rest 把剩下的值都存入 rest</p>\n<p>+=</p>\n<ul>\n<li>=</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ... : </span><br><span class=\"line\">    代码块</span><br><span class=\"line\">    代码块</span><br><span class=\"line\"><span class=\"keyword\">elif</span> ... : </span><br><span class=\"line\">    代码块</span><br><span class=\"line\">    代码块</span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">    代码块</span><br><span class=\"line\">    代码块</span><br></pre></td></tr></table></figure>\n<p>x is y x 和 y 是同一对象<br>\n x is not y …<br>\nx in y<br>\nx not in y<br>\n 可以使用 x&lt;y&lt;z</p>\n<p>断言：assert 判断条件<br>\n如果不满足直接程序崩溃</p>\n<p>while 判断 :<br>\n 代码块<br>\n代码块</p>\n<p>for i in sequence :<br>\n…<br>\n…</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>range ( 3 )<br>\n[ 0 , 1 , 2 , 3 ]</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>xrange ( 3 )<br>\n 同 range 只不过是一个一个给出的，更为高效</p>\n</blockquote>\n</blockquote>\n</blockquote>\n",
            "tags": [
                "学习笔记",
                "python"
            ]
        },
        {
            "id": "http://amentiraz.github.io/2021/12/28/%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "http://amentiraz.github.io/2021/12/28/%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "文件学习笔记",
            "date_published": "2021-12-28T01:46:28.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-MtvMxXMJ\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"1486106274\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<h3 id=\"文件是什么\"><a class=\"markdownIt-Anchor\" href=\"#文件是什么\">#</a> 文件是什么</h3>\n<p>文件是指一组相关数据的有序集合，这个数据集有一个名称叫做文件名。文件可以是自己编制的，也可以是系统已有的。事实上我们已经多次使用了文件，例如源程序文件，目标文件、可执行文件、库文件等。<br>\n为了将结果保存起来，就需要使用文件。将数据以文件的形式存放在光盘、磁盘等外存储器上，可以达到重复利用、永久保存数据的目的。文件可分为普通文件和设备文件两种。通常吧显示器定义为标准输出文件，一般情况下在屏幕上显示有关信息就是向标准输出文件输出。如前面经常使用的 printf、putchar 函数就是这类输出。键盘通常被指定标准的输入文件，从键盘上输入意味着以标准输入文件输入数据。scanf、getchar 函数就属于这类输入。</p>\n<h3 id=\"文件类型\"><a class=\"markdownIt-Anchor\" href=\"#文件类型\">#</a> 文件类型</h3>\n<p>文件可分为 ASCII 码文件和二进制文件两种。ASCII 文件也成为文本文件，这种文件在磁盘中存放时每个字符对应一个字节，用于存放对应的 ASCII 码。<br>\n例如数 6843 的存储形式为：<br>\nASCII 码：00110110 00111000 00110100 00110011<br>\n 十进制码：  6         8        4        3<br>\n 共占用四个字节。<br>\nASCII 码文件可在屏幕上按字符显示，例如源程序文件就是 ASCII 文件，用 DOS 命令 TYPE 可显示文件的内容。<br>\n二进制文件是按二进制编码的方式来存放文件的。例如，数 6843 的存储形式为：00011010 10111011<br>\n 只占两个字节。二进制文件也可以在屏幕中显示，但内容无法读懂。<br>\n输入输出字符流的开始和结束只由程序控制而不受物理符号（如回车符）的控制。因此也把这种文件称作流式文件。</p>\n<h3 id=\"文件指针\"><a class=\"markdownIt-Anchor\" href=\"#文件指针\">#</a> 文件指针</h3>\n<p>在 C 语言中用一个指针变量指向一个文件，这个指针被称为文件指针，通过文件指针可以对它所指的文件进行各种操作。存放文件的有关信息被保存在一个结构体变量中，它是由系统定义的，取名为 FILE。在编写源程序时不必关心 FILE 结构的细节。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE * 指针变量标识符</span><br></pre></td></tr></table></figure>\n<p>其中 FILE 必须为大写，该结构中含有文件名、文件状态和文件当前位置等信息。<br>\n注意：在操作系统中，文件被作为重要的系统资源来看待。因此，当程序需要访问文件时，程序员必须显式地打开某个文件，并在使用后关闭它。程序中所有对文件的操作都通过文件指针来实现。</p>\n<h3 id=\"文件打开操作\"><a class=\"markdownIt-Anchor\" href=\"#文件打开操作\">#</a> 文件打开操作</h3>\n<p>C 语言没有输入输出语句，对文件的读写都是用看库函数来实现的。<br>\n对文件进行操作时应遵循一下步骤：</p>\n<ol>\n<li>打开文件。打开文件是指请求系统为指定文件分配内存缓冲区，建立文件的各种有关信息，文件使用前必须先打开。</li>\n<li>读写文件。包括文件的读、写、定位等操作。</li>\n<li>关闭文件。确保数据完整写入文件并释放内存缓冲区。</li>\n</ol>\n<p>打开文件，实际上是建立文件的各种有关信息，并使文件指针指向该文件。关闭文件则是断开指针与文件之间的联系，也就是禁止再对该文件操作。<br>\nfopen 函数用来打开一个文件，其调用的一般形式为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件指针名 = <span class=\"built_in\">fopen</span> ( 文件名 , 使用文件方式 ) ; </span><br></pre></td></tr></table></figure>\n<p>文件指针名必须是被说明为 FILE 类型的指针变量；文件名使被打开文件的文件名，可以是字符串常量或字符串数组；使用文件方式是指文件类型和操作要求。<br>\n例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE * fp ; </span><br><span class=\"line\">fp = ( <span class=\"string\">&quot;file a&quot;</span> , <span class=\"string\">&quot;r&quot;</span> ) ; </span><br></pre></td></tr></table></figure>\n<p>其意义使在当前目录下打开文件 file a，只允许进行读入操作，并使 fp 指向该文件。<br>\n又如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE * fp ; </span><br><span class=\"line\">fp = ( <span class=\"string\">&quot;c:\\\\test&quot;</span> , <span class=\"string\">&quot;rb&quot;</span> ) ; </span><br></pre></td></tr></table></figure>\n<p>其意义是打开 C 驱动磁盘的根目录下的文件 test，这是一个二进制文件，只允许按二进制的方式进行读操作。两个反斜杠 &quot;\\&quot; 第一个表示转义字符，第二个表示根目录。<br>\n或者使用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">FILE * <span class=\"title\">fopen</span> <span class=\"params\">( <span class=\"type\">const</span> <span class=\"type\">char</span> * filename , <span class=\"type\">const</span> <span class=\"type\">char</span> * mode )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>返回失败时返回空指针 NULL<br>\n 使用文件的方式共有 12 种，下表给出其符号以及意义。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">文件使用方式</th>\n<th style=\"text-align:center\">意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">r</td>\n<td style=\"text-align:center\">打开文件，只读</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w</td>\n<td style=\"text-align:center\">打开或建立文件只写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">追加打开一个文本文件，并在文件末尾写数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">rb</td>\n<td style=\"text-align:center\">二进制文件，同上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wb</td>\n<td style=\"text-align:center\">二进制文件，同上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ab</td>\n<td style=\"text-align:center\">二进制文件，同上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">r+</td>\n<td style=\"text-align:center\">读 + 写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w+</td>\n<td style=\"text-align:center\">读 + 写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a+</td>\n<td style=\"text-align:center\">读 + 写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">rb+&amp;wb+&amp;ab+</td>\n<td style=\"text-align:center\">类推</td>\n</tr>\n</tbody>\n</table>\n<p>总结如下：r (ead) , w (rite) , a (ppend) , t (ext) , b (inary) 。+：读和写<br>\n查看是否成功读入</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( ( fp = <span class=\"built_in\">fopen</span> ( <span class=\"string\">&quot;text&quot;</span> , <span class=\"string\">&quot;rb&quot;</span> ) ) == <span class=\"literal\">NULL</span>  ) &#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;error&quot;</span> ; </span><br><span class=\"line\">    <span class=\"built_in\">getch</span> ( ) ; <span class=\"built_in\">exit</span> ( <span class=\"number\">1</span> ) ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件关闭操作\"><a class=\"markdownIt-Anchor\" href=\"#文件关闭操作\">#</a> 文件关闭操作</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE * fp ; </span><br><span class=\"line\">fp = <span class=\"built_in\">fopen</span> ( <span class=\"string\">&quot;a.out&quot;</span> , <span class=\"string\">&quot;r&quot;</span> ) ; </span><br><span class=\"line\"><span class=\"built_in\">fclose</span> ( fp ) ; </span><br></pre></td></tr></table></figure>\n<p>关闭成功返回值为 0，否则为非零值<br>\n如果打开了多个文件且需要统一关闭：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fcloseall</span> <span class=\"params\">( )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>此函数关闭除了标准流意外的所有打开流，刷新所有的流缓冲区，并关闭返回的参数，否则返回 EOF。<br>\n标准流：stdin，stdout，stderr</p>\n<h3 id=\"文件结束检测\"><a class=\"markdownIt-Anchor\" href=\"#文件结束检测\">#</a> 文件结束检测</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">feof</span> <span class=\"params\">( FLIE * fp )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>文件未结束返回 0，已结束返回真。</p>\n<h3 id=\"文件错误检测函数\"><a class=\"markdownIt-Anchor\" href=\"#文件错误检测函数\">#</a> 文件错误检测函数</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ferror</span> <span class=\"params\">( FILE * fp )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>发生错误返回非零，否则返回 0</p>\n<h3 id=\"定位文件位置指针函数\"><a class=\"markdownIt-Anchor\" href=\"#定位文件位置指针函数\">#</a> 定位文件位置指针函数</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">fseek</span> ( FILE * fp , <span class=\"type\">long</span> offset , <span class=\"type\">int</span> startpos ) ; </span><br></pre></td></tr></table></figure>\n<p>offset 表示目标位置相对起始点的偏移量，要求偏移量为 long 型数据以便在文件长度大于 64KB 时不会出错，当用常量表示位移量时，要求加后缀 L.<br>\nstartpos 表示从何处计算偏移量：SEEK_SET:0 , SEEK_CUR:1 , SEEK_END:2 ;<br>\nfseek 函数一般用于二进制文件，在文本文件中由于要进行转换，故往往会出现错误。</p>\n<h3 id=\"重置文件位置指针函数\"><a class=\"markdownIt-Anchor\" href=\"#重置文件位置指针函数\">#</a> 重置文件位置指针函数</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">rewind</span> ( FILE * fp ) ; </span><br></pre></td></tr></table></figure>\n<p>移动到文件开始的位置。<br>\n无返回值</p>\n<h3 id=\"移动指针到当前位置函数\"><a class=\"markdownIt-Anchor\" href=\"#移动指针到当前位置函数\">#</a> 移动指针到当前位置函数</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"title\">ftell</span> <span class=\"params\">( FILE * p )</span> </span>;</span><br></pre></td></tr></table></figure>\n<p>若函数调用成功则函数的返回值时当前读写位置偏离文件头部的字节数，否则返回 - 1 ；<br>\n文件的长度</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ftell</span> ( fp , <span class=\"number\">0L</span> , SEEK_END ) ;</span><br><span class=\"line\">len = <span class=\"built_in\">ftell</span> ( fp ) ; </span><br></pre></td></tr></table></figure>\n<h3 id=\"面向字符的文件读写操作\"><a class=\"markdownIt-Anchor\" href=\"#面向字符的文件读写操作\">#</a> 面向字符的文件读写操作</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">fputc</span> ( <span class=\"type\">int</span> c , FILE * stream ) ; </span><br></pre></td></tr></table></figure>\n<p>c 是带写入的字符，可以是字符常量或者变量。<br>\n每写入一个字符，文件内部位置指针将向后移动一个字节。返回值为字符或者 EOF。<br>\n如果用写或者读写方式打开一个已存在的文件时将清除原有的文件内容，写入字符从文件首开始，如需保留原有文件内容，必须以追加的方式打开文件。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch = <span class=\"built_in\">fgetc</span> ( FILE * stream ) ; </span><br></pre></td></tr></table></figure>\n<p>读取的文件必须是以读写或读的方式打开的。</p>\n<h3 id=\"面向字符串的文件读写操作\"><a class=\"markdownIt-Anchor\" href=\"#面向字符串的文件读写操作\">#</a> 面向字符串的文件读写操作</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">char</span> * <span class=\"title\">fgets</span> <span class=\"params\">( <span class=\"type\">char</span> * string , <span class=\"type\">int</span> n , FILE * stream )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>函数的功能是从 stream 指向的文件中逐一读取 n-1 个字符，并将读取的字符保存到 string 指向的连续存储空间。<br>\n在读取 n-1 个字符之前如果遇到了换行符或 EOF，则读取结束。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fputs</span> <span class=\"params\">( <span class=\"type\">const</span> <span class=\"type\">char</span> * string , FILE * stream )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>执行成功返回非负整数，否则返回 EOF。不会把 \\0 写入文件。</p>\n<h3 id=\"面向格式化输入输出的文件读写操作\"><a class=\"markdownIt-Anchor\" href=\"#面向格式化输入输出的文件读写操作\">#</a> 面向格式化输入输出的文件读写操作</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fscanf</span> <span class=\"params\">( FILE * stream , <span class=\"type\">const</span> <span class=\"type\">char</span> * format[,argument]...)</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>返回值为读取正确的数据个数， EOF 为读取错误或文件结束。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fprintf</span> <span class=\"params\">( FILE * stream , <span class=\"type\">const</span> <span class=\"type\">char</span> * format[,argument]... )</span> </span>; </span><br></pre></td></tr></table></figure>\n<p>返回值为正确写入返回数据的个数，负值为读写错误。</p>\n<h3 id=\"面向信息块的文件读写操作\"><a class=\"markdownIt-Anchor\" href=\"#面向信息块的文件读写操作\">#</a> 面向信息块的文件读写操作</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">fread</span> ( <span class=\"type\">void</span> * buffer , <span class=\"type\">int</span> size , <span class=\"type\">int</span> count , FILE * fp ) ; </span><br><span class=\"line\"><span class=\"built_in\">fwrite</span> ( <span class=\"type\">void</span> * buffer , <span class=\"type\">int</span> size , <span class=\"type\">int</span> count , FILE * fp ) ; </span><br></pre></td></tr></table></figure>\n<p>例如：fread (fa , 4 , 5 , fp) ; 的意义是从 fp 所指的文件中，每次读 4 个字节，送入实数数组 fa 中，连续读 5 次。</p>\n",
            "tags": [
                "学习笔记",
                "C语言"
            ]
        },
        {
            "id": "http://amentiraz.github.io/2021/11/22/%E7%BB%93%E6%9E%84/",
            "url": "http://amentiraz.github.io/2021/11/22/%E7%BB%93%E6%9E%84/",
            "title": "结构",
            "date_published": "2021-11-22T13:02:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-TxVuxMvi\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"29393038\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<h3 id=\"结构的基本知识\"><a class=\"markdownIt-Anchor\" href=\"#结构的基本知识\">#</a> 结构的基本知识</h3>\n<p>结构是一个或者多个变量的几何，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。<br>\n结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值，在 ANSI 标准中，自动结构和数组现在也可以进行初始化。</p>\n<span id=\"more\"></span>\n<p>我们首先来看一个关于平面坐标的结构体</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct point &#123;</span><br><span class=\"line\">    int x , y ; </span><br><span class=\"line\">&#125; ; </span><br></pre></td></tr></table></figure>\n<p>关键字 struct 引入结构声明。结构声明由包含在花括号内的一系列声明组成。关键字 struct 后面的名字是可选的，称为<em>结构标记</em>（这里是 point）。<br>\n结构标记用于为结构命名，在定义之后，结构标记就代表花括号内的声明，可以用它作为该声明的简写形式。<br>\n结构中定义的变量称为<em>成员</em>。结构成员，结构标记和普通变量（即非成员）可以采用相同的名字，它们之间不会冲突，因为通过上下文分析总可以对它们进行区分。不同结构中的成员也可以使用相同的名字。<br>\nstruct 声明定义了一种数据类型，在标志结构成员表结束的右花括号之后可以跟一个变量表，这与其它基本类型的变量声明是相同的。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct &#123; ... &#125; x , y , z ; </span><br></pre></td></tr></table></figure>\n<p>从语法角度来说，这种声明与声明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int x , y , z ; </span><br></pre></td></tr></table></figure>\n<p>具有类似的意义。如果结构声明的后面不带变量表，则不需要为它分配存储空间，它仅仅描述了一个结构的模版。但是，如果结构声明中带有标记，那么在以后定义结构实例时便可以使用该标记定义。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct point maxpt = &#123; 320 , 200 &#125; ; </span><br></pre></td></tr></table></figure>\n<p>定义了一个 struct point 类型的变量 pt。结构的初始化可以在定义的后面使用初值表进行，除指标中同每个成员对应的处置必须是常量表达式。<br>\n自动结构也可以通过赋值初始化，还可以通过调用返回相应类型结构中的成员。<br>\n在表达式中可以通过下列形式引用某哥特定结构中的成员：<br>\n结构名。成员<br>\n结构可以嵌套，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct rect &#123; </span><br><span class=\"line\">    struct point pt1 ; </span><br><span class=\"line\">    struct point pt2 ; </span><br><span class=\"line\">&#125; ;</span><br><span class=\"line\">struct rec screen ; </span><br></pre></td></tr></table></figure>\n<p>我们可以使用语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">screen.pt1.x ; </span><br></pre></td></tr></table></figure>\n<h3 id=\"结构与函数\"><a class=\"markdownIt-Anchor\" href=\"#结构与函数\">#</a> 结构与函数</h3>\n<p>结构的合法操作只有：</p>\n<ol>\n<li>作为一个整体赋值</li>\n<li>通过 &amp; 运算符取地址，访问其成员。</li>\n</ol>\n<p>其中复制和复制包括向函数传递参数以及从函数返回值。结构之间不可以进行比较。<br>\n可以用一个常量成员值列表初始化结构，自动结构也可以通过赋值进行初始化。<br>\n我们可以通过至少 3 种方法传递结构：</p>\n<ol>\n<li>分别传递各个结构成员</li>\n<li>传递整个结构</li>\n<li>传递指向结构的指针</li>\n</ol>\n<p>例如以下函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct point makepoint ( int x , int y ) &#123;</span><br><span class=\"line\">    struct point temp ; </span><br><span class=\"line\">    temp.x = x ; temp.y = y ; </span><br><span class=\"line\">    return temp ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">struct rect screen ; </span><br><span class=\"line\">struct point middle ; </span><br><span class=\"line\">struct point makepoint ( int , int ) ; </span><br><span class=\"line\">screen.pt1 = makepoint ( 0 , 0 ) ; </span><br><span class=\"line\">screen.pt2 = makepoint ( XMAX , YMAX ) ; </span><br><span class=\"line\">middle = makepoint ( ( screen.pt1.x + screen.pt2.x ) &gt;&gt; 1 , ( screen.pt1.y + screen.pt2.y ) &gt;&gt; 1 ) ; </span><br><span class=\"line\"></span><br><span class=\"line\">struct point addpoint ( struct point p1 , struct point p2 ) &#123; </span><br><span class=\"line\">    p1.x += p2.x ; </span><br><span class=\"line\">    p1.y += p2.y ; </span><br><span class=\"line\">    return p1 ; </span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n<p>addpoint 函数的参数和返回值都是结构类型，结构类型的参数和其它参数是一样的都是通过值传递的。</p>\n<p>如果传递给函数的结构很大，使用指针方式的效率通常比赋值整个结构的效率更高，结构指针类似于普通变量指针。声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct point * pp ; </span><br></pre></td></tr></table></figure>\n<p>如果 pp 指向一个 point 结构，那么 * pp 即为该结构，而（ * pp ).x 和 (* pp).y 则是结构成员。其中 ( * pp ).x 的圆括号是必须的，因为结构成员运算符 &quot;.“的优先级比”*&quot; 的优先级高。表达式 * pp.x 的含义等价于 *(pp.x)，因为 x 不是指针，所以该表达式是非法的。<br>\n结构指针的使用频率非常高，为了使用方便，C 语言提供了另一种简写方式。嘉定 p 是一个指向结构的指针，可以用<br>\n p-&gt; 结构成员<br>\n这种形式来引用相应的结构成员。<br>\n运算符。和 -&gt; 都是从左至右结合的，所以以下声明都是等价的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct rec r , * rp = &amp; r ; </span><br><span class=\"line\"></span><br><span class=\"line\">r.pt1.x </span><br><span class=\"line\">rp-&gt;pt1.x </span><br><span class=\"line\">(r.pt1).x </span><br><span class=\"line\">(rp-&gt;pt1).x</span><br></pre></td></tr></table></figure>\n<p>在所有运算符中，下面 4 个运算符的优先级最高：结构运算符 “.” 和 “-&gt;”、用于函数<br>\n调用的 “()” 以及用于下标的 “[]”，因此，它们同操作数之间的结合也最紧密。例如，对于<br>\n结构声明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct &#123; </span><br><span class=\"line\">    int len; </span><br><span class=\"line\">    char *str; </span><br><span class=\"line\">&#125; *p ;</span><br></pre></td></tr></table></figure>\n<p>表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">++p-&gt;len</span><br></pre></td></tr></table></figure>\n<p>将增加 len 的值，而不是增加 p 的值，这是田为，其中的隐含括号关系是 ++(p-&gt;len)。可 以使用括号改变结合次序。例如：(<ins>p)-&gt;len 将先执行 p 的加 1 操作，再对 len 执行操作； 而 (p</ins>)-&gt;len 则先对 len 执行操作，然后再将 p 加 1（该表达式中的括号可以省略）。 同样的道理，*p-&gt;str 读取的是指针 str 所指向的对象的值；*p-&gt;str<ins> 先读取指针 str 指向的对象的值，然后再将 str 加 1（与 * s</ins> 相同）；(*p-&gt;str）<ins>将指针 str 指向 的对象的值加 1；*p</ins>-&gt;str 先读取指针 str 指向的对象的值，然后再将 p 加 1。</p>\n<h3 id=\"结构数组\"><a class=\"markdownIt-Anchor\" href=\"#结构数组\">#</a> 结构数组</h3>\n<p>考虑编写一个程序，用来统计输入中各个 C 语言关键字出现的次数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct key &#123;</span><br><span class=\"line\">    char *word;</span><br><span class=\"line\">    int count;</span><br><span class=\"line\">&#125; keytab[] = &#123;</span><br><span class=\"line\">    &quot;auto&quot;, 0,</span><br><span class=\"line\">    &quot;break&quot;, 0,</span><br><span class=\"line\">    &quot;case&quot;, 0,</span><br><span class=\"line\">    &quot;char&quot;, 0,</span><br><span class=\"line\">    &quot;const&quot;, 0,</span><br><span class=\"line\">    &quot;continue&quot;, 0,</span><br><span class=\"line\">    &quot;default&quot;, 0,</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">    &quot;unsigned&quot;, 0,</span><br><span class=\"line\">    &quot;void&quot;, 0,</span><br><span class=\"line\">    &quot;volatile&quot;, 0,</span><br><span class=\"line\">    &quot;while&quot;, 0</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>与结构成员相对应，初值也要按照成对的方式列出。更精确的做法是，将每一行（即每个结<br>\n构）的初值都括在花括号内，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;auto&quot;, 0 &#125;, </span><br><span class=\"line\">&#123; &quot;break&quot;, 0 &#125;, </span><br><span class=\"line\">&#123; &quot;case&quot;, 0 &#125;, </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>但是，如果初值是简单变量或字符串，并且其中的任何值都不为空，则内层的花括号可以省 略。通常情况下，如果初值存在并且方括号 [ ] 中没有数值，编译程序将计算数组 keytab 中 的项数。<br>\n在统计关键字出现次数的程序中，我们首先定义了 keytab。主程序反复调用函数 getword 读取输入，每次读取一个单词。每个单词将通过折半查找函数在 keytab 中进行查找。注意，关键字列表必须按升序存储在 keytab 中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;ctype.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#define MAXWORD 100</span><br><span class=\"line\">int getword(char *, int);</span><br><span class=\"line\">int binsearch(char *, struct key *, int);</span><br><span class=\"line\">/* count C keywords */</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    char word[MAXWORD];</span><br><span class=\"line\">    while (getword(word, MAXWORD) != EOF)</span><br><span class=\"line\">        if (isalpha(word[0]))</span><br><span class=\"line\">              if ((n = binsearch(word, keytab, NKEYS)) &gt;= 0)</span><br><span class=\"line\">                    keytab[n].count++;</span><br><span class=\"line\">    for (n = 0; n &lt; NKEYS; n++)</span><br><span class=\"line\">        if (keytab[n].count &gt; 0)</span><br><span class=\"line\">            printf(&quot;%4d %s\\n&quot;,</span><br><span class=\"line\">                keytab[n].count, keytab[n].word);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* binsearch: find word in tab[0]...tab[n-1] */</span><br><span class=\"line\">int binsearch(char *word, struct key tab[], int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int cond;</span><br><span class=\"line\">    int low, high, mid;</span><br><span class=\"line\">    low = 0;</span><br><span class=\"line\">    high = n - 1;</span><br><span class=\"line\">    while (low &lt;= high) &#123;</span><br><span class=\"line\">        mid = (low+high) / 2;</span><br><span class=\"line\">        if ((cond = strcmp(word, tab[mid].word)) &lt; 0)</span><br><span class=\"line\">            high = mid - 1;</span><br><span class=\"line\">        else if (cond &gt; 0)</span><br><span class=\"line\">            low = mid + 1;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            return mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int getword ( char * word , int lim ) &#123;</span><br><span class=\"line\">    int c , getch ( void ) ; </span><br><span class=\"line\">    void ungetch ( int ) ; </span><br><span class=\"line\">    char * w = word ; </span><br><span class=\"line\">    while ( isspace ( c = getch ( ) ) ) ; </span><br><span class=\"line\">    if ( c != EOF ) * w ++ ; </span><br><span class=\"line\">    if ( ! isalpha ( c ) ) &#123; * w = &#x27;\\0&#x27; ; return c ; &#125; </span><br><span class=\"line\">    for ( ; -- lim &gt; 0 ; w ++ ) </span><br><span class=\"line\">        if ( ! isnum ( * w = getch ( ) ) ) &#123;</span><br><span class=\"line\">            ungetch ( * w ) ; break ; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    * w = &#x27;\\0&#x27; ; </span><br><span class=\"line\">    return word[0] ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*我们可以通过如下方法计算NKEYS的值*/</span><br><span class=\"line\">#define NKEYS ( sizeof keytab / sizeof ( struct key ) ) </span><br><span class=\"line\">#define NKEYS ( sizeof keytab / sizeof keytab[0] ) </span><br></pre></td></tr></table></figure>\n<p>getchar 函数的返回值也是 int 类型的</p>\n<h3 id=\"指向结构的指针\"><a class=\"markdownIt-Anchor\" href=\"#指向结构的指针\">#</a> 指向结构的指针</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt; </span><br><span class=\"line\">#include &lt;ctype.h&gt; </span><br><span class=\"line\">#include &lt;string.h&gt; </span><br><span class=\"line\">#define MAXWORD 100 </span><br><span class=\"line\">int getword(char *, int); </span><br><span class=\"line\">struct key *binsearch(char *, struct key *, int); </span><br><span class=\"line\">/* count C keywords; pointer version */ </span><br><span class=\"line\">int main() </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    char word[MAXWORD]; </span><br><span class=\"line\">    struct key *p; </span><br><span class=\"line\">    while (getword(word, MAXWORD) != EOF) </span><br><span class=\"line\">        if (isalpha(word[0])) </span><br><span class=\"line\">            if ((p=binsearch(word, keytab, NKEYS)) != NULL) </span><br><span class=\"line\">                p-&gt;count++; </span><br><span class=\"line\">    for (p = keytab; p &lt; keytab + NKEYS; p++) </span><br><span class=\"line\">        if (p-&gt;count &gt; 0) </span><br><span class=\"line\">            printf(&quot;%4d %s\\n&quot;, p-&gt;count, p-&gt;word); </span><br><span class=\"line\">    return 0; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">/* binsearch: find word in tab[0]...tab[n-1] */ </span><br><span class=\"line\">struct key *binsearch(char *word, struck key *tab, int n) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    int cond; </span><br><span class=\"line\">    struct key *low = &amp;tab[0]; </span><br><span class=\"line\">    struct key *high = &amp;tab[n]; </span><br><span class=\"line\">    struct key *mid; </span><br><span class=\"line\">    while (low &lt; high) &#123; </span><br><span class=\"line\">        mid = low + (high-low) / 2; </span><br><span class=\"line\">        if ((cond = strcmp(word, mid-&gt;word)) &lt; 0) </span><br><span class=\"line\">            high = mid; </span><br><span class=\"line\">        else if (cond &gt; 0) </span><br><span class=\"line\">            low = mid + 1; </span><br><span class=\"line\">        else </span><br><span class=\"line\">            return mid; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    return NULL; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一个部分比较简单，就不细写了，上面的程序等于是改写了一下。搜索函数里面的 while 循环是为了防止死循环写的，当 high==low 的时候，如果没有 low&lt;high 这个条件会一直死循环下去。<br>\n特别需要注意的是千万不要认为结构的长度等于各成员长度的和。因为不同的对象有不同的对齐要 求，所以，结构中可能会出现未命名的 “空穴 “（hole）。例如，假设 char 类型占用一个字节，int 类型占用 4 个字节，则下列结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct &#123; </span><br><span class=\"line\">    char c; </span><br><span class=\"line\">    int i; </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<p>可能需要 8 个字节的存储空间，而不是 5 个字节。使用 sizeof 运算符可以返回正确的对象<br>\n长度。</p>\n<h3 id=\"自引用结构\"><a class=\"markdownIt-Anchor\" href=\"#自引用结构\">#</a> 自引用结构</h3>\n<p>假定我们需要处理一个更一般化的问题：统计输入中所有单词的出现次数。因为预先不 知道出现的单词列表，所以无法方便地排序，并使用折半查找；也不能分别对输入中的每个单词都执行一次线性查找，看它在前面是否已经出现，这样做，程序的执行将花费太长的时 间。（更准确地说，程序的执行时间是与输入单词数目的二次方成比例的。）我们该如何组织这些数据，才能够有效地处理一系列任意的单词呢？<br>\n一种解决方法是，在读取输入中任意单词的同时，就将它放置到正确的位置，从而始终 保证所有单词是按顺序排列的。虽然这可以不用通过在线性数组中移动单词来实现，但它仍 然会导致程序执行的时间过长。我们可以使用一种称为二叉树的数据结构来取而代之。 每个不同的单词在树中都是一个节点，每个节点包含：</p>\n<ol>\n<li>一个指向该单词内容的指针</li>\n<li>一个统计出现次数的计数值・一个指向左子树的指针</li>\n<li>一个指向右子树的指针<br>\n任何节点最多拥有两个子树，也可能只有一个子树或一个都没有。 对节点的所有操作要保证，任何节点的左子树只包含按字典序小于该节点中单词的那些单词，右子树只包含按字典序大于该节点中单词的那些单词。要查找一个新单词是否已经在树中，可以从根节点开始，比较新单词与该节点中的单词。若 匹配，则得到肯定的答案。若新单词小于该节点中的单词，则在左子树中继续查找，否则在 右子树中查找。如在搜寻方向上无子树，则说明新单词不在树中，并且，当前的空位置就是 存放新加入单词的正确位置。因为从任意节点出发的查找都要按照同样的方式查找它的一个子树，所以该过程是递归的。相应地，在插入和打印操作中使用递归过程也是很自然的事情。<br>\n对节点的递归的：</li>\n</ol>\n",
            "tags": [
                "C语言",
                "结构"
            ]
        },
        {
            "id": "http://amentiraz.github.io/2021/11/04/%E6%8C%87%E9%92%88/",
            "url": "http://amentiraz.github.io/2021/11/04/%E6%8C%87%E9%92%88/",
            "title": "指针",
            "date_published": "2021-11-04T00:48:35.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-YMkJXQJc\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"447578836\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>指针是一种保存变量地址的变量。在存储时，内存被分为一块一块的。每一块都有一个特有的编号。而这个编号可以暂时理解为指针，就像酒店的门牌号一样。</p>\n<span id=\"more\"></span>\n<h3 id=\"指针与地址\"><a class=\"markdownIt-Anchor\" href=\"#指针与地址\">#</a> 指针与地址</h3>\n<p>一元运算符 &amp; 可用于取一个对象的地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = &amp; c ; </span><br></pre></td></tr></table></figure>\n<p>将把 c 的地址赋值给变量 p，我们称 p 为 “指向” c 的指针。地址运算符 &amp; 只能应用于内存中 的对象，即变量与数组元素。它不能作用于表达式、常量或 register 类型的变量。<br>\n一元运算符 * 是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对象。下列程序介绍了 &amp; 与 * 的使用方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int x = 1 , y = 2 , z[10] ; </span><br><span class=\"line\">ip = &amp; x ; //表明表达式*ip 的结果是 int 类型。</span><br><span class=\"line\">y = * ip ; </span><br><span class=\"line\">* ip = 0 ; </span><br><span class=\"line\">ip = &amp; z[0] ; </span><br></pre></td></tr></table></figure>\n<p>对函数的声明也可以采用这种方式。<br>\n例如，声明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double *dp，atof(char *); </span><br></pre></td></tr></table></figure>\n<p>表明，在表达式中，*dp 和 atof (s) 的值都是 double 类型，且 atof 的参数是一个指向 char 类型的指针。<br>\n指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型。（一个例外情况是指向 void 类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身。)<br>\n 如果指针 ip 指向整型变量，那么在 x 可以出现的任何上下文中都可以使用 * ip，因此， 语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*ip = *ip + 10; </span><br></pre></td></tr></table></figure>\n<p>将把<em> ip 的值增加 10。 一元运算符</em>和 &amp; 的优先级比算术运算符的优先级高，因此，赋值语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y = *ip + 1 </span><br></pre></td></tr></table></figure>\n<p>将把 * ip 指向的对象的值取出并加 1，然后再将结果赋值给 y，而下列赋值语句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*ip += 1 </span><br></pre></td></tr></table></figure>\n<p>则将 ip 指向的对象的值加 1，它等同于</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">++*ip </span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*ip)++ </span><br></pre></td></tr></table></figure>\n<p>语句的执行结果。语句 (* ip)<ins> 中的圆括号是必需的，否则，该表达式将对 ip 进行加 1 运算，<br>\n而不是对 ip 指向的对象进行加 1 运算，这是因为，类似于 * 和</ins>这样的一元运算符遵循从右 至左的结合顺序。<br>\n最后说明一点，由于指针也是变量，所以在程序中可以直接使用，而不必通过间接引用<br>\n的方法使用。例如，如果 iq 是另一个指向整型的指针，那么语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iq = ip </span><br></pre></td></tr></table></figure>\n<p>将把 ip 中的值拷贝到 iq 中，这样，指针 iq 也将指向 ip 指向的对象。</p>\n<h3 id=\"指针与指针参数\"><a class=\"markdownIt-Anchor\" href=\"#指针与指针参数\">#</a> 指针与指针参数</h3>\n<p>为了使被调用函数直接修改主调函数中的变量值，我们可以使主调程序将指向所要交换的变量的指针传递给被调用函数，即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swap ( &amp; a , &amp; b ) ; </span><br></pre></td></tr></table></figure>\n<p>由于一元运算符 &amp; 用来取变量的地址，这样 &amp; a 就是一个指向变量 a 的指针。swap 函数的所有参数都声明为指针，并且通过这些指针来间接访问它们所指向的操作数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void swap ( int * px , int * py ) &#123;</span><br><span class=\"line\">    int temp ; </span><br><span class=\"line\">    temp = * px ; </span><br><span class=\"line\">    * px = * py ; </span><br><span class=\"line\">    * py = temp ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>指针参数使得被调用函数能够访问和修改主调函数中对象的值。<br>\n我们来看一个可以接受自由格式输入，并执行转换，并同时返回得到的整数和文件结束标志（EOF）的函数。<br>\n如果你觉得你已经了解了可以不用看下面的代码，直接进入下一节。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int getch ( void ) &#123; return ( bufp &gt; 0 ) ? buf[--bufp] : getchar ( ) ; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void ungetch ( int c ) &#123; </span><br><span class=\"line\">    if ( bufp &gt;= BUFSIZE ) printf ( &quot;ungetch:too many characters\\n&quot; ) ; </span><br><span class=\"line\">    else buf[bufp++] = c ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int getint ( int * pn ) &#123;</span><br><span class=\"line\">    int c , sign ; </span><br><span class=\"line\">    while ( isspace ( c = getch ( ) ) ) ;</span><br><span class=\"line\">    if ( ! isdigit ( c ) &amp;&amp; c != EOF &amp;&amp; c != &#x27;+&#x27; &amp;&amp; c != &#x27;-&#x27; ) &#123;</span><br><span class=\"line\">        ungetch ( c ) ; return 0 ;     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sign = ( c == &#x27;-&#x27; ) ? -1 : 1 ; </span><br><span class=\"line\">    if ( c == &#x27;+&#x27; || c == &#x27;-&#x27; ) c = getch ( ) ; </span><br><span class=\"line\">    for ( * pn = 0 ; isdigit ( c ) ; c = getch ( ) ) </span><br><span class=\"line\">        * pn = 10 * * pn + c - &#x27;0&#x27; ; </span><br><span class=\"line\">    * pn *= sign ; </span><br><span class=\"line\">    if ( c != EOF ) ungetch ( c ) ; </span><br><span class=\"line\">    return c ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 getint 函数中，*pn 始终作为一个普通的整形变量使用。</p>\n<h3 id=\"指针与数组\"><a class=\"markdownIt-Anchor\" href=\"#指针与数组\">#</a> 指针与数组</h3>\n<p>一般来说，用指针编写的程序比用数组下标编写的程序执行速度快，但另一方面，用指针实现的程序理解 起来稍微困难一些。<br>\n声明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a[10]; </span><br></pre></td></tr></table></figure>\n<p>定义了一个长度为 10 的数组 a。换句话说，它定义了一个由 10 个对象组成的集合，这 10 个<br>\n对象存储在相邻的内存区域中，名字分别为 a [0]、a [1]、…、a [9]<br>\n 如果 pa 指向数组中的某个特定元素，那么，根据指针运算的定义，pa+1 将指向下一个元素，pa+i 将指向 pa 所指向数组元素之后的第 i 个元素，而 pa-i 将指向 pa 所指向数组元素之前的第 i 个元素。因此，如果指针 pa 指向 a [0]，那么 * (pa+1) 引用的是数组元素 a [1] 的内容，pa+i 是数组元素 a [i] 的地址，* (pa+i) 引用的是数组元素 a [i] 的内容<br>\n无论数组 a 中元素的类型或数组长度是什么，上面的结论都成立。“指针加 1” 就意味着，pa+1 指向 pa 所指向的对象的<strong>下一个对象</strong>。相应地，pa+i 指向 pa 所指向的对象之后的第 i 个对象。<br>\n对数组元素 a [i] 的引用也可以写成 *(a+i) 这种形式。对第一次接触这种写法的人来说， 可能会觉得很奇怪。在计算数组元素 a [i] 的值时，C 语言实际上先将其转换为 *(a+i) 的形<br>\n式，然后再进行求值，因此在程序中这两种形式是等价的。如果对这两种等价的表示形式分 别施加地址运算符 &amp;，便可以得出这样的结论：&amp;a [i] 和 a+i 的含义也是相同的。a+i 是 a<br>\n 之后第 i 个元素的地址。相应地，如果 pa 是个指针，那么，在表达式中也可以在它的后面加 下标。pa [i] 与 *(pa+i) 是等价的。简而言之，一个通过数组和下标实现的表达式可等价地 通过指针和偏移量实现。<br>\n但是，我们必须记住，数组名和指针之间有一个不同之处，指针是一个变量，因此，在 C 语言中，语句 pa=a 和 pa<ins> 都是合法的。但数组名不是变量，因此，类似于 a=pa 和 a</ins> 形式的语句是非法的。<br>\n当把数组名传递给一个函数时，实际上传递的是该数组第一个元索的地址。在被调用函数中，该参数是一个局部变量，因此，数组名参数必须是一个指针，也就是一个存储地址值 的变量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*return length of s */</span><br><span class=\"line\">int strlen ( char * s ) &#123;</span><br><span class=\"line\">    int n ; </span><br><span class=\"line\">    for ( n = 0 ; * s != &#x27;\\0&#x27; ; s ++ ) n ++ ; </span><br><span class=\"line\">    return n ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行 s++ 运算不会影响到 strlen 函数的调用者中的字符串，它仅对该指针在 strlen 函数中的私有副本进行自增运算。<br>\n以下的函数调用均正确：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strlen ( &quot;hello world&quot; ) ;</span><br><span class=\"line\">char array[100] ; </span><br><span class=\"line\">strlen ( array ) ; </span><br><span class=\"line\">char * ptr ; </span><br><span class=\"line\">strlen ( ptr ) ; </span><br></pre></td></tr></table></figure>\n<p>在函数定义中，形式参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char s[]; </span><br></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *s; </span><br></pre></td></tr></table></figure>\n<p>是等价的。我们通常更习惯于使用后一种形式，因为它比前者更直观地表明了该参数是一个指针。如果将数组名传递给函数，函数可以根据情况判定是按照数组处理还是按照指针处理，随后根据相应的方式操作该参数。为了直观且恰当地描述函数，在函数中甚至可以同时使用数组和指针这两种表示方法。<br>\n也可以将指向子数组起始位置的指针传递给函数，这样，就将数组的一部分传递给了函<br>\n数。例如，如果 a 是一个数组，那么下面两个函数调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(&amp;a[2]) </span><br></pre></td></tr></table></figure>\n<p>与</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(a+2) </span><br></pre></td></tr></table></figure>\n<p>都将把起始于 a [2] 的子数组的地址传递给函数 f。在函数 f 中，参数的声明形式可以为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(int arr[]) &#123; ... &#125; </span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(int *arr) &#123; ... &#125; </span><br></pre></td></tr></table></figure>\n<p>对于函数 f 来说，它并不关心所引用的是否只是一个更大数组的部分元素。 如果确信相应的元素存在，也可以通过下标访问数组第一个元素之前的元素。类似于<br>\n p [-1]、p [-2] 这样的表达式在语法上都是合法的，它们分别引用位于 p [0] 之前的两个元素。<br>\n当然，引用数组边界之外的对象是非法的。</p>\n<h3 id=\"地址算术运算\"><a class=\"markdownIt-Anchor\" href=\"#地址算术运算\">#</a> 地址算术运算</h3>\n<p>下面我们将给出函数 alloc 和 afree，他们分别对标 malloc.h 头文件中的 malloc 函数和 free 函数，只是功能相对于 malloc 和 free 更菜而已。这里就先直接贴代码，看不懂也没关系，继续往下看就行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char * alloc ( int n ) &#123;</span><br><span class=\"line\">    if ( ( allocbuf + ALLOCSIZE - allocp &gt;= n ) ) &#123;</span><br><span class=\"line\">        allocp += n ;</span><br><span class=\"line\">        return allocp - n ; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else return 0 ; </span><br><span class=\"line\">    //C语言保证，0永远不是有效的数据地址，因此返回值0可用来表示发生了异常事件</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void afree ( char * p ) &#123;</span><br><span class=\"line\">    if ( p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE ) allocp = p ;</span><br><span class=\"line\">    //对指针进行比较</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，在某些情况下对指针可以进 行比较运算。例如，如果指针 p 和 q 指向同一个数组的成员，那么它们之间就可以进行类似 于 ==、!=、&lt;、&gt;= 的关系比较运算。如果 p 指向的数组元素的位置在 q 指向的数组元素位置 之前，那么关系表达式<br>\n p &lt; q<br>\n 的值为真。任何指针与 0 进行相等或不等的比较运算都有意义。但是，指向不同数组的元素的指针之间的算术或比较运算没有定义。（这里有一个特例：指针的算术运算中可使用数组最 后一个元素的下一个元素的地址。）<br>\n其次。我们从前面可以看到，指针可以和整数进行相加或相减运算。例如，结构<br>\n p + n<br>\n 表示指针 p 当前指向的对象之后第 n 个对象的地址。无论指针 p 指向的对象是何种类型，上述结论都成立。在计算 p+n 时，n 将根据 p 指向的对象的长度按比例缩放，而 p 指向的对象的长度则取决于 p 的声明。例如，如果 int 类型占 4 个字节的存储空间，那么在 int 类型的计算中，对应的 n 将按 4 的倍数来计算。指针的减法运算也是有意义的：如果 p 和 q 指向相同数组中的元索，且 p&lt;q，那么 q-p+1 就是位于 p 和 q 指向的元索之间的元素的数目。我们由此可以编写出函数 strlen 的另一个<br>\n版本，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int strlen ( char * s ) &#123;</span><br><span class=\"line\">    char * p = s ; </span><br><span class=\"line\">    while ( * p != &#x27;\\0&#x27; ) p ++ ; </span><br><span class=\"line\">    return p - s ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符指针与函数\"><a class=\"markdownIt-Anchor\" href=\"#字符指针与函数\">#</a> 字符指针与函数</h3>\n<p>字符串常量是一个字符数组，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;I am a string&quot; </span><br></pre></td></tr></table></figure>\n<p>在字符串的内部表示中，字符数组以空字符’\\0’结尾，所以，程序可以通过检查空字符找到 字符数组的结尾。字符串常量占据的存储单元数也因此比双引号内的字符数大 1。<br>\n字符串常量最常见的用法也许是作为函数参数，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">princf(&quot;hello, world\\n&quot;&#125;; </span><br></pre></td></tr></table></figure>\n<p>当类似于这样的一个字符串出现在程序中时，实际上是通过字符指针访问该字符串的。在上<br>\n述语句中，printf 接受的是一个指向字符数组第一个字符的指针。也就是说，字符串常量可 通过一个指向其第一个元素的指针访问。<br>\n除了作为函数参数以外，字符串常量还有其它的用法。例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *pmessage ; </span><br><span class=\"line\">pmessage = &quot;now is the time&quot; ; </span><br></pre></td></tr></table></figure>\n<p>此操作把一个指向该字符数组的指针赋值给 pmessage。该过程并没有进行字符串的复制，而只 是涉及到指针的操作。C 语言没有提供将整个字符串作为一个整体进行处理的运算符。<br>\n下面两个定义之间有很大的差别：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char amessage[] = &quot;nw is the time&quot;; /* 定义一个数组 */ </span><br><span class=\"line\">char *pmessage = &quot;now is the time&quot;; /* 定义一个指针 */ </span><br></pre></td></tr></table></figure>\n<p>上述声明中，amessage 是一个仅仅足以存放初始化字符串以及空字符’\\0’的一维数组。数组中的单个字符可以进行修改，但 amessage 始终指向同一个存储位置。另一方面，pmessage 是一个指针，其初值指向一个字符串常量，之后它可以被修改以指向其它地址，但如果试图 修改字符串的内容，结果是没有定义的<br>\n掌握了上面的知识，我们现在可以理解下面的程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void strcpy ( char * s , char * t ) while ( * s ++ = * t ++ ) ; </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int strcmp ( char * s , char * t ) &#123;</span><br><span class=\"line\">    for ( ; * s == * t ; s ++ , t ++ ) if ( * s == &#x27;\\0&#x27; ) return 0 ; </span><br><span class=\"line\">    return * s - * t ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组指针与指向指针的指针\"><a class=\"markdownIt-Anchor\" href=\"#数组指针与指向指针的指针\">#</a> 数组指针与指向指针的指针</h3>\n<p>下面是一个运用快速排序来实现字符串排序的程序，qsort 部分可自行使用快排实现，我自己想了想也可以用普通的 sort + 结构体实现，或许会更好点，这里就不展开了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt; </span><br><span class=\"line\">#include &lt;string.h&gt; </span><br><span class=\"line\">#define MAXLINES 5000 /* max #lines to be sorted */ </span><br><span class=\"line\">char *lineptr[MAXLINES]; /* pointers to text lines */ </span><br><span class=\"line\">int readlines(char *lineptr[], int nlines); </span><br><span class=\"line\">void writelines(char *lineptr[], int nlines); </span><br><span class=\"line\">void qsort(char *lineptr[], int left, int right); </span><br><span class=\"line\">/* sort input lines */ </span><br><span class=\"line\">main() </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    int nlines; /* number of input lines read */ </span><br><span class=\"line\">    if ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) &#123; </span><br><span class=\"line\">        qsort(lineptr, 0, nlines-1); </span><br><span class=\"line\">        writelines(lineptr, nlines); </span><br><span class=\"line\">        return 0; </span><br><span class=\"line\">    &#125; else &#123; </span><br><span class=\"line\">        printf(&quot;error: input too big to sort\\n&quot;); </span><br><span class=\"line\">        return 1; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">    #define MAXLEN 1000 /* max length of any input line */ </span><br><span class=\"line\">    int getline(char *, int); </span><br><span class=\"line\">    char *alloc(int); </span><br><span class=\"line\">/* readlines: read input lines */ </span><br><span class=\"line\">int readlines(char *lineptr[], int maxlines) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    int len, nlines; </span><br><span class=\"line\">    char *p, line[MAXLEN]; </span><br><span class=\"line\">    nlines = 0; </span><br><span class=\"line\">    while ((len = getline(line, MAXLEN)) &gt; 0) </span><br><span class=\"line\">        if (nlines &gt;= maxlines || p = alloc(len) == NULL) </span><br><span class=\"line\">            return -1; </span><br><span class=\"line\">        else &#123; </span><br><span class=\"line\">            line[len-1] = &#x27;\\0&#x27;; /* delete newline */ </span><br><span class=\"line\">            strcpy(p, line); </span><br><span class=\"line\">            lineptr[nlines++] = p; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    return nlines; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">/* writelines: write output lines */ </span><br><span class=\"line\">void writelines(char *lineptr[], int nlines) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    int i; </span><br><span class=\"line\">    for (i = 0; i &lt; nlines; i++) </span><br><span class=\"line\">        printf(&quot;%s\\n&quot;, lineptr[i]); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void qsort(char *v[], int left, int right) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    int i, last; </span><br><span class=\"line\">    void swap(char *v[], int i, int j); </span><br><span class=\"line\">    if (left &gt;= right) /* do nothing if array contains */ </span><br><span class=\"line\">        return; /* fewer than two elements */ </span><br><span class=\"line\">    swap(v, left, (left + right)/2); </span><br><span class=\"line\">    last = left; </span><br><span class=\"line\">    for (i = left+1; i &lt;= right; i++) </span><br><span class=\"line\">        if (strcmp(v[i], v[left]) &lt; 0) </span><br><span class=\"line\">            swap(v, ++last, i); </span><br><span class=\"line\">        swap(v, left, last); </span><br><span class=\"line\">        qsort(v, left, last-1); </span><br><span class=\"line\">        qsort(v, last+1, right); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* swap: interchange v[i] and v[j] */ </span><br><span class=\"line\">void swap(char *v[], int i, int j) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    char *temp; </span><br><span class=\"line\">    temp = v[i]; </span><br><span class=\"line\">    v[i] = v[j]; </span><br><span class=\"line\">    v[j] = temp; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在该例子中，指针数组 lineptr 的声明是新出现的重要概念：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *lineptr[MAXLINES]; </span><br></pre></td></tr></table></figure>\n<p>它表示 lineptr 是一个具有 MAXLINES 个元素的一维数组，其中数组的每个元素是一个指向字符类型对象的指针。也就是说，lineptr [i] 是一个字符指针，而 * lineptr [i] 是该指针指向的第 i 个文本行的首字符。 由于 lineptr 本身是一个数组名，因此，可按照前面例子中相同的方法将其作为指针使用，这样，writelines 函数可以改写为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* writelines: write output lines */ </span><br><span class=\"line\">void writelines(char *lineptr[], int nlines) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    while (nlines-- &gt; 0) </span><br><span class=\"line\">        printf(&quot;%s\\n&quot;, *lineptr++); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（注意这里的数组变量 lineptr 可以改变值）<br>\n循环开始执行时，*lineptr 指向第一行，每执行一次自增运算都使得 lineptr 指向下 一行，同时对 nlines 进行自减运算。</p>\n<h3 id=\"多维数组\"><a class=\"markdownIt-Anchor\" href=\"#多维数组\">#</a> 多维数组</h3>\n<p>如果将二维数组作为参数传递给函数，那么在函数的参数声明中必须指明数组的列数。<br>\n数组的行数没有太大关系，因为前面已经讲过，函数调用时传递的是一个指针，它指向由行 向量构成的一维数组，其中每个行向量是具有 13 个整型元素的一维数组。在该例子中，传递 给函数的是一个指向很多对象的指针，其中每个对象是由 13 个整型元素构成的一维数组。因 此，如果将数组 daytab 作为参数传递给函数 f，那么 f 的声明应该写成下列形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(int daytab[2][13]) &#123; ... &#125; </span><br></pre></td></tr></table></figure>\n<p>也可以写成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(int daytab[][13]) &#123; ... &#125; </span><br></pre></td></tr></table></figure>\n<p>因为数组的行数无关紧要，所以，该声明还可以写成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(int (*daytab)[13]) &#123; ... &#125; </span><br></pre></td></tr></table></figure>\n<p>这种声明形式表明参数是一个指针，它指向具有 13 个整型元素的一维数组。因为方括号 [] 的<br>\n优先级高于 * 的优先级，所以上述声明中必须使用圆括号。如果去掉括号，则声明变成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int *daytab[13] </span><br></pre></td></tr></table></figure>\n<p>这相当于声明了一个数组，该数组有 13 个元素，其中每个元素都是一个指向整型对象的指针。<br>\n一般来说，除数组的第一维（下标）可以不指定大小外，其余各维都必须明确指定大小。</p>\n<h3 id=\"指针数组的初始化\"><a class=\"markdownIt-Anchor\" href=\"#指针数组的初始化\">#</a> 指针数组的初始化</h3>\n<p>考虑这样一个问题：编写一个函数 month_name (n)，它返回一个指向第 n 个月名字的 字符串的指针。这是内部 static 类型数组的一种理想的应用。month_name 函数中包含一 个私有的字符串数组，当它被调用时，返回一个指向正确元素的指针。本节将说明如何初始<br>\n化该名字数组。<br>\n指针数组的初始化语法和前面所讲的其它类型对象的初始化语法类似：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* month_name: return name of n-th month */ </span><br><span class=\"line\">char *month_name(int n) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    static char *name[] = &#123; </span><br><span class=\"line\">        &quot;Illegal month&quot;, </span><br><span class=\"line\">        &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, </span><br><span class=\"line\">        &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, </span><br><span class=\"line\">        &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, </span><br><span class=\"line\">        &quot;October&quot;, &quot;November&quot;, &quot;December&quot; </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return name ; </span><br></pre></td></tr></table></figure>\n<p>其中，name 的声明与排序例子中 lineptr 的声明相同，是一个一维数组，数组的元素为字 符指针。name 数组的初始化通过一个字符串列表实现，列表中的每个字符串赋值给数组相应 位置的元素。第 i 个字符串的所有字符存储在存储器中的某个位置，指向它的指针存储在 name [i] 中。由于上述声明中没有指明 name 的长度，因此，编译器编译时将对初值个数进 行统计，并将这一准确数字填入数组的长度。</p>\n<h3 id=\"指针与多维数组\"><a class=\"markdownIt-Anchor\" href=\"#指针与多维数组\">#</a> 指针与多维数组</h3>\n<p>对于 C 语言的初学者来说，很容易混淆二维数组与指针数组之间的区别，比如上面例子 中的 name。假如有下面两个定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a[10][20]; </span><br><span class=\"line\">int \\*b[10]; </span><br></pre></td></tr></table></figure>\n<p>那么，从语法角度讲，a [3][4] 和 b [3][4] 都是对一个 int 对象的合法引用。但 a 是一个真正的二维数组，它分配了 200 个 int 类型长度的存储空间，并且通过常规的矩阵下标计算公式 20×row+col（其中，row 表示行，col 表示列）计算得到元素 a [row][col] 的位置。但是，对 b 来说，该定义仅仅分配了 10 个指针，并且没有对它们初始化，它们的初始化必须以显式的方式进行，比如静态初始化或通过代码初始化。假定 b 的每个元素 (其实只取决于最大的）都指向一个具有 20 个元 素的数组，那么编译器就要为它分配 200 个 int 类型长度的存储空间以及 10 个指针的存储空间。指针数组的一个重要优点在于，数组的每一行长度可以不同，也就是说，b 的每个元素不 必都指向一个具有 20 个元素的向量，某些元素可以指向具有 2 个元素的向量，某些元素可以指向具有 50 个元素的向量，而某些元素可以不指向任何向量。</p>\n<h3 id=\"命令行参数\"><a class=\"markdownIt-Anchor\" href=\"#命令行参数\">#</a> 命令行参数</h3>\n<p>编程实际场景中感觉是不常用的，我自己也没看懂，日后补<br>\n略</p>\n<h3 id=\"指向函数的指针\"><a class=\"markdownIt-Anchor\" href=\"#指向函数的指针\">#</a> 指向函数的指针</h3>\n<p>在系统学习完指向含糊的指针后，我发现这玩意就是个纸老虎，只是听起来挺高大上的，其实非常简单。<br>\n在实际运用中就差不多减少一点代码行数而已，感觉替代性挺强的。（也可能是因为我太菜了）<br>\n那就开始吧<br>\n在 C 语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。我们接下来将修改排序函数，在给定可选参数 - n 的情况下，该函数将按树枝大小而非字典顺序对输入行进行排序。<br>\n排序程序通常包括 3 部分：判断任何两个对象之间次序的比较操作、颠倒对象次序的交 换操作、一个用于比较和交换对象直到所有对象都按正确次序排列的排序算法。<br>\n由于排序算法与比较、交换操作无关，因此，通过在排序算法中调用不同的比较和交换函数，便可以实 现按照不同的标准排序。这就是我们的新版本排序函数所采用的方法。<br>\n函数 strcmp 按字典顺序比较两个输入行。在这里，我们还需要一个以数值为基础来比较两个输入行，并返回与 strcmp 同样的比较结果的函数 numcmp。这些函 数在 main 之前声明，并且，指向恰当函数的指针将被传递给 qsort 函数。在这里，参数的出错处理并不是问题的重点，我们将主要考虑指向函数的指针问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#define MAXLINES 5000 /* max #lines to be sorted */</span><br><span class=\"line\">char *lineptr[MAXLINES]; /* pointers to text lines */</span><br><span class=\"line\">int readlines(char *lineptr[], int nlines);</span><br><span class=\"line\">void writelines(char *lineptr[], int nlines);</span><br><span class=\"line\">void qsort(void *lineptr[], int left, int right,</span><br><span class=\"line\">int (*comp)(void *, void *));</span><br><span class=\"line\">int numcmp(char *, char *);</span><br><span class=\"line\">/* sort input lines */</span><br><span class=\"line\">int main(int argc, char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int nlines; /* number of input lines read */</span><br><span class=\"line\">    int numeric = 0; /* 1 if numeric sort */</span><br><span class=\"line\">    if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &quot;-n&quot;) == 0)</span><br><span class=\"line\">        numeric = 1;</span><br><span class=\"line\">    if ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) &#123;</span><br><span class=\"line\">        qsort((void**) lineptr, 0, nlines-1,</span><br><span class=\"line\">            (int (*)(void*,void*))(numeric ? numcmp : strcmp));</span><br><span class=\"line\">        writelines(lineptr, nlines);</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        printf(&quot;input too big to sort\\n&quot;);</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* qsort: sort v[left]...v[right] into increasing order */</span><br><span class=\"line\">void qsort(void *v[], int left, int right,</span><br><span class=\"line\">int (*comp)(void *, void *))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i, last;</span><br><span class=\"line\">    void swap(void *v[], int, int);</span><br><span class=\"line\">    if (left &gt;= right) /* do nothing if array contains */</span><br><span class=\"line\">        return; /* fewer than two elements */</span><br><span class=\"line\">    swap(v, left, (left + right)/2);</span><br><span class=\"line\">    last = left;</span><br><span class=\"line\">    for (i = left+1; i &lt;= right; i++)</span><br><span class=\"line\">        if ((*comp)(v[i], v[left]) &lt; 0)</span><br><span class=\"line\">            swap(v, ++last, i);</span><br><span class=\"line\">    swap(v, left, last);</span><br><span class=\"line\">    qsort(v, left, last-1, comp);</span><br><span class=\"line\">    qsort(v, last+1, right, comp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在调用函数 qsort 的语句中，strcmp 和 numcmp 是函数的地址，因为它们是函数，所以前面不需要加上取地址运算符 &amp;，同样的原因，数组名前面也不需要 &amp; 运算符。<br>\n改写后的 qsort 函数能够处理任何数据类型，而不仅仅限于字符串。从函数 qsort 的 原型可以看出，它的参数表包括一个指针数组、两个整数和一个有两个指针参数的函数。其中，指针数组参数的类型为通用指针类型 void <em>。由于任何类型的指针都可以转换为 void</em> 类型，并且在将它转换回原来的类型时不会丢失信息，所以，调用 qsort 函数时可以将参数强制转换为 void * 类型。比较函数的参数也要执行这种类型的转换。这种转换通常不会影响到数据的实际表示，但要确保编译器不会报错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ( * comp ) ( void * , void * ) </span><br></pre></td></tr></table></figure>\n<p>它表明 comp 是一个指向函数的指针，该函数具有两个 void * 类型的参数，其返回值为 int。<br>\n值得注意的是圆括号是必须的，这样才能保证其中的各个部分正确结合，如果没有括号，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int * comp ( void * , void * ) </span><br></pre></td></tr></table></figure>\n<p>则表明 comp 是一个函数，该函数返回一个指向 int 类型的指针<br>\n我们在前面讲过函数 strcmp，占用于比较两个字符串。这里介绍的函数 numcmp 也是比 较两个字符串，但它通过调用 atof 计算字符串对应的数值，然后在此基础上进行比较：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">/* numcmp: compare s1 and s2 numerically */</span><br><span class=\"line\">int numcmp(char *s1, char *s2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    double v1, v2;</span><br><span class=\"line\">    v1 = atof(s1);</span><br><span class=\"line\">    v2 = atof(s2);</span><br><span class=\"line\">    if (v1 &lt; v2)</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    else if (v1 &gt; v2)</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>交换两个指引的 swap 函数和本章前面所述的 swap 函数相同，但它的参数声明为 void *<br>\n 类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void swap(void * v[], int i, int j;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void *temp;</span><br><span class=\"line\">    temp = v[i];</span><br><span class=\"line\">    v[i] = v[j];</span><br><span class=\"line\">    v[j] = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"链表\"><a class=\"markdownIt-Anchor\" href=\"#链表\">#</a> 链表</h3>\n<p>关于 malloc：</p>\n<h4 id=\"函数原型\"><a class=\"markdownIt-Anchor\" href=\"#函数原型\">#</a> 函数原型：</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern void \\*malloc(unsigned int num\\_bytes);</span><br></pre></td></tr></table></figure>\n<h4 id=\"malloc函数返回值\"><a class=\"markdownIt-Anchor\" href=\"#malloc函数返回值\">#</a> malloc 函数返回值</h4>\n<p>如果分配成功则返回指向被分配内存的指针，否则返回空指针 NULL。</p>\n<h4 id=\"malloc函数使用注意事项\"><a class=\"markdownIt-Anchor\" href=\"#malloc函数使用注意事项\">#</a> malloc 函数使用注意事项</h4>\n<p>malloc 函数的返回的是无类型指针，在使用时一定要强制转换为所需要的类型。<br>\n在使用 malloc 开辟空间时，使用完成一定要释放空间，如果不释放会造内存泄漏。<br>\n在使用 malloc 函数开辟的空间中，不要进行指针的移动，因为一旦移动之后可能出现申请的空间和释放空间大小的不匹配</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;malloc.h&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std ; </span><br><span class=\"line\"></span><br><span class=\"line\">struct node &#123;</span><br><span class=\"line\">    int value ; </span><br><span class=\"line\">    struct node * next ; </span><br><span class=\"line\">&#125; ; </span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct node Node ; </span><br><span class=\"line\">//创造节点</span><br><span class=\"line\">Node * create_node ( Node * head , int value ) &#123;</span><br><span class=\"line\">    Node * t_node = ( Node * ) malloc ( sizeof ( Node ) ) ; //千万不可自己去计算数据填入!!!</span><br><span class=\"line\">    if ( ! t_node ) &#123; printf ( &quot;failed&quot; ) ; exit ( -1 ) ; &#125;</span><br><span class=\"line\">    t_node -&gt; value = value ; // ( * t_node ).value ; </span><br><span class=\"line\">    t_node -&gt; next = head ; //</span><br><span class=\"line\">    return t_node ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//搜索目标节点</span><br><span class=\"line\">Node * search_node ( int val , Node * head ) &#123;</span><br><span class=\"line\">    for ( Node * p = head ; p ; p = p -&gt; next ) &#123;</span><br><span class=\"line\">        if ( p -&gt; value == val ) return p ; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0 ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//删除节点，直接越过目标节点进行连接</span><br><span class=\"line\">Node * delete_node ( Node * head , int n ) &#123;</span><br><span class=\"line\">    Node * pre , * cur ;</span><br><span class=\"line\">    for ( pre = 0 , cur = head ; cur &amp;&amp; cur -&gt; value != n ; pre = cur , cur = cur -&gt; next ) ; </span><br><span class=\"line\">    if ( ! cur ) return head ; </span><br><span class=\"line\">    if ( ! pre ) head = head -&gt; next ; </span><br><span class=\"line\">    else pre -&gt; next = cur -&gt; next ; </span><br><span class=\"line\">    free ( cur ) ; cur = NULL ; //指向NULL养成好习惯</span><br><span class=\"line\">    return head ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main ( ) &#123;</span><br><span class=\"line\">    Node * head = 0 ;  </span><br><span class=\"line\">    while ( 1 ) &#123;</span><br><span class=\"line\">        int val ; scanf ( &quot;%d&quot; , &amp; val ) ; </span><br><span class=\"line\">        if ( val == -1 ) break ; </span><br><span class=\"line\">        head = create_node ( head , val ) ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int find_val ; scanf ( &quot;%d&quot; , &amp; find_val ) ; </span><br><span class=\"line\">    Node * goal = search_node ( find_val , head ) ; </span><br><span class=\"line\">    return 0 ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "指针",
                "c语言"
            ]
        },
        {
            "id": "http://amentiraz.github.io/2021/09/19/c%E5%A4%8D%E4%B9%A0/",
            "url": "http://amentiraz.github.io/2021/09/19/c%E5%A4%8D%E4%B9%A0/",
            "title": "c复习",
            "date_published": "2021-09-19T06:32:11.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>\n    <div id=\"aplayer-XGhDTRyH\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"578090\" data-server=\"netease\" data-type=\"song\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"none\" data-theme=\"#ad7a86\"\n    ></div>\n<p>这篇文章是大一刚开学对 c 的复习，十分的不全面，看看就行。</p>\n<span id=\"more\"></span>\n<p>程序设计语言<br>\n机器语言 汇编语言 高级语言<br>\n return 0 ; return 表示 main 函数结束，0 表示程序在退出时给执行此程序的操作系统返回来一个结果，即返回值。</p>\n<h3 id=\"c程序的构成\"><a class=\"markdownIt-Anchor\" href=\"#c程序的构成\">#</a> c 程序的构成</h3>\n<h4 id=\"预处理部分\"><a class=\"markdownIt-Anchor\" href=\"#预处理部分\">#</a> 预处理部分</h4>\n<ol>\n<li>宏定义：#define 指令定义一个宏，#undef 指令删除一个宏定义</li>\n<li>头文件包含：#include</li>\n<li>条件编译语句：#if、#ifdef、#ifndef、#else 和 #endif 指令根据预处理器可以测试的条件来确定是将一段文本块包含到程序还是将其排除在外</li>\n</ol>\n<h4 id=\"说明部分\"><a class=\"markdownIt-Anchor\" href=\"#说明部分\">#</a> 说明部分</h4>\n<ol>\n<li>全局变量</li>\n<li>常量：#define PI 3.1416926f \\ const float PI 3.1415926</li>\n<li>函数声明</li>\n</ol>\n<h4 id=\"执行部分\"><a class=\"markdownIt-Anchor\" href=\"#执行部分\">#</a> 执行部分</h4>\n<ol>\n<li>主函数</li>\n<li>其他函数</li>\n</ol>\n<h3 id=\"标识符\"><a class=\"markdownIt-Anchor\" href=\"#标识符\">#</a> 标识符</h3>\n<p>由数字、字母和下划线字符构成的一个连续序列，不能有空白字符。<br>\n区分大小写</p>\n<h3 id=\"整型数据的分类\"><a class=\"markdownIt-Anchor\" href=\"#整型数据的分类\">#</a> 整型数据的分类</h3>\n<p>基本整型（int）、短整型（short int）和长整型（long int）<br>\nint 的取值范围 - 2147483648 与 2147483647（2^31-1)、字节数 4<br>\nshort (int) 的取值范围 -32768 与 32767 之间、字节数 2<br>\nlong (int) 主流编译器一般规定其取值范围与基本 int 类型相同、字节数 4<br>\nC 语言还提供了有符号和无符号整数类型<br>\n若希望表达非负整数，可以定义无符号整型，即在类型符号前面加上修饰符 unsigned<br>\n 加上 unsigned 变成原来的两倍、字节数不变<br>\n如：unsigned int : 0 ~ 4294967295</p>\n<h3 id=\"整型常数的书写形式\"><a class=\"markdownIt-Anchor\" href=\"#整型常数的书写形式\">#</a> 整型常数的书写形式</h3>\n<ol>\n<li>十进制形式</li>\n<li>八进制形式： 以 0 开头，如 0100、0123、0123456</li>\n<li>十六进制形式：以 0x 开头，如 0x100、0x123</li>\n<li>整型数据的储存形式：在计算机内部通常采用补码形式储存</li>\n</ol>\n<h3 id=\"补码-后面再补充相应知识\"><a class=\"markdownIt-Anchor\" href=\"#补码-后面再补充相应知识\">#</a> 补码 （ 后面再补充相应知识 ）</h3>\n<h3 id=\"浮点数类型\"><a class=\"markdownIt-Anchor\" href=\"#浮点数类型\">#</a> 浮点数类型</h3>\n<p>C 语言把浮点数类型分为 float（单精度浮点型）、double（双精度浮点型）和 long double （长双精度浮点型）<br>\n如表所示</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>字节数</th>\n<th>有效位数</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foat</td>\n<td>4</td>\n<td>6</td>\n<td>-3.4 * 10^38 ~ 3.4 * 10^38</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8</td>\n<td>15</td>\n<td>-1.7 * 10^308 ~ 3.4 * 10^308</td>\n</tr>\n<tr>\n<td>long double</td>\n<td>16</td>\n<td>19</td>\n<td>-1.2 * 10^4932 ~ 3.4 * 10^4932</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"浮点数的书写形式\"><a class=\"markdownIt-Anchor\" href=\"#浮点数的书写形式\">#</a> 浮点数的书写形式</h3>\n<ol>\n<li>当小数点前后的数是零时，可以省略 0，但是小数点不能省略如 5. 和.5 分别表示 5.0 和 0.5</li>\n<li>指数形式 ： 如 4.5678E2 代表 4.5678 * 10^2 \\ -5.7e-3 代表 - 5.7 * 10^-3 （E 和 e 本质是一样的）</li>\n</ol>\n<p>默认情况下，浮点型常数为 double 型。可以在浮点型常数后面加上 F (f) 以表示 float 型；也可以在浮点型常数后面加上 L (l）表示 long double 型</p>\n<h3 id=\"字符类型\"><a class=\"markdownIt-Anchor\" href=\"#字符类型\">#</a> 字符类型</h3>\n<p>ASCII 字符集的特征：0～9、26 个大写英文字母以及 26 哥消协的英文字母的编码各自是连续的<br>\n如：A 的编码加上 25 是 Z 的编码</p>\n<p>char 类型来描述单字节编码字符集中的字符类型数据<br>\n C 还提供了 [signed] char 和 unsigned char 类型，他们的区别在于：在参加算术运算时，把字符的编码当作有符号整数还是无符号整数来看待</p>\n<h4 id=\"字符型常量的三种书写方式\"><a class=\"markdownIt-Anchor\" href=\"#字符型常量的三种书写方式\">#</a> 字符型常量的三种书写方式：</h4>\n<ol>\n<li>以一对单引号括起来的一个字符：‘A’‘1’</li>\n<li>以字符对应的 ASCII 码来表示，这时必须用转义序列（以反斜杠开头的一串字符）</li>\n</ol>\n<ul>\n<li>八进制：’\\ddd’如’101’为字母 A 的 ASCII 码的八进制表示</li>\n<li>十六进制：’\\xhh’如’\\x41’为字母 A 的 ASCII 码的十六进制表示</li>\n</ul>\n<ol start=\"3\">\n<li>特殊的转移序列符号表示</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\a</td>\n<td>响铃</td>\n<td>\\v</td>\n<td>纵向制表</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>退格</td>\n<td>’</td>\n<td>单引号</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>换页</td>\n<td>‘’</td>\n<td>双引号</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>换行</td>\n<td>\\ | 反斜杠</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车</td>\n<td>\\0</td>\n<td>字符串结束</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td colspan=\"2\">横向制表</td>\n</tr>\n</tbody>\n</table>\n<p>“Please enter “Y” or “N”:<br>\n 当字符串包含双引号 &quot; 时，双引号应写成：”<br>\n 字符常量表示单个字符，字符串常量可表示多个字符<br>\n字符常量用’' 表示，字符串常量用 &quot;&quot; 表示<br>\n在储存字符串时，通常在最后一个字符后面储存一个表示字符串结束的标记符号</p>\n<p>两个实数相除的结果是双精度实数，两个整数相除的结果是整数</p>\n<h3 id=\"常用运算符的优先级与结合性\"><a class=\"markdownIt-Anchor\" href=\"#常用运算符的优先级与结合性\">#</a> 常用运算符的优先级与结合性</h3>\n<p>自行百度</p>\n<h3 id=\"输入输出语句\"><a class=\"markdownIt-Anchor\" href=\"#输入输出语句\">#</a> 输入输出语句</h3>\n<p>printf ( ) ; scanf ( ) ; getchar ( ) ; putchar ( ) ; puts ( ) ; gets ( ) ;</p>\n<h3 id=\"头文件\"><a class=\"markdownIt-Anchor\" href=\"#头文件\">#</a> 头文件</h3>\n<p>/#include&lt; &gt; 表示直接去查找系统的源文件<br>\n /#include&quot; &quot; 表示先去找用户存放源文件的子目录再去找系统文件<br>\n如果是自己写的头文件必须用第二种<br>\n如果头文件不在当前目录中，可以在双引号中写出文件路径 (#include “C:\\temp\\file.h”</p>\n<h3 id=\"scanf-与-printf\"><a class=\"markdownIt-Anchor\" href=\"#scanf-与-printf\">#</a> scanf 与 printf</h3>\n<p>特别的，scanf (“%2d%2d” , &amp; a , &amp; b ) ; 输入的数据可以为 1234<br>\n 则 a = 12 , b = 34 ；<br>\n如果 scanf (“a=% d,b=% d\\n” , &amp; a , &amp; b ) ;<br>\n 则用户必须输入 a=12,b=34 ;<br>\n 如果是 scanf (“% d * % d” , &amp; a , &amp; b ) ;<br>\n 那么用户输入 12，34｜12#34 都会得到正确的结果，因为 * 为忽略输入修饰符<br>\n scanf 输入时如果是 % c 那么空格也会被读入</p>\n<h3 id=\"空语句\"><a class=\"markdownIt-Anchor\" href=\"#空语句\">#</a> 空语句</h3>\n<p>空语句不做任何事情其作用是用于语法上需要一条语句的地方，而该地方又不需要做任何事情；例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    goto end ; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    end : ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 1 , sum = 0 ; </span><br><span class=\"line\">for ( ; i &lt;= 100 ; sum += i , i ++ ) ; </span><br></pre></td></tr></table></figure>\n<h3 id=\"switch-语句\"><a class=\"markdownIt-Anchor\" href=\"#switch-语句\">#</a> switch 语句</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch( &lt;整式表达式&gt; ) &#123; </span><br><span class=\"line\">    case 常量1: 语句序列1 ; break ; </span><br><span class=\"line\">    case 常量2: 语句序列2 ; break ;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    default ; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>常量可为 1、2、3；‘c’、‘a’…</p>\n<p>case 常量 1: 语句序列 1 ; break ;</p>\n",
            "tags": [
                "学习笔记",
                "C语言",
                "复习资料"
            ]
        }
    ]
}